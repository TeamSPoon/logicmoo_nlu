:-include(library('ec_planner/ec_test_incl')).
:-expects_dialect(pfc).
 %  loading(load_e_pl,'ec_reader_test.e').


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/Root.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:17
% sort boolean
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:18
==> sort(boolean).

% sort integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:19
==> sort(integer).

% reified sort predicate
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:20
reified_sort(predicate).
==> mpred_prop(predicate,reified_sort).

% reified sort function
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:21
reified_sort(function).
==> mpred_prop(function,reified_sort).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/EC.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Event Calculus (EC)
%;
%; @incollection{MillerShanahan:2002,
%;   author = "Rob Miller and Murray Shanahan",
%;   year = "2002",
%;   title = "Some alternative formulations of the event calculus",
%;   editor = "Antonis C. Kakas and Fariba Sadri",
%;   booktitle = "Computational Logic: Logic Programming and Beyond: Essays in Honour of \uppercase{R}obert \uppercase{A}. \uppercase{K}owalski, Part \uppercase{II}",
%;   series = "Lecture Notes in Computer Science",
%;   volume = "2408",
%;   pages = "452--490",
%;   address = "Berlin",
%;   publisher = "Springer",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:56
% sort time: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:57
==> subsort(time,integer).

% sort offset: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:58
==> subsort(offset,integer).

% reified sort fluent
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:60
reified_sort(fluent).
==> mpred_prop(fluent,reified_sort).

% reified sort event
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:61
reified_sort(event).
==> mpred_prop(event,reified_sort).

% predicate Happens(event,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:63
predicate(happens(Happens_Param,Maptime)).
==> mpred_prop(happens(event,time),predicate).
==> meta_argtypes(happens(event,time)).

% predicate HoldsAt(fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:64
predicate(holds_at(Holds_at_Param,Time)).
==> mpred_prop(holds_at(fluent,time),predicate).
==> meta_argtypes(holds_at(fluent,time)).

% predicate ReleasedAt(fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:65
predicate(releasedAt(ReleasedAt_Param,Time)).
==> mpred_prop(releasedAt(fluent,time),predicate).
==> meta_argtypes(releasedAt(fluent,time)).

% predicate Initiates(event,fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:66
predicate(initiates(Initiates_Param,_,Initiates_Ret)).
==> mpred_prop(initiates(event,fluent,time),predicate).
==> meta_argtypes(initiates(event,fluent,time)).

% predicate Terminates(event,fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:67
predicate(terminates(Terminates_Param,
		     _,
		     Terminates_Ret)).
==> mpred_prop(terminates(event,fluent,time),predicate).
==> meta_argtypes(terminates(event,fluent,time)).

% predicate Releases(event,fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:68
predicate(releases(Releases_Param,_,Releases_Ret)).
==> mpred_prop(releases(event,fluent,time),predicate).
==> meta_argtypes(releases(event,fluent,time)).

% predicate Trajectory(fluent,time,fluent,offset)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:69
predicate(trajectory(Trajectory_Param,
		     _,
		     _,
		     Trajectory_Ret)).
==> mpred_prop(trajectory(fluent,time,fluent,offset),predicate).
==> meta_argtypes(trajectory(fluent,time,fluent,offset)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:70
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/DEC.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Discrete Event Calculus (DEC)
%;
%; @article{Mueller:2004a,
%;   author = "Erik T. Mueller",
%;   year = "2004",
%;   title = "Event calculus reasoning through satisfiability",
%;   journal = "Journal of Logic and Computation",
%;   volume = "14",
%;   number = "5",
%;   pages = "703--730",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:101
% sort time: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:102
==> subsort(time,integer).

% sort offset: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:103
==> subsort(offset,integer).

% reified sort fluent
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:105
reified_sort(fluent).
==> mpred_prop(fluent,reified_sort).

% reified sort event
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:106
reified_sort(event).
==> mpred_prop(event,reified_sort).

% predicate Happens(event,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:108
predicate(happens(Happens_Param,Maptime)).
==> mpred_prop(happens(event,time),predicate).
==> meta_argtypes(happens(event,time)).

% predicate HoldsAt(fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:109
predicate(holds_at(Holds_at_Param,Time)).
==> mpred_prop(holds_at(fluent,time),predicate).
==> meta_argtypes(holds_at(fluent,time)).

% predicate ReleasedAt(fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:110
predicate(releasedAt(ReleasedAt_Param,Time)).
==> mpred_prop(releasedAt(fluent,time),predicate).
==> meta_argtypes(releasedAt(fluent,time)).

% predicate Initiates(event,fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:112
predicate(initiates(Initiates_Param,_,Initiates_Ret)).
==> mpred_prop(initiates(event,fluent,time),predicate).
==> meta_argtypes(initiates(event,fluent,time)).

% predicate Terminates(event,fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:113
predicate(terminates(Terminates_Param,
		     _,
		     Terminates_Ret)).
==> mpred_prop(terminates(event,fluent,time),predicate).
==> meta_argtypes(terminates(event,fluent,time)).

% predicate Releases(event,fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:114
predicate(releases(Releases_Param,_,Releases_Ret)).
==> mpred_prop(releases(event,fluent,time),predicate).
==> meta_argtypes(releases(event,fluent,time)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:115
% [fluent,time]
% (HoldsAt(fluent,time) &
%  !ReleasedAt(fluent,time+1) &
%  !({event} Happens(event,time) & Terminates(event,fluent,time))) ->
% HoldsAt(fluent,time+1).

 /*  allDifferent([Fluent, Time, Event]) ->
       ( holds_at(Fluent, Time), not(releasedAt(Fluent, Time+1)), not(exists([Event],  (happens(Event, Time), terminates(Event, Fluent, Time))))->holds_at(Fluent, Time+1)
       ).
 */

 /*  holds_at(Fluent, Time+1) :-
       ( holds_at(Fluent, Time),
         not(releasedAt(Fluent, Time+1)),
         (   not(happens(Event, Time))
         ;   not(terminates(Event, Fluent, Time))
         )
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [holds_at(Fluent, Time), not(releasedAt(Fluent, Time+1)),  (not(happens(Event, Time));not(terminates(Event, Fluent, Time))), allDifferent([Fluent, Time, Event]), b(Time, Time3), ignore(Time+1==Time3)] ->
       ta(Time, holds_at(Fluent, Time3)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:119
axiom(holds_at(Fluent, Time3),
   
    [ holds_at(Fluent, Time),
      not(releasedAt(Fluent, Time3)),
       (not(happens(Event, Time));not(terminates(Event, Fluent, Time))),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time3)
    ]).

 /*  not(holds_at(Fluent, Time)) :-
       ( not(releasedAt(Fluent, Time+1)),
         (   not(happens(Event, Time))
         ;   not(terminates(Event, Fluent, Time))
         )
       ),
       not(holds_at(Fluent, Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [not(releasedAt(Fluent, Time+1)),  (not(happens(Event, Time));not(terminates(Event, Fluent, Time))), holds_at(neg(Fluent), Time4), allDifferent([Fluent, Time, Event]), b(Time, Time4), ignore(Time+1==Time4)] ->
       ta(Time, holds_at(neg(Fluent), Time)).
 */
axiom(holds_at(neg(Fluent), Time),
   
    [ not(releasedAt(Fluent, Time4)),
       (not(happens(Event, Time));not(terminates(Event, Fluent, Time))),
      holds_at(neg(Fluent), Time4),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time4)
    ]).

 /*  releasedAt(Fluent, Time+1) :-
       (   not(happens(Event, Time))
       ;   not(terminates(Event, Fluent, Time))
       ),
       holds_at(Fluent, Time),
       not(holds_at(Fluent, Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(not(happens(Event, Time));not(terminates(Event, Fluent, Time))), holds_at(Fluent, Time), holds_at(neg(Fluent), Time5), allDifferent([Fluent, Time, Event]), b(Time, Time5), ignore(Time+1==Time5)] ->
       ta(Time, releasedAt(Fluent, Time+1)).
 */
axiom(releasedAt(Fluent, Time5),
   
    [  (not(happens(Event, Time));not(terminates(Event, Fluent, Time))),
      holds_at(Fluent, Time),
      holds_at(neg(Fluent), Time5),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time5)
    ]).

 /*  happens(Event, Time) :-
       not(releasedAt(Fluent, Time+1)),
       holds_at(Fluent, Time),
       not(holds_at(Fluent, Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [not(releasedAt(Fluent, Time+1)), holds_at(Fluent, Time), holds_at(neg(Fluent), Time6), allDifferent([Fluent, Time, Event]), b(Time, Time6), ignore(Time+1==Time6)] ->
       ta(Time, happens(Event, Time)).
 */
axiom(happens(Event, Time),
   
    [ not(releasedAt(Fluent, Time6)),
      holds_at(Fluent, Time),
      holds_at(neg(Fluent), Time6),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time6)
    ]).

 /*  terminates(Event, Fluent, Time) :-
       not(releasedAt(Fluent, Time+1)),
       holds_at(Fluent, Time),
       not(holds_at(Fluent, Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [not(releasedAt(Fluent, Time+1)), holds_at(Fluent, Time), holds_at(neg(Fluent), Time7), allDifferent([Fluent, Time, Event]), b(Time, Time7), ignore(Time+1==Time7)] ->
       ta(Time, terminates(Event, Fluent, Time)).
 */
axiom(terminates(Event, Fluent, Time),
   
    [ not(releasedAt(Fluent, Time7)),
      holds_at(Fluent, Time),
      holds_at(neg(Fluent), Time7),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time7)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:121
% [fluent,time]
% (!HoldsAt(fluent,time) &
%  !ReleasedAt(fluent,time+1) &
%  !({event} Happens(event,time) & Initiates(event,fluent,time))) ->
% !HoldsAt(fluent,time+1).

 /*  allDifferent([Fluent, Time, Event]) ->
       ( holds_at(neg(Fluent), Time), not(releasedAt(Fluent, Time+1)), not(exists([Event],  (happens(Event, Time), initiates(Event, Fluent, Time))))->holds_at(neg(Fluent), Time+1)
       ).
 */

 /*  holds_at(neg(Fluent), Time+1) :-
       ( holds_at(neg(Fluent), Time),
         not(releasedAt(Fluent, Time+1)),
         (   not(happens(Event, Time))
         ;   not(initiates(Event, Fluent, Time))
         )
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [holds_at(neg(Fluent), Time), not(releasedAt(Fluent, Time+1)),  (not(happens(Event, Time));not(initiates(Event, Fluent, Time))), allDifferent([Fluent, Time, Event]), b(Time, Time3), ignore(Time+1==Time3)] ->
       ta(Time, holds_at(neg(Fluent), Time3)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:125
axiom(holds_at(neg(Fluent), Time3),
   
    [ holds_at(neg(Fluent), Time),
      not(releasedAt(Fluent, Time3)),
       (not(happens(Event, Time));not(initiates(Event, Fluent, Time))),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time3)
    ]).

 /*  not(holds_at(neg(Fluent), Time)) :-
       ( not(releasedAt(Fluent, Time+1)),
         (   not(happens(Event, Time))
         ;   not(initiates(Event, Fluent, Time))
         )
       ),
       not(holds_at(neg(Fluent), Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [not(releasedAt(Fluent, Time+1)),  (not(happens(Event, Time));not(initiates(Event, Fluent, Time))), holds_at(neg(neg(Fluent)), Time4), allDifferent([Fluent, Time, Event]), b(Time, Time4), ignore(Time+1==Time4)] ->
       ta(Time, holds_at(neg(neg(Fluent)), Time)).
 */
axiom(holds_at(neg(neg(Fluent)), Time),
   
    [ not(releasedAt(Fluent, Time4)),
       (not(happens(Event, Time));not(initiates(Event, Fluent, Time))),
      holds_at(neg(neg(Fluent)), Time4),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time4)
    ]).

 /*  releasedAt(Fluent, Time+1) :-
       (   not(happens(Event, Time))
       ;   not(initiates(Event, Fluent, Time))
       ),
       holds_at(neg(Fluent), Time),
       not(holds_at(neg(Fluent), Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(not(happens(Event, Time));not(initiates(Event, Fluent, Time))), holds_at(neg(Fluent), Time), holds_at(neg(neg(Fluent)), Time5), allDifferent([Fluent, Time, Event]), b(Time, Time5), ignore(Time+1==Time5)] ->
       ta(Time, releasedAt(Fluent, Time+1)).
 */
axiom(releasedAt(Fluent, Time5),
   
    [  (not(happens(Event, Time));not(initiates(Event, Fluent, Time))),
      holds_at(neg(Fluent), Time),
      holds_at(neg(neg(Fluent)), Time5),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time5)
    ]).

 /*  happens(Event, Time) :-
       not(releasedAt(Fluent, Time+1)),
       holds_at(neg(Fluent), Time),
       not(holds_at(neg(Fluent), Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [not(releasedAt(Fluent, Time+1)), holds_at(neg(Fluent), Time), holds_at(neg(neg(Fluent)), Time6), allDifferent([Fluent, Time, Event]), b(Time, Time6), ignore(Time+1==Time6)] ->
       ta(Time, happens(Event, Time)).
 */
axiom(happens(Event, Time),
   
    [ not(releasedAt(Fluent, Time6)),
      holds_at(neg(Fluent), Time),
      holds_at(neg(neg(Fluent)), Time6),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time6)
    ]).

 /*  initiates(Event, Fluent, Time) :-
       not(releasedAt(Fluent, Time+1)),
       holds_at(neg(Fluent), Time),
       not(holds_at(neg(Fluent), Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [not(releasedAt(Fluent, Time+1)), holds_at(neg(Fluent), Time), holds_at(neg(neg(Fluent)), Time7), allDifferent([Fluent, Time, Event]), b(Time, Time7), ignore(Time+1==Time7)] ->
       ta(Time, initiates(Event, Fluent, Time)).
 */
axiom(initiates(Event, Fluent, Time),
   
    [ not(releasedAt(Fluent, Time7)),
      holds_at(neg(Fluent), Time),
      holds_at(neg(neg(Fluent)), Time7),
      allDifferent([Fluent, Time, Event]),
      b(Time, Time7)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:127
% [fluent,time]
% (!ReleasedAt(fluent,time) &
%  !({event} Happens(event,time) & Releases(event,fluent,time))) ->
% !ReleasedAt(fluent,time+1).

 /*  allDifferent([Fluent, Time, Event]) ->
       ( not(releasedAt(Fluent, Time)), not(exists([Event],  (happens(Event, Time), releases(Event, Fluent, Time))))->not(releasedAt(Fluent, Time+1))
       ).
 */

 /*  not(releasedAt(Fluent, Time+1)) :-
       ( not(releasedAt(Fluent, Time)),
         (   not(happens(Event, Time))
         ;   not(releases(Event, Fluent, Time))
         )
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time3), b(Time, Time3), not(releasedAt(Fluent, Time)),  (not(happens(Event, Time));not(releases(Event, Fluent, Time))), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(releasedAt(Fluent, Time3))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:130
axiom(not(releasedAt(Fluent, Time3)),
   
    [ b(Time, Time3),
      not(releasedAt(Fluent, Time)),
       (not(happens(Event, Time));not(releases(Event, Fluent, Time))),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  releasedAt(Fluent, Time) :-
       (   not(happens(Event, Time))
       ;   not(releases(Event, Fluent, Time))
       ),
       releasedAt(Fluent, Time+1),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time4), b(Time, Time4),  (not(happens(Event, Time));not(releases(Event, Fluent, Time))), releasedAt(Fluent, Time4), allDifferent([Fluent, Time, Event])] ->
       ta(Time, releasedAt(Fluent, Time)).
 */
axiom(releasedAt(Fluent, Time),
   
    [ b(Time, Time4),
       (not(happens(Event, Time));not(releases(Event, Fluent, Time))),
      releasedAt(Fluent, Time4),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  happens(Event, Time) :-
       not(releasedAt(Fluent, Time)),
       releasedAt(Fluent, Time+1),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time5), b(Time, Time5), not(releasedAt(Fluent, Time)), releasedAt(Fluent, Time5), allDifferent([Fluent, Time, Event])] ->
       ta(Time, happens(Event, Time)).
 */
axiom(happens(Event, Time),
   
    [ b(Time, Time5),
      not(releasedAt(Fluent, Time)),
      releasedAt(Fluent, Time5),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  releases(Event, Fluent, Time) :-
       not(releasedAt(Fluent, Time)),
       releasedAt(Fluent, Time+1),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time6), b(Time, Time6), not(releasedAt(Fluent, Time)), releasedAt(Fluent, Time6), allDifferent([Fluent, Time, Event])] ->
       ta(Time, releases(Event, Fluent, Time)).
 */
axiom(releases(Event, Fluent, Time),
   
    [ b(Time, Time6),
      not(releasedAt(Fluent, Time)),
      releasedAt(Fluent, Time6),
      allDifferent([Fluent, Time, Event])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:132
% [fluent,time]
% (ReleasedAt(fluent,time) &
%  !({event} Happens(event,time) &
%    (Initiates(event,fluent,time) |
%     Terminates(event,fluent,time)))) ->
% ReleasedAt(fluent,time+1).

 /*  allDifferent([Fluent, Time, Event]) ->
       ( releasedAt(Fluent, Time), not(exists([Event],  (happens(Event, Time), (initiates(Event, Fluent, Time);terminates(Event, Fluent, Time)))))->releasedAt(Fluent, Time+1)
       ).
 */

 /*  releasedAt(Fluent, Time+1) :-
       ( releasedAt(Fluent, Time),
         (   not(happens(Event, Time))
         ;   not(initiates(Event, Fluent, Time)),
             not(terminates(Event, Fluent, Time))
         )
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time3), b(Time, Time3), releasedAt(Fluent, Time),  (not(happens(Event, Time));not(initiates(Event, Fluent, Time)), not(terminates(Event, Fluent, Time))), allDifferent([Fluent, Time, Event])] ->
       ta(Time, releasedAt(Fluent, Time3)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:137
axiom(releasedAt(Fluent, Time3),
   
    [ b(Time, Time3),
      releasedAt(Fluent, Time),
       (not(happens(Event, Time));not(initiates(Event, Fluent, Time)), not(terminates(Event, Fluent, Time))),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(releasedAt(Fluent, Time)) :-
       (   not(happens(Event, Time))
       ;   not(initiates(Event, Fluent, Time)),
           not(terminates(Event, Fluent, Time))
       ),
       not(releasedAt(Fluent, Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time4), b(Time, Time4),  (not(happens(Event, Time));not(initiates(Event, Fluent, Time)), not(terminates(Event, Fluent, Time))), not(releasedAt(Fluent, Time4)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(releasedAt(Fluent, Time))).
 */
axiom(not(releasedAt(Fluent, Time)),
   
    [ b(Time, Time4),
       (not(happens(Event, Time));not(initiates(Event, Fluent, Time)), not(terminates(Event, Fluent, Time))),
      not(releasedAt(Fluent, Time4)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  happens(Event, Time) :-
       releasedAt(Fluent, Time),
       not(releasedAt(Fluent, Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time5), b(Time, Time5), releasedAt(Fluent, Time), not(releasedAt(Fluent, Time5)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, happens(Event, Time)).
 */
axiom(happens(Event, Time),
   
    [ b(Time, Time5),
      releasedAt(Fluent, Time),
      not(releasedAt(Fluent, Time5)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  initiates(Event, Fluent, Time) :-
       not(terminates(Event, Fluent, Time)),
       releasedAt(Fluent, Time),
       not(releasedAt(Fluent, Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time6), b(Time, Time6), not(terminates(Event, Fluent, Time)), releasedAt(Fluent, Time), not(releasedAt(Fluent, Time6)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, initiates(Event, Fluent, Time)).
 */
axiom(initiates(Event, Fluent, Time),
   
    [ b(Time, Time6),
      not(terminates(Event, Fluent, Time)),
      releasedAt(Fluent, Time),
      not(releasedAt(Fluent, Time6)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  terminates(Event, Fluent, Time) :-
       not(initiates(Event, Fluent, Time)),
       releasedAt(Fluent, Time),
       not(releasedAt(Fluent, Time+1)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [ignore(Time+1==Time7), b(Time, Time7), not(initiates(Event, Fluent, Time)), releasedAt(Fluent, Time), not(releasedAt(Fluent, Time7)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, terminates(Event, Fluent, Time)).
 */
axiom(terminates(Event, Fluent, Time),
   
    [ b(Time, Time7),
      not(initiates(Event, Fluent, Time)),
      releasedAt(Fluent, Time),
      not(releasedAt(Fluent, Time7)),
      allDifferent([Fluent, Time, Event])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:139
% [event,fluent,time]
% (Happens(event,time) & Initiates(event,fluent,time)) ->
% (HoldsAt(fluent,time+1) & !ReleasedAt(fluent,time+1)).

 /*  allDifferent([Event, Time, Fluent]) ->
       ( happens(Event, Time), initiates(Event, Fluent, Time)->holds_at(Fluent, Time+1), not(releasedAt(Fluent, Time+1))
       ).
 */

 /*  not(happens(Event, Time)) :-
       initiates(Event, Fluent, Time),
       (   not(holds_at(Fluent, Time+1))
       ;   releasedAt(Fluent, Time+1)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(Fluent, Time+1))
       ;   releasedAt(Fluent, Time+1)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(Fluent), Time+1)
       ;   releasedAt(Fluent, Time+1)
       ).
 */

 /*  [ignore(Time+1==Time3), b(Time, Time3), initiates(Event, Fluent, Time),  (holds_at(neg(Fluent), Time3);releasedAt(Fluent, Time3)), allDifferent([Event, Time, Fluent])] ->
       ta(Time, not(happens(Event, Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:141
axiom(not(happens(Event, Time)),
   
    [ b(Time, Time3),
      initiates(Event, Fluent, Time),
       (holds_at(neg(Fluent), Time3);releasedAt(Fluent, Time3)),
      allDifferent([Event, Time, Fluent])
    ]).

 /*  not(initiates(Event, Fluent, Time)) :-
       happens(Event, Time),
       (   not(holds_at(Fluent, Time+1))
       ;   releasedAt(Fluent, Time+1)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(Fluent, Time+1))
       ;   releasedAt(Fluent, Time+1)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(Fluent), Time+1)
       ;   releasedAt(Fluent, Time+1)
       ).
 */

 /*  [ignore(Time+1==Time4), b(Time, Time4), happens(Event, Time),  (holds_at(neg(Fluent), Time4);releasedAt(Fluent, Time4)), allDifferent([Event, Time, Fluent])] ->
       ta(Time, not(initiates(Event, Fluent, Time))).
 */
axiom(not(initiates(Event, Fluent, Time)),
   
    [ b(Time, Time4),
      happens(Event, Time),
       (holds_at(neg(Fluent), Time4);releasedAt(Fluent, Time4)),
      allDifferent([Event, Time, Fluent])
    ]).

 /*  holds_at(Fluent, Time+1) :-
       ( happens(Event, Time),
         initiates(Event, Fluent, Time)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  [happens(Event, Time), initiates(Event, Fluent, Time), allDifferent([Event, Time, Fluent]), b(Time, Time5), ignore(Time+1==Time5)] ->
       ta(Time, holds_at(Fluent, Time5)).
 */
axiom(holds_at(Fluent, Time5),
   
    [ happens(Event, Time),
      initiates(Event, Fluent, Time),
      allDifferent([Event, Time, Fluent]),
      b(Time, Time5)
    ]).

 /*  not(releasedAt(Fluent, Time+1)) :-
       ( happens(Event, Time),
         initiates(Event, Fluent, Time)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  [ignore(Time+1==Time6), b(Time, Time6), happens(Event, Time), initiates(Event, Fluent, Time), allDifferent([Event, Time, Fluent])] ->
       ta(Time, not(releasedAt(Fluent, Time6))).
 */
axiom(not(releasedAt(Fluent, Time6)),
   
    [ b(Time, Time6),
      happens(Event, Time),
      initiates(Event, Fluent, Time),
      allDifferent([Event, Time, Fluent])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:143
% [event,fluent,time]
% (Happens(event,time) & Terminates(event,fluent,time)) ->
% (!HoldsAt(fluent,time+1) & !ReleasedAt(fluent,time+1)).

 /*  allDifferent([Event, Time, Fluent]) ->
       ( happens(Event, Time), terminates(Event, Fluent, Time)->holds_at(neg(Fluent), Time+1), not(releasedAt(Fluent, Time+1))
       ).
 */

 /*  not(happens(Event, Time)) :-
       terminates(Event, Fluent, Time),
       (   not(holds_at(neg(Fluent), Time+1))
       ;   releasedAt(Fluent, Time+1)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(neg(Fluent), Time+1))
       ;   releasedAt(Fluent, Time+1)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(neg(Fluent)), Time+1)
       ;   releasedAt(Fluent, Time+1)
       ).
 */

 /*  [ignore(Time+1==Time3), b(Time, Time3), terminates(Event, Fluent, Time),  (holds_at(neg(neg(Fluent)), Time3);releasedAt(Fluent, Time3)), allDifferent([Event, Time, Fluent])] ->
       ta(Time, not(happens(Event, Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:145
axiom(not(happens(Event, Time)),
   
    [ b(Time, Time3),
      terminates(Event, Fluent, Time),
       (holds_at(neg(neg(Fluent)), Time3);releasedAt(Fluent, Time3)),
      allDifferent([Event, Time, Fluent])
    ]).

 /*  not(terminates(Event, Fluent, Time)) :-
       happens(Event, Time),
       (   not(holds_at(neg(Fluent), Time+1))
       ;   releasedAt(Fluent, Time+1)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(neg(Fluent), Time+1))
       ;   releasedAt(Fluent, Time+1)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(neg(Fluent)), Time+1)
       ;   releasedAt(Fluent, Time+1)
       ).
 */

 /*  [ignore(Time+1==Time4), b(Time, Time4), happens(Event, Time),  (holds_at(neg(neg(Fluent)), Time4);releasedAt(Fluent, Time4)), allDifferent([Event, Time, Fluent])] ->
       ta(Time, not(terminates(Event, Fluent, Time))).
 */
axiom(not(terminates(Event, Fluent, Time)),
   
    [ b(Time, Time4),
      happens(Event, Time),
       (holds_at(neg(neg(Fluent)), Time4);releasedAt(Fluent, Time4)),
      allDifferent([Event, Time, Fluent])
    ]).

 /*  holds_at(neg(Fluent), Time+1) :-
       ( happens(Event, Time),
         terminates(Event, Fluent, Time)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  [happens(Event, Time), terminates(Event, Fluent, Time), allDifferent([Event, Time, Fluent]), b(Time, Time5), ignore(Time+1==Time5)] ->
       ta(Time, holds_at(neg(Fluent), Time5)).
 */
axiom(holds_at(neg(Fluent), Time5),
   
    [ happens(Event, Time),
      terminates(Event, Fluent, Time),
      allDifferent([Event, Time, Fluent]),
      b(Time, Time5)
    ]).

 /*  not(releasedAt(Fluent, Time+1)) :-
       ( happens(Event, Time),
         terminates(Event, Fluent, Time)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  [ignore(Time+1==Time6), b(Time, Time6), happens(Event, Time), terminates(Event, Fluent, Time), allDifferent([Event, Time, Fluent])] ->
       ta(Time, not(releasedAt(Fluent, Time6))).
 */
axiom(not(releasedAt(Fluent, Time6)),
   
    [ b(Time, Time6),
      happens(Event, Time),
      terminates(Event, Fluent, Time),
      allDifferent([Event, Time, Fluent])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:147
% [event,fluent,time]
% (Happens(event,time) & Releases(event,fluent,time)) ->
% ReleasedAt(fluent,time+1).

 /*  allDifferent([Event, Time, Fluent]) ->
       ( happens(Event, Time), releases(Event, Fluent, Time)->releasedAt(Fluent, Time+1)
       ).
 */

 /*  releasedAt(Fluent, Time+1) :-
       ( happens(Event, Time),
         releases(Event, Fluent, Time)
       ),
       allDifferent([Event, Time, Fluent]).
 */

 /*  [ignore(Time+1==Time3), b(Time, Time3), happens(Event, Time), releases(Event, Fluent, Time), allDifferent([Event, Time, Fluent])] ->
       ta(Time, releasedAt(Fluent, Time3)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:149
axiom(releasedAt(Fluent, Time3),
   
    [ b(Time, Time3),
      happens(Event, Time),
      releases(Event, Fluent, Time),
      allDifferent([Event, Time, Fluent])
    ]).

 /*  not(happens(Event, Time)) :-
       releases(Event, Fluent, Time),
       not(releasedAt(Fluent, Time+1)),
       allDifferent([Event, Time, Fluent]).
 */

 /*  [ignore(Time+1==Time4), b(Time, Time4), releases(Event, Fluent, Time), not(releasedAt(Fluent, Time4)), allDifferent([Event, Time, Fluent])] ->
       ta(Time, not(happens(Event, Time))).
 */
axiom(not(happens(Event, Time)),
   
    [ b(Time, Time4),
      releases(Event, Fluent, Time),
      not(releasedAt(Fluent, Time4)),
      allDifferent([Event, Time, Fluent])
    ]).

 /*  not(releases(Event, Fluent, Time)) :-
       happens(Event, Time),
       not(releasedAt(Fluent, Time+1)),
       allDifferent([Event, Time, Fluent]).
 */

 /*  [ignore(Time+1==Time5), b(Time, Time5), happens(Event, Time), not(releasedAt(Fluent, Time5)), allDifferent([Event, Time, Fluent])] ->
       ta(Time, not(releases(Event, Fluent, Time))).
 */
axiom(not(releases(Event, Fluent, Time)),
   
    [ b(Time, Time5),
      happens(Event, Time),
      not(releasedAt(Fluent, Time5)),
      allDifferent([Event, Time, Fluent])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:151
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/ECCausal.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Causal Constraints
%;
%; @inproceedings{Shanahan:1999a,
%;   author = "Murray Shanahan",
%;   year = "1999",
%;   title = "The ramification problem in the event calculus",
%;   booktitle = "\uppercase{P}roceedings of the \uppercase{S}ixteenth \uppercase{I}nternational \uppercase{J}oint \uppercase{C}onference on \uppercase{A}rtificial \uppercase{I}ntelligence",
%;   pages = "140--146",
%;   address = "San Mateo, CA",
%;   publisher = "Morgan Kaufmann",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:182
% predicate Started(fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:183
predicate(started(Started_Param,Started_Ret)).
==> mpred_prop(started(fluent,time),predicate).
==> meta_argtypes(started(fluent,time)).

% predicate Stopped(fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:184
predicate(stopped(Stopped_Param,Stopped_Ret)).
==> mpred_prop(stopped(fluent,time),predicate).
==> meta_argtypes(stopped(fluent,time)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:185
% [fluent,time]
% Started(fluent,time) <->
% (HoldsAt(fluent,time) |
%  ({event} Happens(event,time) & Initiates(event,fluent,time))).

 /*  started(Fluent, Time) <->
       (   holds_at(Fluent, Time)
       ;   exists([Event],
                   (happens(Event, Time), initiates(Event, Fluent, Time)))
       ).
 */

 /*  [started] <->
       [;, holds_at, exists, happens, initiates].
 */

 /*  allDifferent([Fluent, Time, Event]) ->
       ( started(Fluent, Time)->holds_at(Fluent, Time);exists([Event],  (happens(Event, Time), initiates(Event, Fluent, Time)))
       ).
 */

 /*  not(started(Fluent, Time)) :-
       ( not(holds_at(Fluent, Time)),
         (   not(happens(Event, Time))
         ;   not(initiates(Event, Fluent, Time))
         )
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [holds_at(neg(Fluent), Time),  (not(happens(Event, Time));not(initiates(Event, Fluent, Time))), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(started(Fluent, Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:188
axiom(not(started(Fluent, Time)),
   
    [ holds_at(neg(Fluent), Time),
       (not(happens(Event, Time));not(initiates(Event, Fluent, Time))),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  holds_at(Fluent, Time) :-
       (   not(happens(Event, Time))
       ;   not(initiates(Event, Fluent, Time))
       ),
       started(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(not(happens(Event, Time));not(initiates(Event, Fluent, Time))), started(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, holds_at(Fluent, Time)).
 */
axiom(holds_at(Fluent, Time),
   
    [  (not(happens(Event, Time));not(initiates(Event, Fluent, Time))),
      started(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  happens(Event, Time) :-
       not(holds_at(Fluent, Time)),
       started(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [holds_at(neg(Fluent), Time), started(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, happens(Event, Time)).
 */
axiom(happens(Event, Time),
   
    [ holds_at(neg(Fluent), Time),
      started(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  initiates(Event, Fluent, Time) :-
       not(holds_at(Fluent, Time)),
       started(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [holds_at(neg(Fluent), Time), started(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, initiates(Event, Fluent, Time)).
 */
axiom(initiates(Event, Fluent, Time),
   
    [ holds_at(neg(Fluent), Time),
      started(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  allDifferent([Fluent, Time, Event]) ->
       ( holds_at(Fluent, Time);exists([Event],  (happens(Event, Time), initiates(Event, Fluent, Time)))->started(Fluent, Time)
       ).
 */

 /*  started(Fluent, Time) :-
       (   holds_at(Fluent, Time)
       ;   happens(Event, Time),
           initiates(Event, Fluent, Time)
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(holds_at(Fluent, Time);happens(Event, Time), initiates(Event, Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, started(Fluent, Time)).
 */
axiom(started(Fluent, Time),
   
    [  (holds_at(Fluent, Time);happens(Event, Time), initiates(Event, Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(holds_at(Fluent, Time)) :-
       not(started(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [not(started(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, holds_at(neg(Fluent), Time)).
 */
axiom(holds_at(neg(Fluent), Time),
   
    [ not(started(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(happens(Event, Time)) :-
       initiates(Event, Fluent, Time),
       not(started(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [initiates(Event, Fluent, Time), not(started(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(happens(Event, Time))).
 */
axiom(not(happens(Event, Time)),
   
    [ initiates(Event, Fluent, Time),
      not(started(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(initiates(Event, Fluent, Time)) :-
       happens(Event, Time),
       not(started(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [happens(Event, Time), not(started(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(initiates(Event, Fluent, Time))).
 */
axiom(not(initiates(Event, Fluent, Time)),
   
    [ happens(Event, Time),
      not(started(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:190
% [fluent,time]
% Stopped(fluent,time) <->
% (!HoldsAt(fluent,time) |
%  ({event} Happens(event,time) & Terminates(event,fluent,time))).

 /*  stopped(Fluent, Time) <->
       (   holds_at(neg(Fluent), Time)
       ;   exists([Event],
                   (happens(Event, Time), terminates(Event, Fluent, Time)))
       ).
 */

 /*  [stopped] <->
       [;, holds_at, neg, exists, happens, terminates].
 */

 /*  allDifferent([Fluent, Time, Event]) ->
       ( stopped(Fluent, Time)->holds_at(neg(Fluent), Time);exists([Event],  (happens(Event, Time), terminates(Event, Fluent, Time)))
       ).
 */

 /*  not(stopped(Fluent, Time)) :-
       ( not(holds_at(neg(Fluent), Time)),
         (   not(happens(Event, Time))
         ;   not(terminates(Event, Fluent, Time))
         )
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [holds_at(neg(neg(Fluent)), Time),  (not(happens(Event, Time));not(terminates(Event, Fluent, Time))), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(stopped(Fluent, Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:193
axiom(not(stopped(Fluent, Time)),
   
    [ holds_at(neg(neg(Fluent)), Time),
       (not(happens(Event, Time));not(terminates(Event, Fluent, Time))),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  holds_at(neg(Fluent), Time) :-
       (   not(happens(Event, Time))
       ;   not(terminates(Event, Fluent, Time))
       ),
       stopped(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(not(happens(Event, Time));not(terminates(Event, Fluent, Time))), stopped(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, holds_at(neg(Fluent), Time)).
 */
axiom(holds_at(neg(Fluent), Time),
   
    [  (not(happens(Event, Time));not(terminates(Event, Fluent, Time))),
      stopped(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  happens(Event, Time) :-
       not(holds_at(neg(Fluent), Time)),
       stopped(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [holds_at(neg(neg(Fluent)), Time), stopped(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, happens(Event, Time)).
 */
axiom(happens(Event, Time),
   
    [ holds_at(neg(neg(Fluent)), Time),
      stopped(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  terminates(Event, Fluent, Time) :-
       not(holds_at(neg(Fluent), Time)),
       stopped(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [holds_at(neg(neg(Fluent)), Time), stopped(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, terminates(Event, Fluent, Time)).
 */
axiom(terminates(Event, Fluent, Time),
   
    [ holds_at(neg(neg(Fluent)), Time),
      stopped(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  allDifferent([Fluent, Time, Event]) ->
       ( holds_at(neg(Fluent), Time);exists([Event],  (happens(Event, Time), terminates(Event, Fluent, Time)))->stopped(Fluent, Time)
       ).
 */

 /*  stopped(Fluent, Time) :-
       (   holds_at(neg(Fluent), Time)
       ;   happens(Event, Time),
           terminates(Event, Fluent, Time)
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(holds_at(neg(Fluent), Time);happens(Event, Time), terminates(Event, Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, stopped(Fluent, Time)).
 */
axiom(stopped(Fluent, Time),
   
    [  (holds_at(neg(Fluent), Time);happens(Event, Time), terminates(Event, Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(holds_at(neg(Fluent), Time)) :-
       not(stopped(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [not(stopped(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, holds_at(neg(neg(Fluent)), Time)).
 */
axiom(holds_at(neg(neg(Fluent)), Time),
   
    [ not(stopped(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(happens(Event, Time)) :-
       terminates(Event, Fluent, Time),
       not(stopped(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [terminates(Event, Fluent, Time), not(stopped(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(happens(Event, Time))).
 */
axiom(not(happens(Event, Time)),
   
    [ terminates(Event, Fluent, Time),
      not(stopped(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(terminates(Event, Fluent, Time)) :-
       happens(Event, Time),
       not(stopped(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [happens(Event, Time), not(stopped(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(terminates(Event, Fluent, Time))).
 */
axiom(not(terminates(Event, Fluent, Time)),
   
    [ happens(Event, Time),
      not(stopped(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:195
% predicate Initiated(fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:196
predicate(initiated(Initiated_Param,Initiated_Ret)).
==> mpred_prop(initiated(fluent,time),predicate).
==> meta_argtypes(initiated(fluent,time)).

% predicate Terminated(fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:197
predicate(terminated(Terminated_Param,Terminated_Ret)).
==> mpred_prop(terminated(fluent,time),predicate).
==> meta_argtypes(terminated(fluent,time)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:198
% [fluent,time]
% Initiated(fluent,time) <->
% (Started(fluent,time) &
%  !({event} Happens(event,time) & Terminates(event,fluent,time))).

 /*  initiated(Fluent, Time) <->
       started(Fluent, Time),
       not(exists([Event],
                   (happens(Event, Time), terminates(Event, Fluent, Time)))).
 */

 /*  [initiated] <->
       [started, not, exists, happens, terminates].
 */

 /*  allDifferent([Fluent, Time, Event]) ->
       ( initiated(Fluent, Time)->started(Fluent, Time), not(exists([Event],  (happens(Event, Time), terminates(Event, Fluent, Time))))
       ).
 */

 /*  not(initiated(Fluent, Time)) :-
       (   not(started(Fluent, Time))
       ;   happens(Event, Time),
           terminates(Event, Fluent, Time)
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(not(started(Fluent, Time));happens(Event, Time), terminates(Event, Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(initiated(Fluent, Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:201
axiom(not(initiated(Fluent, Time)),
   
    [  (not(started(Fluent, Time));happens(Event, Time), terminates(Event, Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  started(Fluent, Time) :-
       initiated(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [initiated(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Ta_Param, started(Fluent, Time)).
 */
axiom(started(Fluent, Time),
   
    [ initiated(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(happens(Event, Time)) :-
       terminates(Event, Fluent, Time),
       initiated(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [terminates(Event, Fluent, Time), initiated(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(happens(Event, Time))).
 */
axiom(not(happens(Event, Time)),
   
    [ terminates(Event, Fluent, Time),
      initiated(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(terminates(Event, Fluent, Time)) :-
       happens(Event, Time),
       initiated(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [happens(Event, Time), initiated(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(terminates(Event, Fluent, Time))).
 */
axiom(not(terminates(Event, Fluent, Time)),
   
    [ happens(Event, Time),
      initiated(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  allDifferent([Fluent, Time, Event]) ->
       ( started(Fluent, Time), not(exists([Event],  (happens(Event, Time), terminates(Event, Fluent, Time))))->initiated(Fluent, Time)
       ).
 */

 /*  initiated(Fluent, Time) :-
       ( started(Fluent, Time),
         (   not(happens(Event, Time))
         ;   not(terminates(Event, Fluent, Time))
         )
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [started(Fluent, Time),  (not(happens(Event, Time));not(terminates(Event, Fluent, Time))), allDifferent([Fluent, Time, Event])] ->
       ta(Time, initiated(Fluent, Time)).
 */
axiom(initiated(Fluent, Time),
   
    [ started(Fluent, Time),
       (not(happens(Event, Time));not(terminates(Event, Fluent, Time))),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(started(Fluent, Time)) :-
       (   not(happens(Event, Time))
       ;   not(terminates(Event, Fluent, Time))
       ),
       not(initiated(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(not(happens(Event, Time));not(terminates(Event, Fluent, Time))), not(initiated(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(started(Fluent, Time))).
 */
axiom(not(started(Fluent, Time)),
   
    [  (not(happens(Event, Time));not(terminates(Event, Fluent, Time))),
      not(initiated(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  happens(Event, Time) :-
       started(Fluent, Time),
       not(initiated(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [started(Fluent, Time), not(initiated(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, happens(Event, Time)).
 */
axiom(happens(Event, Time),
   
    [ started(Fluent, Time),
      not(initiated(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  terminates(Event, Fluent, Time) :-
       started(Fluent, Time),
       not(initiated(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [started(Fluent, Time), not(initiated(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, terminates(Event, Fluent, Time)).
 */
axiom(terminates(Event, Fluent, Time),
   
    [ started(Fluent, Time),
      not(initiated(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:203
% [fluent,time]
% Terminated(fluent,time) <->
% (Stopped(fluent,time) &
%  !({event} Happens(event,time) & Initiates(event,fluent,time))).

 /*  terminated(Fluent, Time) <->
       stopped(Fluent, Time),
       not(exists([Event],
                   (happens(Event, Time), initiates(Event, Fluent, Time)))).
 */

 /*  [terminated] <->
       [stopped, not, exists, happens, initiates].
 */

 /*  allDifferent([Fluent, Time, Event]) ->
       ( terminated(Fluent, Time)->stopped(Fluent, Time), not(exists([Event],  (happens(Event, Time), initiates(Event, Fluent, Time))))
       ).
 */

 /*  not(terminated(Fluent, Time)) :-
       (   not(stopped(Fluent, Time))
       ;   happens(Event, Time),
           initiates(Event, Fluent, Time)
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(not(stopped(Fluent, Time));happens(Event, Time), initiates(Event, Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(terminated(Fluent, Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:206
axiom(not(terminated(Fluent, Time)),
   
    [  (not(stopped(Fluent, Time));happens(Event, Time), initiates(Event, Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  stopped(Fluent, Time) :-
       terminated(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [terminated(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Ta_Param, stopped(Fluent, Time)).
 */
axiom(stopped(Fluent, Time),
   
    [ terminated(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(happens(Event, Time)) :-
       initiates(Event, Fluent, Time),
       terminated(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [initiates(Event, Fluent, Time), terminated(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(happens(Event, Time))).
 */
axiom(not(happens(Event, Time)),
   
    [ initiates(Event, Fluent, Time),
      terminated(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(initiates(Event, Fluent, Time)) :-
       happens(Event, Time),
       terminated(Fluent, Time),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [happens(Event, Time), terminated(Fluent, Time), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(initiates(Event, Fluent, Time))).
 */
axiom(not(initiates(Event, Fluent, Time)),
   
    [ happens(Event, Time),
      terminated(Fluent, Time),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  allDifferent([Fluent, Time, Event]) ->
       ( stopped(Fluent, Time), not(exists([Event],  (happens(Event, Time), initiates(Event, Fluent, Time))))->terminated(Fluent, Time)
       ).
 */

 /*  terminated(Fluent, Time) :-
       ( stopped(Fluent, Time),
         (   not(happens(Event, Time))
         ;   not(initiates(Event, Fluent, Time))
         )
       ),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [stopped(Fluent, Time),  (not(happens(Event, Time));not(initiates(Event, Fluent, Time))), allDifferent([Fluent, Time, Event])] ->
       ta(Time, terminated(Fluent, Time)).
 */
axiom(terminated(Fluent, Time),
   
    [ stopped(Fluent, Time),
       (not(happens(Event, Time));not(initiates(Event, Fluent, Time))),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  not(stopped(Fluent, Time)) :-
       (   not(happens(Event, Time))
       ;   not(initiates(Event, Fluent, Time))
       ),
       not(terminated(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [(not(happens(Event, Time));not(initiates(Event, Fluent, Time))), not(terminated(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, not(stopped(Fluent, Time))).
 */
axiom(not(stopped(Fluent, Time)),
   
    [  (not(happens(Event, Time));not(initiates(Event, Fluent, Time))),
      not(terminated(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  happens(Event, Time) :-
       stopped(Fluent, Time),
       not(terminated(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [stopped(Fluent, Time), not(terminated(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, happens(Event, Time)).
 */
axiom(happens(Event, Time),
   
    [ stopped(Fluent, Time),
      not(terminated(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).

 /*  initiates(Event, Fluent, Time) :-
       stopped(Fluent, Time),
       not(terminated(Fluent, Time)),
       allDifferent([Fluent, Time, Event]).
 */

 /*  [stopped(Fluent, Time), not(terminated(Fluent, Time)), allDifferent([Fluent, Time, Event])] ->
       ta(Time, initiates(Event, Fluent, Time)).
 */
axiom(initiates(Event, Fluent, Time),
   
    [ stopped(Fluent, Time),
      not(terminated(Fluent, Time)),
      allDifferent([Fluent, Time, Event])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:208
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/ECTraj.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @incollection{MillerShanahan:2002,
%;   author = "Rob Miller and Murray Shanahan",
%;   year = "2002",
%;   title = "Some alternative formulations of the event calculus",
%;   editor = "Antonis C. Kakas and Fariba Sadri",
%;   booktitle = "Computational Logic: Logic Programming and Beyond: Essays in Honour of \uppercase{R}obert \uppercase{A}. \uppercase{K}owalski, Part \uppercase{II}",
%;   series = "Lecture Notes in Computer Science",
%;   volume = "2408",
%;   pages = "452--490",
%;   address = "Berlin",
%;   publisher = "Springer",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:240
% predicate Clipped(time,fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:241
predicate(clipped(Clipped_Param,_,Clipped_Ret)).
==> mpred_prop(clipped(time,fluent,time),predicate).
==> meta_argtypes(clipped(time,fluent,time)).

% predicate Declipped(time,fluent,time)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:242
predicate(declipped(Declipped_Param,_,Declipped_Ret)).
==> mpred_prop(declipped(time,fluent,time),predicate).
==> meta_argtypes(declipped(time,fluent,time)).

% predicate Trajectory(fluent,time,fluent,offset)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:244
predicate(trajectory(Trajectory_Param,
		     _,
		     _,
		     Trajectory_Ret)).
==> mpred_prop(trajectory(fluent,time,fluent,offset),predicate).
==> meta_argtypes(trajectory(fluent,time,fluent,offset)).

% predicate AntiTrajectory(fluent,time,fluent,offset)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:245
predicate(antiTrajectory(AntiTrajectory_Param,
			 _,
			 _,
			 AntiTrajectory_Ret)).
==> mpred_prop(antiTrajectory(fluent,time,fluent,offset),predicate).
==> meta_argtypes(antiTrajectory(fluent,time,fluent,offset)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:246
% [event,fluent,fluent2,offset,time]
% Happens(event,time) &
% Initiates(event,fluent,time) &
% 0 < offset &
% Trajectory(fluent,time,fluent2,offset) &
% !Clipped(time,fluent,time+offset) ->
% HoldsAt(fluent2,time+offset).

 /*  allDifferent([Event, Time, Fluent, Offset, Fluent2]) ->
       ( happens(Event, Time), initiates(Event, Fluent, Time), 0<Offset, trajectory(Fluent, Time, Fluent2, Offset), not(clipped(Time, Fluent, Time+Offset))->holds_at(Fluent2, Time+Offset)
       ).
 */

 /*  holds_at(Fluent2, Time+Offset) :-
       ( happens(Event, Time),
         initiates(Event, Fluent, Time),
         comparison(0, Offset, <),
         trajectory(Fluent, Time, Fluent2, Offset),
         not(clipped(Time, Fluent, Time+Offset))
       ),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time5), b(Time, Time5), happens(Event, Time), initiates(Event, Fluent, Time), comparison(0, Offset, <), trajectory(Fluent, Time, Fluent2, Offset), not(clipped(Time, Fluent, Time5)), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time, holds_at(Fluent2, Time5)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:252
axiom(holds_at(Fluent2, Time5),
   
    [ b(Time, Time5),
      happens(Event, Time),
      initiates(Event, Fluent, Time),
      comparison(0, Offset, <),
      trajectory(Fluent, Time, Fluent2, Offset),
      not(clipped(Time, Fluent, Time5)),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).

 /*  not(happens(Event, Time)) :-
       ( initiates(Event, Fluent, Time),
         comparison(0, Offset, <),
         trajectory(Fluent, Time, Fluent2, Offset),
         not(clipped(Time, Fluent, Time+Offset))
       ),
       not(holds_at(Fluent2, Time+Offset)),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time6), b(Time, Time6), initiates(Event, Fluent, Time), comparison(0, Offset, <), trajectory(Fluent, Time, Fluent2, Offset), not(clipped(Time, Fluent, Time6)), holds_at(neg(Fluent2), Time6), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time, not(happens(Event, Time))).
 */
axiom(not(happens(Event, Time)),
   
    [ b(Time, Time6),
      initiates(Event, Fluent, Time),
      comparison(0, Offset, <),
      trajectory(Fluent, Time, Fluent2, Offset),
      not(clipped(Time, Fluent, Time6)),
      holds_at(neg(Fluent2), Time6),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).

 /*  not(initiates(Event, Fluent, Time)) :-
       ( comparison(0, Offset, <),
         trajectory(Fluent, Time, Fluent2, Offset),
         not(clipped(Time, Fluent, Time+Offset))
       ),
       happens(Event, Time),
       not(holds_at(Fluent2, Time+Offset)),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time7), b(Time, Time7), comparison(0, Offset, <), trajectory(Fluent, Time, Fluent2, Offset), not(clipped(Time, Fluent, Time7)), happens(Event, Time), holds_at(neg(Fluent2), Time7), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time, not(initiates(Event, Fluent, Time))).
 */
axiom(not(initiates(Event, Fluent, Time)),
   
    [ b(Time, Time7),
      comparison(0, Offset, <),
      trajectory(Fluent, Time, Fluent2, Offset),
      not(clipped(Time, Fluent, Time7)),
      happens(Event, Time),
      holds_at(neg(Fluent2), Time7),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).

 /*  not(trajectory(Fluent, Time, Fluent2, Offset)) :-
       not(clipped(Time, Fluent, Time+Offset)),
       comparison(0, Offset, <),
       initiates(Event, Fluent, Time),
       happens(Event, Time),
       not(holds_at(Fluent2, Time+Offset)),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time8), b(Time, Time8), not(clipped(Time, Fluent, Time8)), comparison(0, Offset, <), initiates(Event, Fluent, Time), happens(Event, Time), holds_at(neg(Fluent2), Time8), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time,
          not(trajectory(Fluent, Time, Fluent2, Offset))).
 */
axiom(not(trajectory(Fluent, Time, Fluent2, Offset)),
   
    [ b(Time, Time8),
      not(clipped(Time, Fluent, Time8)),
      comparison(0, Offset, <),
      initiates(Event, Fluent, Time),
      happens(Event, Time),
      holds_at(neg(Fluent2), Time8),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).

 /*  clipped(Time, Fluent, Time+Offset) :-
       trajectory(Fluent, Time, Fluent2, Offset),
       comparison(0, Offset, <),
       initiates(Event, Fluent, Time),
       happens(Event, Time),
       not(holds_at(Fluent2, Time+Offset)),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time9), b(Time, Time9), trajectory(Fluent, Time, Fluent2, Offset), comparison(0, Offset, <), initiates(Event, Fluent, Time), happens(Event, Time), holds_at(neg(Fluent2), Time9), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time, clipped(Time, Fluent, Time9)).
 */
axiom(clipped(Time, Fluent, Time9),
   
    [ b(Time, Time9),
      trajectory(Fluent, Time, Fluent2, Offset),
      comparison(0, Offset, <),
      initiates(Event, Fluent, Time),
      happens(Event, Time),
      holds_at(neg(Fluent2), Time9),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:254
% [event,fluent,fluent2,offset,time]
% Happens(event,time) &
% Terminates(event,fluent,time) &
% 0 < offset &
% AntiTrajectory(fluent,time,fluent2,offset) &
% !Declipped(time,fluent,time+offset) ->
% HoldsAt(fluent2,time+offset).

 /*  allDifferent([Event, Time, Fluent, Offset, Fluent2]) ->
       ( happens(Event, Time), terminates(Event, Fluent, Time), 0<Offset, antiTrajectory(Fluent, Time, Fluent2, Offset), not(declipped(Time, Fluent, Time+Offset))->holds_at(Fluent2, Time+Offset)
       ).
 */

 /*  holds_at(Fluent2, Time+Offset) :-
       ( happens(Event, Time),
         terminates(Event, Fluent, Time),
         comparison(0, Offset, <),
         antiTrajectory(Fluent, Time, Fluent2, Offset),
         not(declipped(Time, Fluent, Time+Offset))
       ),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time5), b(Time, Time5), happens(Event, Time), terminates(Event, Fluent, Time), comparison(0, Offset, <), antiTrajectory(Fluent, Time, Fluent2, Offset), not(declipped(Time, Fluent, Time5)), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time, holds_at(Fluent2, Time5)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:260
axiom(holds_at(Fluent2, Time5),
   
    [ b(Time, Time5),
      happens(Event, Time),
      terminates(Event, Fluent, Time),
      comparison(0, Offset, <),
      antiTrajectory(Fluent, Time, Fluent2, Offset),
      not(declipped(Time, Fluent, Time5)),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).

 /*  not(happens(Event, Time)) :-
       ( terminates(Event, Fluent, Time),
         comparison(0, Offset, <),
         antiTrajectory(Fluent, Time, Fluent2, Offset),
         not(declipped(Time, Fluent, Time+Offset))
       ),
       not(holds_at(Fluent2, Time+Offset)),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time6), b(Time, Time6), terminates(Event, Fluent, Time), comparison(0, Offset, <), antiTrajectory(Fluent, Time, Fluent2, Offset), not(declipped(Time, Fluent, Time6)), holds_at(neg(Fluent2), Time6), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time, not(happens(Event, Time))).
 */
axiom(not(happens(Event, Time)),
   
    [ b(Time, Time6),
      terminates(Event, Fluent, Time),
      comparison(0, Offset, <),
      antiTrajectory(Fluent, Time, Fluent2, Offset),
      not(declipped(Time, Fluent, Time6)),
      holds_at(neg(Fluent2), Time6),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).

 /*  not(terminates(Event, Fluent, Time)) :-
       ( comparison(0, Offset, <),
         antiTrajectory(Fluent, Time, Fluent2, Offset),
         not(declipped(Time, Fluent, Time+Offset))
       ),
       happens(Event, Time),
       not(holds_at(Fluent2, Time+Offset)),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time7), b(Time, Time7), comparison(0, Offset, <), antiTrajectory(Fluent, Time, Fluent2, Offset), not(declipped(Time, Fluent, Time7)), happens(Event, Time), holds_at(neg(Fluent2), Time7), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time, not(terminates(Event, Fluent, Time))).
 */
axiom(not(terminates(Event, Fluent, Time)),
   
    [ b(Time, Time7),
      comparison(0, Offset, <),
      antiTrajectory(Fluent, Time, Fluent2, Offset),
      not(declipped(Time, Fluent, Time7)),
      happens(Event, Time),
      holds_at(neg(Fluent2), Time7),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).

 /*  not(antiTrajectory(Fluent, Time, Fluent2, Offset)) :-
       not(declipped(Time, Fluent, Time+Offset)),
       comparison(0, Offset, <),
       terminates(Event, Fluent, Time),
       happens(Event, Time),
       not(holds_at(Fluent2, Time+Offset)),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time8), b(Time, Time8), not(declipped(Time, Fluent, Time8)), comparison(0, Offset, <), terminates(Event, Fluent, Time), happens(Event, Time), holds_at(neg(Fluent2), Time8), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time,
          not(antiTrajectory(Fluent, Time, Fluent2, Offset))).
 */
axiom(not(antiTrajectory(Fluent, Time, Fluent2, Offset)),
   
    [ b(Time, Time8),
      not(declipped(Time, Fluent, Time8)),
      comparison(0, Offset, <),
      terminates(Event, Fluent, Time),
      happens(Event, Time),
      holds_at(neg(Fluent2), Time8),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).

 /*  declipped(Time, Fluent, Time+Offset) :-
       antiTrajectory(Fluent, Time, Fluent2, Offset),
       comparison(0, Offset, <),
       terminates(Event, Fluent, Time),
       happens(Event, Time),
       not(holds_at(Fluent2, Time+Offset)),
       allDifferent(
                    [ Event,
                      Time,
                      Fluent,
                      Offset,
                      Fluent2
                    ]).
 */

 /*  [ignore(Time+Offset==Time9), b(Time, Time9), antiTrajectory(Fluent, Time, Fluent2, Offset), comparison(0, Offset, <), terminates(Event, Fluent, Time), happens(Event, Time), holds_at(neg(Fluent2), Time9), allDifferent([Event, Time, Fluent, Offset, Fluent2])] ->
       ta(Time, declipped(Time, Fluent, Time9)).
 */
axiom(declipped(Time, Fluent, Time9),
   
    [ b(Time, Time9),
      antiTrajectory(Fluent, Time, Fluent2, Offset),
      comparison(0, Offset, <),
      terminates(Event, Fluent, Time),
      happens(Event, Time),
      holds_at(neg(Fluent2), Time9),
      allDifferent(
                   [ Event,
                     Time,
                     Fluent,
                     Offset,
                     Fluent2
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:262
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Ontology.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; integer
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:283
% sort diameter: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:284
==> subsort(diameter,integer).
%; object

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:287
% sort object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:288
==> sort(object).

% sort agent: object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:290
==> subsort(agent,object).

% sort physobj: object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:292
==> subsort(physobj,object).

% sort bed: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:293
==> subsort(bed,physobj).

% sort snowflake: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:294
==> subsort(snowflake,physobj).

% sort sky: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:295
==> subsort(sky,physobj).

% sort stuff: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:297
==> subsort(stuff,physobj).

% sort surface: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:299
==> subsort(surface,physobj).

% sort ground: surface
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:300
==> subsort(ground,surface).

% sort snow: stuff
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:302
==> subsort(snow,stuff).

% sort ball
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:303
==> sort(ball).

% sort food: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:305
==> subsort(food,physobj).

% sort fruit: food
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:306
==> subsort(fruit,food).

% sort orange: fruit
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:307
==> subsort(orange,fruit).

% sort salad: food
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:308
==> subsort(salad,food).

% sort clothing: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:310
==> subsort(clothing,physobj).

% sort scarf: clothing
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:311
==> subsort(scarf,clothing).

% sort hat: clothing
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:312
==> subsort(hat,clothing).

% sort vegetablematter: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:314
==> subsort(vegetablematter,physobj).

% sort coal: vegetablematter
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:315
==> subsort(coal,vegetablematter).

% sort bodypart: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:317
==> subsort(bodypart,physobj).

% sort hand: bodypart
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:318
==> subsort(hand,bodypart).

% sort papertowels: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:320
==> subsort(papertowels,physobj).

% sort device: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:321
==> subsort(device,physobj).

% sort electronicdevice: device
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:322
==> subsort(electronicdevice,device).

% sort lamp: electronicdevice
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:323
==> subsort(lamp,electronicdevice).

% sort cat: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:325
==> subsort(cat,physobj).

% sort horse: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:326
==> subsort(horse,physobj).

% sort weapon: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:328
==> subsort(weapon,physobj).

% sort gun: weapon
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:329
==> subsort(gun,weapon).

% sort bomb: weapon
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:330
==> subsort(bomb,weapon).

% sort bullet: weapon
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:331
==> subsort(bullet,weapon).
%; location

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:334
% sort location
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:335
==> sort(location).

% sort room: location, outside: location
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:336
==> subsort(room,location).
==> subsort(outside,location).
%; portal

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:339
% sort portal
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:340
==> sort(portal).

% sort door: portal, staircase: portal
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:341
==> subsort(door,portal).
==> subsort(staircase,portal).

% sort street: portal
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:342
==> subsort(street,portal).

% sort track: portal
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:343
==> subsort(track,portal).

% sort building
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:345
==> sort(building).

% sort fire: object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:347
==> subsort(fire,object).

% sort smoke: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:348
==> subsort(smoke,physobj).

% sort furniture: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:350
==> subsort(furniture,physobj).

% sort chair: furniture
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:351
==> subsort(chair,furniture).

% sort table: furniture
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:352
==> subsort(table,furniture).

% sort bill: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:354
==> subsort(bill,physobj).

% sort ticket: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:355
==> subsort(ticket,physobj).

% sort envelope: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:356
==> subsort(envelope,physobj).

% sort text: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:358
==> subsort(text,physobj).

% sort book: text
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:359
==> subsort(book,text).

% sort letter: text
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:360
==> subsort(letter,text).

% sort menu: text
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:361
==> subsort(menu,text).

% sort paper: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:363
==> subsort(paper,physobj).

% sort content
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:365
==> sort(content).

% sort script
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:366
==> sort(script).

% sort container: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:368
==> subsort(container,physobj).

% sort cigarette: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:369
==> subsort(cigarette,physobj).

% sort ashtray: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:370
==> subsort(ashtray,physobj).

% sort umbrella: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:371
==> subsort(umbrella,physobj).

% sort pen: physobj
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:373
==> subsort(pen,physobj).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/RTSpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; RTSpace: room-scale topological space
%;
%; We use topological and metric representations of space,
%; at two levels of granularity---room-scale and object-scale.
%; The RTSpace representation deals with topological space at
%; the scale of rooms and outdoor locations.
%; This representation of space consists of locations, which
%; are connected by portals. There are two types of locations:
%; rooms and outside areas (outsides).
%;
%; object is at location.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:404
% fluent At(object,location)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:405
fluent(at(At_Param,Location)).
==> mpred_prop(at(object,location),fluent).
==> meta_argtypes(at(object,location)).

% manualrelease At
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:406
manualrelease(at).

 /*  axiom_head(Axiom_head_Ret) ->
       manualrelease(at).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(manualrelease(at), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:407
% [object1,location,time]
% (
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:408
% {object2} PartOf(object1,object2)) ->
% ReleasedAt(At(object1,location),time).

 /*  exists([Object2],
    partOf(Object1, Object2) ->
       releasedAt(at(Object1, Location), Time)).
 */

 /*  releasedAt(at(Object1, Location), Time) :-
       partOf(Object1, Object2),
       some(Object2, '$kolem_Fn_199'(Object1, Location, Time)).
 */

 /*  [partOf(Object1, Object2), some(Object2, '$kolem_Fn_199'(Object1, Location, Time))] ->
       ta(Ta_Param, releasedAt(at(Object1, Location), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:409
axiom(releasedAt(at(Object1, Location), Time),
   
    [ partOf(Object1, Object2),
      some(Object2,
           '$kolem_Fn_199'(Object1, Location, Time))
    ]).

 /*  not(partOf(Object1, Object2)) :-
       not(releasedAt(at(Object1, Location), Time)),
       some(Object2, '$kolem_Fn_199'(Object1, Location, Time)).
 */

 /*  [not(releasedAt(at(Object1, Location), Time)), some(Object2, '$kolem_Fn_199'(Object1, Location, Time))] ->
       ta(Ta_Param6, not(partOf(Object1, Object2))).
 */
axiom(not(partOf(Object1, Object2)),
   
    [ not(releasedAt(at(Object1, Location), Time)),
      some(Object2,
           '$kolem_Fn_199'(Object1, Location, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:411
%; A state constraint says that an object
%; is at one location at a time:
% [object,location1,location2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:414
% HoldsAt(At(object,location1),time) &
% HoldsAt(At(object,location2),time) ->
% location1=location2.

 /*  allDifferent([Object, Location1, Time, Location2]) ->
       ( holds_at(at(Object, Location1), Time), holds_at(at(Object, Location2), Time)->Location1=Location2
       ).
 */

 /*  not(holds_at(at(Object, Location1), Time)) :-
       holds_at(at(Object, Location2), Time),
       not(equals(Location1, Location2)),
       allDifferent([Object, Location1, Time, Location2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Location1, Location2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Location1=Location2)).
 */

 /*  [holds_at(at(Object, Location2), Time), not(call(Location1=Location2)), allDifferent([Object, Location1, Time, Location2])] ->
       ta(Time, holds_at(neg(at(Object, Location1)), Time)).
 */

 /*  [holds_at(at(Object, Location2), Time), holds_at(neg(call(Location1=Location2)), Time), allDifferent([Object, Location1, Time, Location2])] ->
       ta(Time, holds_at(neg(at(Object, Location1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:416
axiom(holds_at(neg(at(Object, Location1)), Time),
   
    [ holds_at(at(Object, Location2), Time),
      holds_at(neg(call(Location1=Location2)), Time),
      allDifferent([Object, Location1, Time, Location2])
    ]).

 /*  not(holds_at(at(Object, Location2), Time)) :-
       holds_at(at(Object, Location1), Time),
       not(equals(Location1, Location2)),
       allDifferent([Object, Location1, Time, Location2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Location1, Location2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Location1=Location2)).
 */

 /*  [holds_at(at(Object, Location1), Time), not(call(Location1=Location2)), allDifferent([Object, Location1, Time, Location2])] ->
       ta(Time, holds_at(neg(at(Object, Location2)), Time)).
 */

 /*  [holds_at(at(Object, Location1), Time), holds_at(neg(call(Location1=Location2)), Time), allDifferent([Object, Location1, Time, Location2])] ->
       ta(Time, holds_at(neg(at(Object, Location2)), Time)).
 */
axiom(holds_at(neg(at(Object, Location2)), Time),
   
    [ holds_at(at(Object, Location1), Time),
      holds_at(neg(call(Location1=Location2)), Time),
      allDifferent([Object, Location1, Time, Location2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:418
%; connectivity
%; Side one of portal is location.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:421
% function Side1(portal): location
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:422
functional_predicate(side1(Side1_Param,Side1_Ret)).
==> mpred_prop(side1(portal,location),functional_predicate).
==> meta_argtypes(side1(portal,location)).
==> resultIsa(side1,location).
%; Side two of portal is location.

% function Side2(portal): location
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:424
functional_predicate(side2(Side2_Param,Side2_Ret)).
==> mpred_prop(side2(portal,location),functional_predicate).
==> meta_argtypes(side2(portal,location)).
==> resultIsa(side2,location).
%; The building of room is building.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:426
% function BuildingOf(room): building
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:427
functional_predicate(buildingOf(BuildingOf_Param,
				BuildingOf_Ret)).
==> mpred_prop(buildingOf(room,building),functional_predicate).
==> meta_argtypes(buildingOf(room,building)).
==> resultIsa(buildingOf,building).
%; object is at a location that has portal.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:429
% fluent NearPortal(object,portal)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:430
fluent(nearPortal(NearPortal_Param,NearPortal_Ret)).
==> mpred_prop(nearPortal(object,portal),fluent).
==> meta_argtypes(nearPortal(object,portal)).

% noninertial NearPortal
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:431
==> noninertial(nearPortal).
%; A state constraint says that an object is near
%; a portal if and only if there is a location such that
%; the object is at the location and one of the sides
%; of the portal is the location:
% [object,portal,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:437
% HoldsAt(NearPortal(object,portal),time) <->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:438
% {location}% 
%  (Side1(portal)=location|
%   Side2(portal)=location) &
%  HoldsAt(At(object,location),time).

 /*  exists([Location],
    holds_at(nearPortal(Object, Portal), Time) <->
       (   side1(Portal)=Location
       ;   side2(Portal)=Location
       ),
       holds_at(at(Object, Location), Time)).
 */

 /*  not(holds_at(nearPortal(Object, Portal), Time)) :-
       (   not(equals(side1(Portal), Location)),
           not(equals(side2(Portal), Location))
       ;   not(holds_at(at(Object, Location), Time))
       ),
       some(Location, '$kolem_Fn_200'(Object, Portal, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(equals(side1(Portal), Location)),
           not(equals(side2(Portal), Location))
       ;   not(holds_at(at(Object, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(side1(Portal)=Location)),
           not(call(side2(Portal)=Location))
       ;   holds_at(neg(at(Object, Location)), Time)
       ).
 */

 /*  [(not(call(side1(Portal)=Location)), not(call(side2(Portal)=Location));holds_at(neg(at(Object, Location)), Time)), some(Location, '$kolem_Fn_200'(Object, Portal, Time))] ->
       ta(Time,
          holds_at(neg(nearPortal(Object, Portal)), Time)).
 */

 /*  [(holds_at(neg(call(side1(Portal)=Location)), Time), holds_at(neg(call(side2(Portal)=Location)), Time);holds_at(neg(at(Object, Location)), Time)), some(Location, '$kolem_Fn_200'(Object, Portal, Time))] ->
       ta(Time,
          holds_at(neg(nearPortal(Object, Portal)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:441
axiom(holds_at(neg(nearPortal(Object, Portal)), Time),
   
    [  (holds_at(neg(call(side1(Portal)=Location)), Time), holds_at(neg(call(side2(Portal)=Location)), Time);holds_at(neg(at(Object, Location)), Time)),
      some(Location, '$kolem_Fn_200'(Object, Portal, Time))
    ]).

 /*  holds_at(at(Object, Location), Time) :-
       holds_at(nearPortal(Object, Portal), Time),
       some(Location, '$kolem_Fn_200'(Object, Portal, Time)).
 */

 /*  [holds_at(nearPortal(Object, Portal), Time), some(Location, '$kolem_Fn_200'(Object, Portal, Time))] ->
       ta(Time, holds_at(at(Object, Location), Time)).
 */
axiom(holds_at(at(Object, Location), Time),
   
    [ holds_at(nearPortal(Object, Portal), Time),
      some(Location, '$kolem_Fn_200'(Object, Portal, Time))
    ]).

 /*  holds_at(nearPortal(Object, Portal), Time) :-
       ( holds_at(at(Object, Location), Time),
         (   equals(side1(Portal), Location)
         ;   equals(side2(Portal), Location)
         )
       ),
       some(Location, '$kolem_Fn_200'(Object, Portal, Time)).
 */

 /*  axiom_head(Time) ->
       (   equals(side1(Portal), Location)
       ;   equals(side2(Portal), Location)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   call(side1(Portal)=Location)
       ;   call(side2(Portal)=Location)
       ).
 */

 /*  [holds_at(at(Object, Location), Time),  (call(side1(Portal)=Location);call(side2(Portal)=Location)), some(Location, '$kolem_Fn_200'(Object, Portal, Time))] ->
       ta(Time, holds_at(nearPortal(Object, Portal), Time)).
 */

 /*  [holds_at(at(Object, Location), Time),  (holds_at(call(side1(Portal)=Location), Time);holds_at(call(side2(Portal)=Location), Time)), some(Location, '$kolem_Fn_200'(Object, Portal, Time))] ->
       ta(Time, holds_at(nearPortal(Object, Portal), Time)).
 */
axiom(holds_at(nearPortal(Object, Portal), Time),
   
    [ holds_at(at(Object, Location), Time),
       (holds_at(call(side1(Portal)=Location), Time);holds_at(call(side2(Portal)=Location), Time)),
      some(Location, '$kolem_Fn_200'(Object, Portal, Time))
    ]).

 /*  not(holds_at(at(Object, Location), Time)) :-
       (   equals(side1(Portal), Location)
       ;   equals(side2(Portal), Location)
       ),
       not(holds_at(nearPortal(Object, Portal), Time)),
       some(Location, '$kolem_Fn_200'(Object, Portal, Time)).
 */

 /*  axiom_head(Time) ->
       (   equals(side1(Portal), Location)
       ;   equals(side2(Portal), Location)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   call(side1(Portal)=Location)
       ;   call(side2(Portal)=Location)
       ).
 */

 /*  [(call(side1(Portal)=Location);call(side2(Portal)=Location)), holds_at(neg(nearPortal(Object, Portal)), Time), some(Location, '$kolem_Fn_200'(Object, Portal, Time))] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */

 /*  [(holds_at(call(side1(Portal)=Location), Time);holds_at(call(side2(Portal)=Location), Time)), holds_at(neg(nearPortal(Object, Portal)), Time), some(Location, '$kolem_Fn_200'(Object, Portal, Time))] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */
axiom(holds_at(neg(at(Object, Location)), Time),
   
    [  (holds_at(call(side1(Portal)=Location), Time);holds_at(call(side2(Portal)=Location), Time)),
      holds_at(neg(nearPortal(Object, Portal)), Time),
      some(Location, '$kolem_Fn_200'(Object, Portal, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:443
%; locking and unlocking doors
%; agent unlocks door.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:446
% event DoorUnlock(agent,door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:447
event(doorUnlock(DoorUnlock_Param,DoorUnlock_Ret)).
==> mpred_prop(doorUnlock(agent,door),event).
==> meta_argtypes(doorUnlock(agent,door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:447
%; agent locks door.

% event DoorLock(agent,door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:449
event(doorLock(DoorLock_Param,DoorLock_Ret)).
==> mpred_prop(doorLock(agent,door),event).
==> meta_argtypes(doorLock(agent,door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:449
%; door is unlocked.

% fluent DoorUnlocked(door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:451
fluent(doorUnlocked(DoorUnlocked_Ret)).
==> mpred_prop(doorUnlocked(door),fluent).
==> meta_argtypes(doorUnlocked(door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:452
%; A precondition axiom states that
%; for an agent to unlock a door,
%; the agent must be awake,
%; the door must not already be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:458
% Happens(DoorUnlock(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).

 /*  allDifferent([Agent, Door, Time]) ->
       ( happens(doorUnlock(Agent, Door), Time)->holds_at(awake(Agent), Time), holds_at(neg(doorUnlocked(Door)), Time), holds_at(nearPortal(Agent, Door), Time)
       ).
 */

 /*  not(happens(doorUnlock(Agent, Door), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(neg(doorUnlocked(Door)), Time))
       ;   not(holds_at(nearPortal(Agent, Door), Time))
       ),
       allDifferent([Agent, Door, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(neg(doorUnlocked(Door)), Time))
       ;   not(holds_at(nearPortal(Agent, Door), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(neg(doorUnlocked(Door))), Time)
       ;   holds_at(neg(nearPortal(Agent, Door)), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(neg(doorUnlocked(Door))), Time);holds_at(neg(nearPortal(Agent, Door)), Time)), allDifferent([Agent, Door, Time])] ->
       ta(Time, not(happens(doorUnlock(Agent, Door), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:461
axiom(not(happens(doorUnlock(Agent, Door), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(neg(doorUnlocked(Door))), Time);holds_at(neg(nearPortal(Agent, Door)), Time)),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(doorUnlock(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorUnlock(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(doorUnlock(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(neg(doorUnlocked(Door)), Time) :-
       happens(doorUnlock(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorUnlock(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(neg(doorUnlocked(Door)), Time)).
 */
axiom(holds_at(neg(doorUnlocked(Door)), Time),
   
    [ happens(doorUnlock(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(nearPortal(Agent, Door), Time) :-
       happens(doorUnlock(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorUnlock(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(nearPortal(Agent, Door), Time)).
 */
axiom(holds_at(nearPortal(Agent, Door), Time),
   
    [ happens(doorUnlock(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:463
%; An effect axiom states that
%; if an agent unlocks a door,
%; the door will be unlocked:
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:467
% Initiates(DoorUnlock(agent,door),DoorUnlocked(door),time).

 /*  [] ->
       ta(Time,
          initiates(doorUnlock(Agent, Door),
                    doorUnlocked(Door),
                    Time)).
 */
axiom(initiates(doorUnlock(Agent, Door), doorUnlocked(Door), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:469
%; A precondition axiom states that
%; for an agent to lock a door,
%; the agent must be awake,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:475
% Happens(DoorLock(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).

 /*  allDifferent([Agent, Door, Time]) ->
       ( happens(doorLock(Agent, Door), Time)->holds_at(awake(Agent), Time), holds_at(doorUnlocked(Door), Time), holds_at(nearPortal(Agent, Door), Time)
       ).
 */

 /*  not(happens(doorLock(Agent, Door), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(doorUnlocked(Door), Time))
       ;   not(holds_at(nearPortal(Agent, Door), Time))
       ),
       allDifferent([Agent, Door, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(doorUnlocked(Door), Time))
       ;   not(holds_at(nearPortal(Agent, Door), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(doorUnlocked(Door)), Time)
       ;   holds_at(neg(nearPortal(Agent, Door)), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(doorUnlocked(Door)), Time);holds_at(neg(nearPortal(Agent, Door)), Time)), allDifferent([Agent, Door, Time])] ->
       ta(Time, not(happens(doorLock(Agent, Door), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:478
axiom(not(happens(doorLock(Agent, Door), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(doorUnlocked(Door)), Time);holds_at(neg(nearPortal(Agent, Door)), Time)),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(doorLock(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorLock(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(doorLock(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(doorUnlocked(Door), Time) :-
       happens(doorLock(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorLock(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(doorUnlocked(Door), Time)).
 */
axiom(holds_at(doorUnlocked(Door), Time),
   
    [ happens(doorLock(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(nearPortal(Agent, Door), Time) :-
       happens(doorLock(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorLock(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(nearPortal(Agent, Door), Time)).
 */
axiom(holds_at(nearPortal(Agent, Door), Time),
   
    [ happens(doorLock(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:480
%; An effect axiom states that
%; if an agent locks a door,
%; the door will no longer be unlocked.
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:484
% Terminates(DoorLock(agent,door),DoorUnlocked(door),time).

 /*  [] ->
       ta(Time,
          terminates(doorLock(Agent, Door),
                     doorUnlocked(Door),
                     Time)).
 */
axiom(terminates(doorLock(Agent, Door), doorUnlocked(Door), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:486
%; A state constraint says that if a door is open,
%; it is unlocked:
% [door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:489
% HoldsAt(DoorIsOpen(door),time) -> HoldsAt(DoorUnlocked(door),time).

 /*  allDifferent([Door, Time]) ->
       ( holds_at(doorIsOpen(Door), Time)->holds_at(doorUnlocked(Door), Time)
       ).
 */

 /*  holds_at(doorUnlocked(Door), Time) :-
       holds_at(doorIsOpen(Door), Time),
       allDifferent([Door, Time]).
 */

 /*  [holds_at(doorIsOpen(Door), Time), allDifferent([Door, Time])] ->
       ta(Time, holds_at(doorUnlocked(Door), Time)).
 */
axiom(holds_at(doorUnlocked(Door), Time),
   
    [ holds_at(doorIsOpen(Door), Time),
      allDifferent([Door, Time])
    ]).

 /*  not(holds_at(doorIsOpen(Door), Time)) :-
       not(holds_at(doorUnlocked(Door), Time)),
       allDifferent([Door, Time]).
 */

 /*  [holds_at(neg(doorUnlocked(Door)), Time), allDifferent([Door, Time])] ->
       ta(Time, holds_at(neg(doorIsOpen(Door)), Time)).
 */
axiom(holds_at(neg(doorIsOpen(Door)), Time),
   
    [ holds_at(neg(doorUnlocked(Door)), Time),
      allDifferent([Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:491
%; opening and closing doors
%; agent opens door.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:494
% event DoorOpen(agent,door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:495
event(doorOpen(DoorOpen_Param,DoorOpen_Ret)).
==> mpred_prop(doorOpen(agent,door),event).
==> meta_argtypes(doorOpen(agent,door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:495
%; agent closes door.

% event DoorClose(agent,door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:497
event(doorClose(DoorClose_Param,DoorClose_Ret)).
==> mpred_prop(doorClose(agent,door),event).
==> meta_argtypes(doorClose(agent,door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:497
%; door is open.

% fluent DoorIsOpen(door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:499
fluent(doorIsOpen(DoorIsOpen_Ret)).
==> mpred_prop(doorIsOpen(door),fluent).
==> meta_argtypes(doorIsOpen(door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:500
%; A precondition axiom states that
%; for an agent to open a door,
%; the agent must be awake,
%; the door must not already be open,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:507
% Happens(DoorOpen(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).

 /*  allDifferent([Agent, Door, Time]) ->
       ( happens(doorOpen(Agent, Door), Time)->holds_at(awake(Agent), Time), holds_at(neg(doorIsOpen(Door)), Time), holds_at(doorUnlocked(Door), Time), holds_at(nearPortal(Agent, Door), Time)
       ).
 */

 /*  not(happens(doorOpen(Agent, Door), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(neg(doorIsOpen(Door)), Time))
       ;   not(holds_at(doorUnlocked(Door), Time))
       ;   not(holds_at(nearPortal(Agent, Door), Time))
       ),
       allDifferent([Agent, Door, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(neg(doorIsOpen(Door)), Time))
       ;   not(holds_at(doorUnlocked(Door), Time))
       ;   not(holds_at(nearPortal(Agent, Door), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(neg(doorIsOpen(Door))), Time)
       ;   holds_at(neg(doorUnlocked(Door)), Time)
       ;   holds_at(neg(nearPortal(Agent, Door)), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(neg(doorIsOpen(Door))), Time);holds_at(neg(doorUnlocked(Door)), Time);holds_at(neg(nearPortal(Agent, Door)), Time)), allDifferent([Agent, Door, Time])] ->
       ta(Time, not(happens(doorOpen(Agent, Door), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:511
axiom(not(happens(doorOpen(Agent, Door), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(neg(doorIsOpen(Door))), Time);holds_at(neg(doorUnlocked(Door)), Time);holds_at(neg(nearPortal(Agent, Door)), Time)),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(doorOpen(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorOpen(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(doorOpen(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(neg(doorIsOpen(Door)), Time) :-
       happens(doorOpen(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorOpen(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(neg(doorIsOpen(Door)), Time)).
 */
axiom(holds_at(neg(doorIsOpen(Door)), Time),
   
    [ happens(doorOpen(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(doorUnlocked(Door), Time) :-
       happens(doorOpen(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorOpen(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(doorUnlocked(Door), Time)).
 */
axiom(holds_at(doorUnlocked(Door), Time),
   
    [ happens(doorOpen(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(nearPortal(Agent, Door), Time) :-
       happens(doorOpen(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorOpen(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(nearPortal(Agent, Door), Time)).
 */
axiom(holds_at(nearPortal(Agent, Door), Time),
   
    [ happens(doorOpen(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:513
%; An effect axiom states that
%; if an agent opens a door,
%; the door will be open:
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:517
% Initiates(DoorOpen(agent,door),DoorIsOpen(door),time).

 /*  [] ->
       ta(Time,
          initiates(doorOpen(Agent, Door),
                    doorIsOpen(Door),
                    Time)).
 */
axiom(initiates(doorOpen(Agent, Door), doorIsOpen(Door), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:519
%; A precondition axiom states that
%; for an agent to close a door,
%; the agent must be awake,
%; the door must be open,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:526
% Happens(DoorClose(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).

 /*  allDifferent([Agent, Door, Time]) ->
       ( happens(doorClose(Agent, Door), Time)->holds_at(awake(Agent), Time), holds_at(doorIsOpen(Door), Time), holds_at(doorUnlocked(Door), Time), holds_at(nearPortal(Agent, Door), Time)
       ).
 */

 /*  not(happens(doorClose(Agent, Door), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(doorIsOpen(Door), Time))
       ;   not(holds_at(doorUnlocked(Door), Time))
       ;   not(holds_at(nearPortal(Agent, Door), Time))
       ),
       allDifferent([Agent, Door, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(doorIsOpen(Door), Time))
       ;   not(holds_at(doorUnlocked(Door), Time))
       ;   not(holds_at(nearPortal(Agent, Door), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(doorIsOpen(Door)), Time)
       ;   holds_at(neg(doorUnlocked(Door)), Time)
       ;   holds_at(neg(nearPortal(Agent, Door)), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(doorIsOpen(Door)), Time);holds_at(neg(doorUnlocked(Door)), Time);holds_at(neg(nearPortal(Agent, Door)), Time)), allDifferent([Agent, Door, Time])] ->
       ta(Time, not(happens(doorClose(Agent, Door), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:530
axiom(not(happens(doorClose(Agent, Door), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(doorIsOpen(Door)), Time);holds_at(neg(doorUnlocked(Door)), Time);holds_at(neg(nearPortal(Agent, Door)), Time)),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(doorClose(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorClose(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(doorClose(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(doorIsOpen(Door), Time) :-
       happens(doorClose(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorClose(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(doorIsOpen(Door), Time)).
 */
axiom(holds_at(doorIsOpen(Door), Time),
   
    [ happens(doorClose(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(doorUnlocked(Door), Time) :-
       happens(doorClose(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorClose(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(doorUnlocked(Door), Time)).
 */
axiom(holds_at(doorUnlocked(Door), Time),
   
    [ happens(doorClose(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(nearPortal(Agent, Door), Time) :-
       happens(doorClose(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(doorClose(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(nearPortal(Agent, Door), Time)).
 */
axiom(holds_at(nearPortal(Agent, Door), Time),
   
    [ happens(doorClose(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:532
%; An effect axiom states that
%; if an agent closes a door,
%; the door will no longer be open:
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:536
% Terminates(DoorClose(agent,door),DoorIsOpen(door),time).

 /*  [] ->
       ta(Time,
          terminates(doorClose(Agent, Door),
                     doorIsOpen(Door),
                     Time)).
 */
axiom(terminates(doorClose(Agent, Door), doorIsOpen(Door), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:538
%; passing through doors
%; agent walks through side one of door.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:541
% event WalkThroughDoor12(agent,door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:542
event(walkThroughDoor12(WalkThroughDoor12_Param,
			WalkThroughDoor12_Ret)).
==> mpred_prop(walkThroughDoor12(agent,door),event).
==> meta_argtypes(walkThroughDoor12(agent,door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:542
%; agent walks through side two of door.

% event WalkThroughDoor21(agent,door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:544
event(walkThroughDoor21(WalkThroughDoor21_Param,
			WalkThroughDoor21_Ret)).
==> mpred_prop(walkThroughDoor21(agent,door),event).
==> meta_argtypes(walkThroughDoor21(agent,door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:545
%; Precondition axioms state that
%; for an agent to walk through a side of a door,
%; the agent must be awake and standing,
%; the door must be open, and
%; the agent must be at the side of the door that
%; the agent walks through:
% [agent,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:552
% Happens(WalkThroughDoor12(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(At(agent,Side1(door)),time).

 /*  allDifferent([Agent, Door, Time]) ->
       ( happens(walkThroughDoor12(Agent, Door), Time)->holds_at(awake(Agent), Time), holds_at(standing(Agent), Time), holds_at(doorIsOpen(Door), Time), holds_at(at(Agent, side1(Door)), Time)
       ).
 */

 /*  not(happens(walkThroughDoor12(Agent, Door), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(doorIsOpen(Door), Time))
       ;   not(holds_at(at(Agent, side1(Door)), Time))
       ),
       allDifferent([Agent, Door, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(doorIsOpen(Door), Time))
       ;   not(holds_at(at(Agent, side1(Door)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(standing(Agent)), Time)
       ;   holds_at(neg(doorIsOpen(Door)), Time)
       ;   holds_at(neg(at(Agent, side1(Door))), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(doorIsOpen(Door)), Time);holds_at(neg(at(Agent, side1(Door))), Time)), allDifferent([Agent, Door, Time])] ->
       ta(Time,
          not(happens(walkThroughDoor12(Agent, Door), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:556
axiom(not(happens(walkThroughDoor12(Agent, Door), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(doorIsOpen(Door)), Time);holds_at(neg(at(Agent, side1(Door))), Time)),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(walkThroughDoor12(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor12(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(walkThroughDoor12(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(standing(Agent), Time) :-
       happens(walkThroughDoor12(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor12(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(standing(Agent), Time)).
 */
axiom(holds_at(standing(Agent), Time),
   
    [ happens(walkThroughDoor12(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(doorIsOpen(Door), Time) :-
       happens(walkThroughDoor12(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor12(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(doorIsOpen(Door), Time)).
 */
axiom(holds_at(doorIsOpen(Door), Time),
   
    [ happens(walkThroughDoor12(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(at(Agent, side1(Door)), Time) :-
       happens(walkThroughDoor12(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor12(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(at(Agent, side1(Door)), Time)).
 */
axiom(holds_at(at(Agent, side1(Door)), Time),
   
    [ happens(walkThroughDoor12(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:558
% [agent,door,time]
% Happens(WalkThroughDoor21(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(At(agent,Side2(door)),time).

 /*  allDifferent([Agent, Door, Time]) ->
       ( happens(walkThroughDoor21(Agent, Door), Time)->holds_at(awake(Agent), Time), holds_at(standing(Agent), Time), holds_at(doorIsOpen(Door), Time), holds_at(at(Agent, side2(Door)), Time)
       ).
 */

 /*  not(happens(walkThroughDoor21(Agent, Door), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(doorIsOpen(Door), Time))
       ;   not(holds_at(at(Agent, side2(Door)), Time))
       ),
       allDifferent([Agent, Door, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(doorIsOpen(Door), Time))
       ;   not(holds_at(at(Agent, side2(Door)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(standing(Agent)), Time)
       ;   holds_at(neg(doorIsOpen(Door)), Time)
       ;   holds_at(neg(at(Agent, side2(Door))), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(doorIsOpen(Door)), Time);holds_at(neg(at(Agent, side2(Door))), Time)), allDifferent([Agent, Door, Time])] ->
       ta(Time,
          not(happens(walkThroughDoor21(Agent, Door), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:563
axiom(not(happens(walkThroughDoor21(Agent, Door), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(doorIsOpen(Door)), Time);holds_at(neg(at(Agent, side2(Door))), Time)),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(walkThroughDoor21(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor21(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(walkThroughDoor21(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(standing(Agent), Time) :-
       happens(walkThroughDoor21(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor21(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(standing(Agent), Time)).
 */
axiom(holds_at(standing(Agent), Time),
   
    [ happens(walkThroughDoor21(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(doorIsOpen(Door), Time) :-
       happens(walkThroughDoor21(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor21(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(doorIsOpen(Door), Time)).
 */
axiom(holds_at(doorIsOpen(Door), Time),
   
    [ happens(walkThroughDoor21(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(at(Agent, side2(Door)), Time) :-
       happens(walkThroughDoor21(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor21(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(at(Agent, side2(Door)), Time)).
 */
axiom(holds_at(at(Agent, side2(Door)), Time),
   
    [ happens(walkThroughDoor21(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:565
%; Effect axioms state that
%; if an agent walks through one side of a door,
%; the agent will be at the other side of the door:
% [agent,door,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:569
% Side2(door)=location ->
% Initiates(WalkThroughDoor12(agent,door),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [call(side2(Door)=Location)] ->
       ta(Time,
          initiates(walkThroughDoor12(Agent, Door),
                    at(Agent, Location),
                    Time)).
 */

 /*  [holds_at(call(side2(Door)=Location), Time)] ->
       ta(Time,
          initiates(walkThroughDoor12(Agent, Door),
                    at(Agent, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:570
axiom(initiates(walkThroughDoor12(Agent, Door), at(Agent, Location), Time),
    [holds_at(call(side2(Door)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:572
% [agent,door,location,time]
% Side1(door)=location ->
% Initiates(WalkThroughDoor21(agent,door),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [call(side1(Door)=Location)] ->
       ta(Time,
          initiates(walkThroughDoor21(Agent, Door),
                    at(Agent, Location),
                    Time)).
 */

 /*  [holds_at(call(side1(Door)=Location), Time)] ->
       ta(Time,
          initiates(walkThroughDoor21(Agent, Door),
                    at(Agent, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:574
axiom(initiates(walkThroughDoor21(Agent, Door), at(Agent, Location), Time),
    [holds_at(call(side1(Door)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:576
% [agent,door,location,time]
% Side1(door)=location ->
% Terminates(WalkThroughDoor12(agent,door),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [call(side1(Door)=Location)] ->
       ta(Time,
          terminates(walkThroughDoor12(Agent, Door),
                     at(Agent, Location),
                     Time)).
 */

 /*  [holds_at(call(side1(Door)=Location), Time)] ->
       ta(Time,
          terminates(walkThroughDoor12(Agent, Door),
                     at(Agent, Location),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:578
axiom(terminates(walkThroughDoor12(Agent, Door), at(Agent, Location), Time),
    [holds_at(call(side1(Door)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:580
% [agent,door,location,time]
% Side2(door)=location ->
% Terminates(WalkThroughDoor21(agent,door),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [call(side2(Door)=Location)] ->
       ta(Time,
          terminates(walkThroughDoor21(Agent, Door),
                     at(Agent, Location),
                     Time)).
 */

 /*  [holds_at(call(side2(Door)=Location), Time)] ->
       ta(Time,
          terminates(walkThroughDoor21(Agent, Door),
                     at(Agent, Location),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:582
axiom(terminates(walkThroughDoor21(Agent, Door), at(Agent, Location), Time),
    [holds_at(call(side2(Door)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:584
%; walking from one end of a street to another
%; agent walks from the first end of street to the second end.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:587
% event WalkStreet12(agent,street)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:588
event(walkStreet12(WalkStreet12_Param,WalkStreet12_Ret)).
==> mpred_prop(walkStreet12(agent,street),event).
==> meta_argtypes(walkStreet12(agent,street)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:588
%; agent walks from the second end of street to the first end.

% event WalkStreet21(agent,street)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:590
event(walkStreet21(WalkStreet21_Param,WalkStreet21_Ret)).
==> mpred_prop(walkStreet21(agent,street),event).
==> meta_argtypes(walkStreet21(agent,street)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:591
%; Precondition axioms state that
%; for an agent to walk from one end of a street to another,
%; the agent must be awake,
%; the agent must be standing, and
%; the agent must be at the first end of the street:
% [agent,street,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:597
% Happens(WalkStreet12(agent,street),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(street)),time).

 /*  allDifferent([Agent, Street, Time]) ->
       ( happens(walkStreet12(Agent, Street), Time)->holds_at(awake(Agent), Time), holds_at(standing(Agent), Time), holds_at(at(Agent, side1(Street)), Time)
       ).
 */

 /*  not(happens(walkStreet12(Agent, Street), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side1(Street)), Time))
       ),
       allDifferent([Agent, Street, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side1(Street)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(standing(Agent)), Time)
       ;   holds_at(neg(at(Agent, side1(Street))), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side1(Street))), Time)), allDifferent([Agent, Street, Time])] ->
       ta(Time,
          not(happens(walkStreet12(Agent, Street), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:600
axiom(not(happens(walkStreet12(Agent, Street), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side1(Street))), Time)),
      allDifferent([Agent, Street, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(walkStreet12(Agent, Street), Time),
       allDifferent([Agent, Street, Time]).
 */

 /*  [happens(walkStreet12(Agent, Street), Time), allDifferent([Agent, Street, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(walkStreet12(Agent, Street), Time),
      allDifferent([Agent, Street, Time])
    ]).

 /*  holds_at(standing(Agent), Time) :-
       happens(walkStreet12(Agent, Street), Time),
       allDifferent([Agent, Street, Time]).
 */

 /*  [happens(walkStreet12(Agent, Street), Time), allDifferent([Agent, Street, Time])] ->
       ta(Time, holds_at(standing(Agent), Time)).
 */
axiom(holds_at(standing(Agent), Time),
   
    [ happens(walkStreet12(Agent, Street), Time),
      allDifferent([Agent, Street, Time])
    ]).

 /*  holds_at(at(Agent, side1(Street)), Time) :-
       happens(walkStreet12(Agent, Street), Time),
       allDifferent([Agent, Street, Time]).
 */

 /*  [happens(walkStreet12(Agent, Street), Time), allDifferent([Agent, Street, Time])] ->
       ta(Time, holds_at(at(Agent, side1(Street)), Time)).
 */
axiom(holds_at(at(Agent, side1(Street)), Time),
   
    [ happens(walkStreet12(Agent, Street), Time),
      allDifferent([Agent, Street, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:602
% [agent,street,time]
% Happens(WalkStreet21(agent,street),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(street)),time).

 /*  allDifferent([Agent, Street, Time]) ->
       ( happens(walkStreet21(Agent, Street), Time)->holds_at(awake(Agent), Time), holds_at(standing(Agent), Time), holds_at(at(Agent, side2(Street)), Time)
       ).
 */

 /*  not(happens(walkStreet21(Agent, Street), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side2(Street)), Time))
       ),
       allDifferent([Agent, Street, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side2(Street)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(standing(Agent)), Time)
       ;   holds_at(neg(at(Agent, side2(Street))), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side2(Street))), Time)), allDifferent([Agent, Street, Time])] ->
       ta(Time,
          not(happens(walkStreet21(Agent, Street), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:606
axiom(not(happens(walkStreet21(Agent, Street), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side2(Street))), Time)),
      allDifferent([Agent, Street, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(walkStreet21(Agent, Street), Time),
       allDifferent([Agent, Street, Time]).
 */

 /*  [happens(walkStreet21(Agent, Street), Time), allDifferent([Agent, Street, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(walkStreet21(Agent, Street), Time),
      allDifferent([Agent, Street, Time])
    ]).

 /*  holds_at(standing(Agent), Time) :-
       happens(walkStreet21(Agent, Street), Time),
       allDifferent([Agent, Street, Time]).
 */

 /*  [happens(walkStreet21(Agent, Street), Time), allDifferent([Agent, Street, Time])] ->
       ta(Time, holds_at(standing(Agent), Time)).
 */
axiom(holds_at(standing(Agent), Time),
   
    [ happens(walkStreet21(Agent, Street), Time),
      allDifferent([Agent, Street, Time])
    ]).

 /*  holds_at(at(Agent, side2(Street)), Time) :-
       happens(walkStreet21(Agent, Street), Time),
       allDifferent([Agent, Street, Time]).
 */

 /*  [happens(walkStreet21(Agent, Street), Time), allDifferent([Agent, Street, Time])] ->
       ta(Time, holds_at(at(Agent, side2(Street)), Time)).
 */
axiom(holds_at(at(Agent, side2(Street)), Time),
   
    [ happens(walkStreet21(Agent, Street), Time),
      allDifferent([Agent, Street, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:608
%; Effect axioms state that
%; if an agent walks from one end of a street to another,
%; the agent will be at the other end of the street:
% [agent,street,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:612
% Side2(street)=location ->
% Initiates(WalkStreet12(agent,street),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side2(Street), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Street)=Location).
 */

 /*  [call(side2(Street)=Location)] ->
       ta(Time,
          initiates(walkStreet12(Agent, Street),
                    at(Agent, Location),
                    Time)).
 */

 /*  [holds_at(call(side2(Street)=Location), Time)] ->
       ta(Time,
          initiates(walkStreet12(Agent, Street),
                    at(Agent, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:613
axiom(initiates(walkStreet12(Agent, Street), at(Agent, Location), Time),
    [holds_at(call(side2(Street)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:615
% [agent,street,location,time]
% Side1(street)=location ->
% Initiates(WalkStreet21(agent,street),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side1(Street), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Street)=Location).
 */

 /*  [call(side1(Street)=Location)] ->
       ta(Time,
          initiates(walkStreet21(Agent, Street),
                    at(Agent, Location),
                    Time)).
 */

 /*  [holds_at(call(side1(Street)=Location), Time)] ->
       ta(Time,
          initiates(walkStreet21(Agent, Street),
                    at(Agent, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:617
axiom(initiates(walkStreet21(Agent, Street), at(Agent, Location), Time),
    [holds_at(call(side1(Street)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:619
% [agent,street,location,time]
% Side1(street)=location ->
% Terminates(WalkStreet12(agent,street),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side1(Street), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Street)=Location).
 */

 /*  [call(side1(Street)=Location)] ->
       ta(Time,
          terminates(walkStreet12(Agent, Street),
                     at(Agent, Location),
                     Time)).
 */

 /*  [holds_at(call(side1(Street)=Location), Time)] ->
       ta(Time,
          terminates(walkStreet12(Agent, Street),
                     at(Agent, Location),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:621
axiom(terminates(walkStreet12(Agent, Street), at(Agent, Location), Time),
    [holds_at(call(side1(Street)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:623
% [agent,street,location,time]
% Side2(street)=location ->
% Terminates(WalkStreet21(agent,street),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side2(Street), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Street)=Location).
 */

 /*  [call(side2(Street)=Location)] ->
       ta(Time,
          terminates(walkStreet21(Agent, Street),
                     at(Agent, Location),
                     Time)).
 */

 /*  [holds_at(call(side2(Street)=Location), Time)] ->
       ta(Time,
          terminates(walkStreet21(Agent, Street),
                     at(Agent, Location),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:625
axiom(terminates(walkStreet21(Agent, Street), at(Agent, Location), Time),
    [holds_at(call(side2(Street)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:627
%; floors
%; The floor of room is integer.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:630
% function Floor(room): integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:631
functional_predicate(floor(Floor_Param,Floor_Ret)).
==> mpred_prop(floor(room,integer),functional_predicate).
==> meta_argtypes(floor(room,integer)).
==> resultIsa(floor,integer).
%; walking up and down staircases
%; agent walks down staircase.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:635
% event WalkDownStaircase(agent,staircase)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:636
event(walkDownStaircase(WalkDownStaircase_Param,
			WalkDownStaircase_Ret)).
==> mpred_prop(walkDownStaircase(agent,staircase),event).
==> meta_argtypes(walkDownStaircase(agent,staircase)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:636
%; agent walks up staircase.

% event WalkUpStaircase(agent,staircase)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:638
event(walkUpStaircase(WalkUpStaircase_Param,
		      WalkUpStaircase_Ret)).
==> mpred_prop(walkUpStaircase(agent,staircase),event).
==> meta_argtypes(walkUpStaircase(agent,staircase)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:639
%; Precondition axioms state that
%; for an agent to walk down (up) a staircase,
%; the agent must be awake, standing, and
%; at the top (bottom) of the staircase:
% [agent,staircase,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:644
% Happens(WalkDownStaircase(agent,staircase),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(staircase)),time).

 /*  allDifferent([Agent, Staircase, Time]) ->
       ( happens(walkDownStaircase(Agent, Staircase), Time)->holds_at(awake(Agent), Time), holds_at(standing(Agent), Time), holds_at(at(Agent, side2(Staircase)), Time)
       ).
 */

 /*  not(happens(walkDownStaircase(Agent, Staircase), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side2(Staircase)), Time))
       ),
       allDifferent([Agent, Staircase, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side2(Staircase)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(standing(Agent)), Time)
       ;   holds_at(neg(at(Agent, side2(Staircase))), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side2(Staircase))), Time)), allDifferent([Agent, Staircase, Time])] ->
       ta(Time,
          not(happens(walkDownStaircase(Agent, Staircase), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:647
axiom(not(happens(walkDownStaircase(Agent, Staircase), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side2(Staircase))), Time)),
      allDifferent([Agent, Staircase, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(walkDownStaircase(Agent, Staircase), Time),
       allDifferent([Agent, Staircase, Time]).
 */

 /*  [happens(walkDownStaircase(Agent, Staircase), Time), allDifferent([Agent, Staircase, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(walkDownStaircase(Agent, Staircase), Time),
      allDifferent([Agent, Staircase, Time])
    ]).

 /*  holds_at(standing(Agent), Time) :-
       happens(walkDownStaircase(Agent, Staircase), Time),
       allDifferent([Agent, Staircase, Time]).
 */

 /*  [happens(walkDownStaircase(Agent, Staircase), Time), allDifferent([Agent, Staircase, Time])] ->
       ta(Time, holds_at(standing(Agent), Time)).
 */
axiom(holds_at(standing(Agent), Time),
   
    [ happens(walkDownStaircase(Agent, Staircase), Time),
      allDifferent([Agent, Staircase, Time])
    ]).

 /*  holds_at(at(Agent, side2(Staircase)), Time) :-
       happens(walkDownStaircase(Agent, Staircase), Time),
       allDifferent([Agent, Staircase, Time]).
 */

 /*  [happens(walkDownStaircase(Agent, Staircase), Time), allDifferent([Agent, Staircase, Time])] ->
       ta(Time, holds_at(at(Agent, side2(Staircase)), Time)).
 */
axiom(holds_at(at(Agent, side2(Staircase)), Time),
   
    [ happens(walkDownStaircase(Agent, Staircase), Time),
      allDifferent([Agent, Staircase, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:649
% [agent,staircase,time]
% Happens(WalkUpStaircase(agent,staircase),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(staircase)),time).

 /*  allDifferent([Agent, Staircase, Time]) ->
       ( happens(walkUpStaircase(Agent, Staircase), Time)->holds_at(awake(Agent), Time), holds_at(standing(Agent), Time), holds_at(at(Agent, side1(Staircase)), Time)
       ).
 */

 /*  not(happens(walkUpStaircase(Agent, Staircase), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side1(Staircase)), Time))
       ),
       allDifferent([Agent, Staircase, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side1(Staircase)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(standing(Agent)), Time)
       ;   holds_at(neg(at(Agent, side1(Staircase))), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side1(Staircase))), Time)), allDifferent([Agent, Staircase, Time])] ->
       ta(Time,
          not(happens(walkUpStaircase(Agent, Staircase), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:653
axiom(not(happens(walkUpStaircase(Agent, Staircase), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side1(Staircase))), Time)),
      allDifferent([Agent, Staircase, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(walkUpStaircase(Agent, Staircase), Time),
       allDifferent([Agent, Staircase, Time]).
 */

 /*  [happens(walkUpStaircase(Agent, Staircase), Time), allDifferent([Agent, Staircase, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(walkUpStaircase(Agent, Staircase), Time),
      allDifferent([Agent, Staircase, Time])
    ]).

 /*  holds_at(standing(Agent), Time) :-
       happens(walkUpStaircase(Agent, Staircase), Time),
       allDifferent([Agent, Staircase, Time]).
 */

 /*  [happens(walkUpStaircase(Agent, Staircase), Time), allDifferent([Agent, Staircase, Time])] ->
       ta(Time, holds_at(standing(Agent), Time)).
 */
axiom(holds_at(standing(Agent), Time),
   
    [ happens(walkUpStaircase(Agent, Staircase), Time),
      allDifferent([Agent, Staircase, Time])
    ]).

 /*  holds_at(at(Agent, side1(Staircase)), Time) :-
       happens(walkUpStaircase(Agent, Staircase), Time),
       allDifferent([Agent, Staircase, Time]).
 */

 /*  [happens(walkUpStaircase(Agent, Staircase), Time), allDifferent([Agent, Staircase, Time])] ->
       ta(Time, holds_at(at(Agent, side1(Staircase)), Time)).
 */
axiom(holds_at(at(Agent, side1(Staircase)), Time),
   
    [ happens(walkUpStaircase(Agent, Staircase), Time),
      allDifferent([Agent, Staircase, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:655
%; Effect axioms state that
%; if an agent walks down (up) a staircase,
%; the agent will be at the bottom (top) of the staircase:
% [agent,staircase,room,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:659
% Side1(staircase)=room ->
% Initiates(WalkDownStaircase(agent,staircase),At(agent,room),time).

 /*  axiom_head(Time) ->
       equals(side1(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Staircase)=Room).
 */

 /*  [call(side1(Staircase)=Room)] ->
       ta(Time,
          initiates(walkDownStaircase(Agent, Staircase),
                    at(Agent, Room),
                    Time)).
 */

 /*  [holds_at(call(side1(Staircase)=Room), Time)] ->
       ta(Time,
          initiates(walkDownStaircase(Agent, Staircase),
                    at(Agent, Room),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:660
axiom(initiates(walkDownStaircase(Agent, Staircase), at(Agent, Room), Time),
    [holds_at(call(side1(Staircase)=Room), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:662
% [agent,staircase,room,time]
% Side2(staircase)=room ->
% Terminates(WalkDownStaircase(agent,staircase),At(agent,room),time).

 /*  axiom_head(Time) ->
       equals(side2(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Staircase)=Room).
 */

 /*  [call(side2(Staircase)=Room)] ->
       ta(Time,
          terminates(walkDownStaircase(Agent, Staircase),
                     at(Agent, Room),
                     Time)).
 */

 /*  [holds_at(call(side2(Staircase)=Room), Time)] ->
       ta(Time,
          terminates(walkDownStaircase(Agent, Staircase),
                     at(Agent, Room),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:664
axiom(terminates(walkDownStaircase(Agent, Staircase), at(Agent, Room), Time),
    [holds_at(call(side2(Staircase)=Room), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:666
% [agent,staircase,room,time]
% Side2(staircase)=room ->
% Initiates(WalkUpStaircase(agent,staircase),At(agent,room),time).

 /*  axiom_head(Time) ->
       equals(side2(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Staircase)=Room).
 */

 /*  [call(side2(Staircase)=Room)] ->
       ta(Time,
          initiates(walkUpStaircase(Agent, Staircase),
                    at(Agent, Room),
                    Time)).
 */

 /*  [holds_at(call(side2(Staircase)=Room), Time)] ->
       ta(Time,
          initiates(walkUpStaircase(Agent, Staircase),
                    at(Agent, Room),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:668
axiom(initiates(walkUpStaircase(Agent, Staircase), at(Agent, Room), Time),
    [holds_at(call(side2(Staircase)=Room), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:670
% [agent,staircase,room,time]
% Side1(staircase)=room ->
% Terminates(WalkUpStaircase(agent,staircase),At(agent,room),time).

 /*  axiom_head(Time) ->
       equals(side1(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Staircase)=Room).
 */

 /*  [call(side1(Staircase)=Room)] ->
       ta(Time,
          terminates(walkUpStaircase(Agent, Staircase),
                     at(Agent, Room),
                     Time)).
 */

 /*  [holds_at(call(side1(Staircase)=Room), Time)] ->
       ta(Time,
          terminates(walkUpStaircase(Agent, Staircase),
                     at(Agent, Room),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:672
axiom(terminates(walkUpStaircase(Agent, Staircase), at(Agent, Room), Time),
    [holds_at(call(side1(Staircase)=Room), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:674
%; A state constraint says that if an agent is outside,
%; the agent is dressed.
% [agent,outside,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:677
% HoldsAt(At(agent,outside),time) ->
% HoldsAt(Dressed(agent),time).

 /*  allDifferent([Agent, Outside, Time]) ->
       ( holds_at(at(Agent, Outside), Time)->holds_at(dressed(Agent), Time)
       ).
 */

 /*  holds_at(dressed(Agent), Time) :-
       holds_at(at(Agent, Outside), Time),
       allDifferent([Agent, Outside, Time]).
 */

 /*  [holds_at(at(Agent, Outside), Time), allDifferent([Agent, Outside, Time])] ->
       ta(Time, holds_at(dressed(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:678
axiom(holds_at(dressed(Agent), Time),
   
    [ holds_at(at(Agent, Outside), Time),
      allDifferent([Agent, Outside, Time])
    ]).

 /*  not(holds_at(at(Agent, Outside), Time)) :-
       not(holds_at(dressed(Agent), Time)),
       allDifferent([Agent, Outside, Time]).
 */

 /*  [holds_at(neg(dressed(Agent)), Time), allDifferent([Agent, Outside, Time])] ->
       ta(Time, holds_at(neg(at(Agent, Outside)), Time)).
 */
axiom(holds_at(neg(at(Agent, Outside)), Time),
   
    [ holds_at(neg(dressed(Agent)), Time),
      allDifferent([Agent, Outside, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:680
%; room looks out onto outside.

% function LookOutOnto(room): outside
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:682
functional_predicate(lookOutOnto(LookOutOnto_Param,
				 LookOutOnto_Ret)).
==> mpred_prop(lookOutOnto(room,outside),functional_predicate).
==> meta_argtypes(lookOutOnto(room,outside)).
==> resultIsa(lookOutOnto,outside).
%; location1 is adjacent to location2.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:684
% predicate Adjacent(location,location)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:685
predicate(adjacent(Adjacent_Param,Adjacent_Ret)).
==> mpred_prop(adjacent(location,location),predicate).
==> meta_argtypes(adjacent(location,location)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:686
%; A state constraint says that
%; two locations are adjacent if and only if
%; they have a portal in common:
% [location1,location2]
 
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:689
% Adjacent(location1,location2) <->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:690
% {portal}% 
% (Side1(portal)=location1 &
%  Side2(portal)=location2) |
% (Side2(portal)=location1 &
%  Side1(portal)=location2).

 /*  exists([Portal],
    adjacent(Location1, Location2) <->
       (   side1(Portal)=Location1,
           side2(Portal)=Location2
       ;   side2(Portal)=Location1,
           side1(Portal)=Location2
       )).
 */

 /*  adjacent(Location1, Location2) :-
       (   equals(side1(Portal), Location1),
           equals(side2(Portal), Location2)
       ;   equals(side2(Portal), Location1),
           equals(side1(Portal), Location2)
       ),
       some(Portal, '$kolem_Fn_201'(Location1, Location2)).
 */

 /*  axiom_head(Axiom_head_Ret) ->
       (   equals(side1(Portal), Location1),
           equals(side2(Portal), Location2)
       ;   equals(side2(Portal), Location1),
           equals(side1(Portal), Location2)
       ).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       (   call(side1(Portal)=Location1),
           call(side2(Portal)=Location2)
       ;   call(side2(Portal)=Location1),
           call(side1(Portal)=Location2)
       ).
 */

 /*  [(call(side1(Portal)=Location1), call(side2(Portal)=Location2);call(side2(Portal)=Location1), call(side1(Portal)=Location2)), some(Portal, '$kolem_Fn_201'(Location1, Location2))] ->
       ta(Axiom_head_Ret, adjacent(Location1, Location2)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:694
axiom(adjacent(Location1, Location2),
   
    [  (call(side1(Portal)=Location1), call(side2(Portal)=Location2);call(side2(Portal)=Location1), call(side1(Portal)=Location2)),
      some(Portal, '$kolem_Fn_201'(Location1, Location2))
    ]).

 /*  not(adjacent(Location1, Location2)) :-
       ( (   not(equals(side1(Portal), Location1))
         ;   not(equals(side2(Portal), Location2))
         ),
         (   not(equals(side2(Portal), Location1))
         ;   not(equals(side1(Portal), Location2))
         )
       ),
       some(Portal, '$kolem_Fn_201'(Location1, Location2)).
 */

 /*  axiom_head(Axiom_head_Ret5) ->
       (   not(equals(side1(Portal), Location1))
       ;   not(equals(side2(Portal), Location2))
       ).
 */

 /*  fix_axiom_head(Axiom_head_Ret5) ->
       (   not(call(side1(Portal)=Location1))
       ;   not(call(side2(Portal)=Location2))
       ).
 */

 /*  axiom_head(Axiom_head_Ret5) ->
       (   not(equals(side2(Portal), Location1))
       ;   not(equals(side1(Portal), Location2))
       ).
 */

 /*  fix_axiom_head(Axiom_head_Ret5) ->
       (   not(call(side2(Portal)=Location1))
       ;   not(call(side1(Portal)=Location2))
       ).
 */

 /*  [(not(call(side1(Portal)=Location1));not(call(side2(Portal)=Location2))),  (not(call(side2(Portal)=Location1));not(call(side1(Portal)=Location2))), some(Portal, '$kolem_Fn_201'(Location1, Location2))] ->
       ta(Axiom_head_Ret5, not(adjacent(Location1, Location2))).
 */
axiom(not(adjacent(Location1, Location2)),
   
    [  (not(call(side1(Portal)=Location1));not(call(side2(Portal)=Location2))),
       (not(call(side2(Portal)=Location1));not(call(side1(Portal)=Location2))),
      some(Portal, '$kolem_Fn_201'(Location1, Location2))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:696
%; The ground of outside is ground.

% function GroundOf(outside): ground
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:698
functional_predicate(groundOf(GroundOf_Param,GroundOf_Ret)).
==> mpred_prop(groundOf(outside,ground),functional_predicate).
==> meta_argtypes(groundOf(outside,ground)).
==> resultIsa(groundOf,ground).
%; The sky of outside is sky.

% function SkyOf(outside): sky
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:700
functional_predicate(skyOf(SkyOf_Param,SkyOf_Ret)).
==> mpred_prop(skyOf(outside,sky),functional_predicate).
==> meta_argtypes(skyOf(outside,sky)).
==> resultIsa(skyOf,sky).
%; State constraints fix the location of ground and sky:
% [outside,ground,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:703
% GroundOf(outside) = ground ->
% HoldsAt(At(ground,outside),time).

 /*  allDifferent([Outside, Ground, Time]) ->
       ( groundOf(Outside)=Ground->holds_at(at(Ground, Outside), Time)
       ).
 */

 /*  holds_at(at(Ground, Outside), Time) :-
       equals(groundOf(Outside), Ground),
       allDifferent([Outside, Ground, Time]).
 */

 /*  axiom_head(Time) ->
       equals(groundOf(Outside), Ground).
 */

 /*  fix_axiom_head(Time) ->
       call(groundOf(Outside)=Ground).
 */

 /*  [call(groundOf(Outside)=Ground), allDifferent([Outside, Ground, Time])] ->
       ta(Time, holds_at(at(Ground, Outside), Time)).
 */

 /*  [holds_at(call(groundOf(Outside)=Ground), Time), allDifferent([Outside, Ground, Time])] ->
       ta(Time, holds_at(at(Ground, Outside), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:704
axiom(holds_at(at(Ground, Outside), Time),
   
    [ holds_at(call(groundOf(Outside)=Ground), Time),
      allDifferent([Outside, Ground, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:706
% [outside,sky,time]
% SkyOf(outside) = sky ->
% HoldsAt(At(sky,outside),time).

 /*  allDifferent([Outside, Sky, Time]) ->
       ( skyOf(Outside)=Sky->holds_at(at(Sky, Outside), Time)
       ).
 */

 /*  holds_at(at(Sky, Outside), Time) :-
       equals(skyOf(Outside), Sky),
       allDifferent([Outside, Sky, Time]).
 */

 /*  axiom_head(Time) ->
       equals(skyOf(Outside), Sky).
 */

 /*  fix_axiom_head(Time) ->
       call(skyOf(Outside)=Sky).
 */

 /*  [call(skyOf(Outside)=Sky), allDifferent([Outside, Sky, Time])] ->
       ta(Time, holds_at(at(Sky, Outside), Time)).
 */

 /*  [holds_at(call(skyOf(Outside)=Sky), Time), allDifferent([Outside, Sky, Time])] ->
       ta(Time, holds_at(at(Sky, Outside), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:708
axiom(holds_at(at(Sky, Outside), Time),
   
    [ holds_at(call(skyOf(Outside)=Sky), Time),
      allDifferent([Outside, Sky, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:710
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/OTSpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; OTSpace: object-scale topological space
%;
%; The OTSpace representation deals with topological space at
%; the scale of objects such as agents (humans and animals)
%; and physical objects.
%;
%; PartOf
%; physobj is a part of object.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:738
% predicate PartOf(physobj,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:739
predicate(partOf(PartOf_Param,PartOf_Ret)).
==> mpred_prop(partOf(physobj,object),predicate).
==> meta_argtypes(partOf(physobj,object)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:740
%; A state constraint says that if a physical object
%; is part of an object, the location of the
%; physical object is the same as the location of the object:
% [physobj,object,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:744
% PartOf(physobj,object) &
% HoldsAt(At(object,location),time) ->
% HoldsAt(At(physobj,location),time).

 /*  allDifferent([Physobj, Object, Location, Time]) ->
       ( partOf(Physobj, Object), holds_at(at(Object, Location), Time)->holds_at(at(Physobj, Location), Time)
       ).
 */

 /*  holds_at(at(Physobj, Location), Time) :-
       ( partOf(Physobj, Object),
         holds_at(at(Object, Location), Time)
       ),
       allDifferent([Physobj, Object, Location, Time]).
 */

 /*  [partOf(Physobj, Object), holds_at(at(Object, Location), Time), allDifferent([Physobj, Object, Location, Time])] ->
       ta(Time, holds_at(at(Physobj, Location), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:746
axiom(holds_at(at(Physobj, Location), Time),
   
    [ partOf(Physobj, Object),
      holds_at(at(Object, Location), Time),
      allDifferent([Physobj, Object, Location, Time])
    ]).

 /*  not(partOf(Physobj, Object)) :-
       holds_at(at(Object, Location), Time),
       not(holds_at(at(Physobj, Location), Time)),
       allDifferent([Physobj, Object, Location, Time]).
 */

 /*  [holds_at(at(Object, Location), Time), holds_at(neg(at(Physobj, Location)), Time), allDifferent([Physobj, Object, Location, Time])] ->
       ta(Time, not(partOf(Physobj, Object))).
 */
axiom(not(partOf(Physobj, Object)),
   
    [ holds_at(at(Object, Location), Time),
      holds_at(neg(at(Physobj, Location)), Time),
      allDifferent([Physobj, Object, Location, Time])
    ]).

 /*  not(holds_at(at(Object, Location), Time)) :-
       partOf(Physobj, Object),
       not(holds_at(at(Physobj, Location), Time)),
       allDifferent([Physobj, Object, Location, Time]).
 */

 /*  [partOf(Physobj, Object), holds_at(neg(at(Physobj, Location)), Time), allDifferent([Physobj, Object, Location, Time])] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */
axiom(holds_at(neg(at(Object, Location)), Time),
   
    [ partOf(Physobj, Object),
      holds_at(neg(at(Physobj, Location)), Time),
      allDifferent([Physobj, Object, Location, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:748
%; rolling a snowball bigger
%; agent rolls stuff1 along stuff2.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:751
% event RollAlong(agent,stuff,stuff)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:752
event(rollAlong(RollAlong_Param,_,RollAlong_Ret)).
==> mpred_prop(rollAlong(agent,stuff,stuff),event).
==> meta_argtypes(rollAlong(agent,stuff,stuff)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:752
%; The diameter of ball is diameter.

% fluent Diameter(ball,diameter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:754
fluent(diameter(Diameter_Param,Diameter_Ret)).
==> mpred_prop(diameter(ball,diameter),fluent).
==> meta_argtypes(diameter(ball,diameter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:755
%; A state constraint says that a ball has a unique diameter:
% [ball,diameter1,diameter2,time]
% HoldsAt(Diameter(ball,diameter1),time) &
% HoldsAt(Diameter(ball,diameter2),time) ->
% diameter1=diameter2.

 /*  allDifferent([Ball, Diameter1, Time, Diameter2]) ->
       ( holds_at(diameter(Ball, Diameter1), Time), holds_at(diameter(Ball, Diameter2), Time)->Diameter1=Diameter2
       ).
 */

 /*  not(holds_at(diameter(Ball, Diameter1), Time)) :-
       holds_at(diameter(Ball, Diameter2), Time),
       not(equals(Diameter1, Diameter2)),
       allDifferent([Ball, Diameter1, Time, Diameter2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Diameter1, Diameter2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Diameter1=Diameter2)).
 */

 /*  [holds_at(diameter(Ball, Diameter2), Time), not(call(Diameter1=Diameter2)), allDifferent([Ball, Diameter1, Time, Diameter2])] ->
       ta(Time,
          holds_at(neg(diameter(Ball, Diameter1)), Time)).
 */

 /*  [holds_at(diameter(Ball, Diameter2), Time), holds_at(neg(call(Diameter1=Diameter2)), Time), allDifferent([Ball, Diameter1, Time, Diameter2])] ->
       ta(Time,
          holds_at(neg(diameter(Ball, Diameter1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:759
axiom(holds_at(neg(diameter(Ball, Diameter1)), Time),
   
    [ holds_at(diameter(Ball, Diameter2), Time),
      holds_at(neg(call(Diameter1=Diameter2)), Time),
      allDifferent([Ball, Diameter1, Time, Diameter2])
    ]).

 /*  not(holds_at(diameter(Ball, Diameter2), Time)) :-
       holds_at(diameter(Ball, Diameter1), Time),
       not(equals(Diameter1, Diameter2)),
       allDifferent([Ball, Diameter1, Time, Diameter2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Diameter1, Diameter2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Diameter1=Diameter2)).
 */

 /*  [holds_at(diameter(Ball, Diameter1), Time), not(call(Diameter1=Diameter2)), allDifferent([Ball, Diameter1, Time, Diameter2])] ->
       ta(Time,
          holds_at(neg(diameter(Ball, Diameter2)), Time)).
 */

 /*  [holds_at(diameter(Ball, Diameter1), Time), holds_at(neg(call(Diameter1=Diameter2)), Time), allDifferent([Ball, Diameter1, Time, Diameter2])] ->
       ta(Time,
          holds_at(neg(diameter(Ball, Diameter2)), Time)).
 */
axiom(holds_at(neg(diameter(Ball, Diameter2)), Time),
   
    [ holds_at(diameter(Ball, Diameter1), Time),
      holds_at(neg(call(Diameter1=Diameter2)), Time),
      allDifferent([Ball, Diameter1, Time, Diameter2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:761
%; Effect axiom state that if an agent rolls some snow along
%; some other snow, the diameter of the first snow will increase:
% [agent,snow1,snow2,diameter1,diameter2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:764
% HoldsAt(Diameter(snow1,diameter1),time) &
% diameter2 = diameter1+1 ->
% Initiates(RollAlong(agent,snow1,snow2),
%           Diameter(snow1,diameter2),
%           time).

 /*  axiom_head(Time) ->
       equals(Diameter2, Diameter1+1).
 */

 /*  fix_axiom_head(Time) ->
       call(Diameter2=Diameter1+1).
 */

 /*  [holds_at(diameter(Snow1, Diameter1), Time), call(Diameter2=Diameter1+1)] ->
       ta(Time,
          initiates(rollAlong(Agent, Snow1, Snow2),
                    diameter(Snow1, Diameter2),
                    Time)).
 */

 /*  [holds_at(diameter(Snow1, Diameter1), Time), holds_at(call(Diameter2=Diameter1+1), Time)] ->
       ta(Time,
          initiates(rollAlong(Agent, Snow1, Snow2),
                    diameter(Snow1, Diameter2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:768
axiom(initiates(rollAlong(Agent, Snow1, Snow2), diameter(Snow1, Diameter2), Time),
   
    [ holds_at(diameter(Snow1, Diameter1), Time),
      holds_at(call(Diameter2=Diameter1+1), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:770
% [agent,snow1,snow2,diameter1,time]
% HoldsAt(Diameter(snow1,diameter1),time) ->
% Terminates(RollAlong(agent,snow1,snow2),
%            Diameter(snow1,diameter1),
%            time).

 /*  [holds_at(diameter(Snow1, Diameter1), Time)] ->
       ta(Time,
          terminates(rollAlong(Agent, Snow1, Snow2),
                     diameter(Snow1, Diameter1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:774
axiom(terminates(rollAlong(Agent, Snow1, Snow2), diameter(Snow1, Diameter1), Time),
    [holds_at(diameter(Snow1, Diameter1), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:776
%; A precondition axiom states that
%; for an agent to roll some snow along some other snow,
%; there must be a location such that
%; the agent is at the location,
%; the first snow is at the location, and
%; the second snow is at the location:
%;[agent,snow1,snow2,time]
%;Happens(RollAlong(agent,snow1,snow2),time) ->
%;{location}
%;HoldsAt(At(agent,location),time) &
%;HoldsAt(At(snow1,location),time) &
%;HoldsAt(At(snow2,location),time).
%; motion
%; object moves (in place).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:792
% event Move(object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:793
event(move(Move_Ret)).
==> mpred_prop(move(object),event).
==> meta_argtypes(move(object)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:794
%; Holding
%; agent is holding physobj.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:797
% fluent Holding(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:798
fluent(holding(Holding_Param,Holding_Ret)).
==> mpred_prop(holding(agent,physobj),fluent).
==> meta_argtypes(holding(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:798
%; agent holds or picks up physobj.

% event Hold(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:800
event(hold(Hold_Param,Hold_Ret)).
==> mpred_prop(hold(agent,physobj),event).
==> meta_argtypes(hold(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:800
%; agent picks up some stuff1 from stuff2.

% event HoldSome(agent,stuff,stuff)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:802
event(holdSome(HoldSome_Param,_,HoldSome_Ret)).
==> mpred_prop(holdSome(agent,stuff,stuff),event).
==> meta_argtypes(holdSome(agent,stuff,stuff)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:802
%; agent releases or lets go of physobj.

% event LetGoOf(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:804
event(letGoOf(LetGoOf_Param,LetGoOf_Ret)).
==> mpred_prop(letGoOf(agent,physobj),event).
==> meta_argtypes(letGoOf(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:805
%; An effect axiom states that if an agent holds
%; a physical object, the agent will be holding the
%; physical object:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:809
% Initiates(Hold(agent,physobj),Holding(agent,physobj),time).

 /*  [] ->
       ta(Time,
          initiates(hold(Agent, Physobj),
                    holding(Agent, Physobj),
                    Time)).
 */
axiom(initiates(hold(Agent, Physobj), holding(Agent, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:811
%; A precondition axiom states that
%; for an agent to hold a physical object,
%; there must be a location such that
%; the agent is at the location and
%; the physical object is at the location:
%;[agent,physobj,time]
%;Happens(Hold(agent,physobj),time) ->
%;{location}
%;  HoldsAt(At(agent,location),time) &
%;  HoldsAt(At(physobj,location),time).
%; An effect axiom states that if an agent
%; lets go of a physical object, the agent is no longer holding
%; the physical object:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:826
% Terminates(LetGoOf(agent,physobj),Holding(agent,physobj),time).

 /*  [] ->
       ta(Time,
          terminates(letGoOf(Agent, Physobj),
                     holding(Agent, Physobj),
                     Time)).
 */
axiom(terminates(letGoOf(Agent, Physobj), holding(Agent, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:828
%; A precondition axiom states that
%; for an agent to let go of a physical object,
%; the agent must be holding the physical object:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:832
% Happens(LetGoOf(agent,physobj),time) ->
% HoldsAt(Holding(agent,physobj),time).

 /*  allDifferent([Agent, Physobj, Time]) ->
       ( happens(letGoOf(Agent, Physobj), Time)->holds_at(holding(Agent, Physobj), Time)
       ).
 */

 /*  holds_at(holding(Agent, Physobj), Time) :-
       happens(letGoOf(Agent, Physobj), Time),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [happens(letGoOf(Agent, Physobj), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time, holds_at(holding(Agent, Physobj), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:833
axiom(holds_at(holding(Agent, Physobj), Time),
   
    [ happens(letGoOf(Agent, Physobj), Time),
      allDifferent([Agent, Physobj, Time])
    ]).

 /*  not(happens(letGoOf(Agent, Physobj), Time)) :-
       not(holds_at(holding(Agent, Physobj), Time)),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(neg(holding(Agent, Physobj)), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time, not(happens(letGoOf(Agent, Physobj), Time))).
 */
axiom(not(happens(letGoOf(Agent, Physobj), Time)),
   
    [ holds_at(neg(holding(Agent, Physobj)), Time),
      allDifferent([Agent, Physobj, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:835
%; A releases axiom states that if an agent holds
%; a physical object,
%; the physical object's location will be released
%; from inertia:
% [agent,physobj,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:840
% Releases(Hold(agent,physobj),At(physobj,location),time).

 /*  [] ->
       ta(Time,
          releases(hold(Agent, Physobj),
                   at(Physobj, Location),
                   Time)).
 */
axiom(releases(hold(Agent, Physobj), at(Physobj, Location), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:842
%; A state constraint says that if an agent is holding
%; a physical object and the agent is at a location,
%; the physical object is also at the location:
% [agent,physobj,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:846
% HoldsAt(Holding(agent,physobj),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(physobj,location),time).

 /*  allDifferent([Agent, Physobj, Time, Location]) ->
       ( holds_at(holding(Agent, Physobj), Time), holds_at(at(Agent, Location), Time)->holds_at(at(Physobj, Location), Time)
       ).
 */

 /*  holds_at(at(Physobj, Location), Time) :-
       ( holds_at(holding(Agent, Physobj), Time),
         holds_at(at(Agent, Location), Time)
       ),
       allDifferent([Agent, Physobj, Time, Location]).
 */

 /*  [holds_at(holding(Agent, Physobj), Time), holds_at(at(Agent, Location), Time), allDifferent([Agent, Physobj, Time, Location])] ->
       ta(Time, holds_at(at(Physobj, Location), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:848
axiom(holds_at(at(Physobj, Location), Time),
   
    [ holds_at(holding(Agent, Physobj), Time),
      holds_at(at(Agent, Location), Time),
      allDifferent([Agent, Physobj, Time, Location])
    ]).

 /*  not(holds_at(holding(Agent, Physobj), Time)) :-
       holds_at(at(Agent, Location), Time),
       not(holds_at(at(Physobj, Location), Time)),
       allDifferent([Agent, Physobj, Time, Location]).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(neg(at(Physobj, Location)), Time), allDifferent([Agent, Physobj, Time, Location])] ->
       ta(Time,
          holds_at(neg(holding(Agent, Physobj)), Time)).
 */
axiom(holds_at(neg(holding(Agent, Physobj)), Time),
   
    [ holds_at(at(Agent, Location), Time),
      holds_at(neg(at(Physobj, Location)), Time),
      allDifferent([Agent, Physobj, Time, Location])
    ]).

 /*  not(holds_at(at(Agent, Location), Time)) :-
       holds_at(holding(Agent, Physobj), Time),
       not(holds_at(at(Physobj, Location), Time)),
       allDifferent([Agent, Physobj, Time, Location]).
 */

 /*  [holds_at(holding(Agent, Physobj), Time), holds_at(neg(at(Physobj, Location)), Time), allDifferent([Agent, Physobj, Time, Location])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */
axiom(holds_at(neg(at(Agent, Location)), Time),
   
    [ holds_at(holding(Agent, Physobj), Time),
      holds_at(neg(at(Physobj, Location)), Time),
      allDifferent([Agent, Physobj, Time, Location])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:850
%; A releases axiom states that if an agent holds
%; a physical object,
%; the locations of the parts of the physical object
%; will be released from inertia:
% [agent,physobj1,physobj2,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:855
% PartOf(physobj1,physobj2) ->
% Releases(Hold(agent,physobj2),At(physobj1,location),time).

 /*  [partOf(Physobj1, Physobj2)] ->
       ta(Time,
          releases(hold(Agent, Physobj2),
                   at(Physobj1, Location),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:856
axiom(releases(hold(Agent, Physobj2), at(Physobj1, Location), Time),
    [partOf(Physobj1, Physobj2)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:858
%; Further, if an agent holds a physical object,
%; the locations of the physical objects of which
%; the physical object is a part
%; will be released from inertia:
% [agent,physobj1,physobj2,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:863
% PartOf(physobj1,physobj2) ->
% Releases(Hold(agent,physobj1),At(physobj2,location),time).

 /*  [partOf(Physobj1, Physobj2)] ->
       ta(Time,
          releases(hold(Agent, Physobj1),
                   at(Physobj2, Location),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:864
axiom(releases(hold(Agent, Physobj1), at(Physobj2, Location), Time),
    [partOf(Physobj1, Physobj2)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:866
%;[agent,physobj,location1,location2,time]
%;(!{object} PartOf(physobj,object)) &
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(LetGoOf(agent,physobj),At(physobj,location2),time).
% [agent,physobj,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:873
% (!{object} PartOf(physobj,object)) &
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).

 /*  [not(partOf(Physobj, Object)), holds_at(at(Agent, Location), Time)] ->
       ta(Time,
          initiates(letGoOf(Agent, Physobj),
                    at(Physobj, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:875
axiom(initiates(letGoOf(Agent, Physobj), at(Physobj, Location), Time),
   
    [ not(partOf(Physobj, Object)),
      holds_at(at(Agent, Location), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:877
%;[agent,physobj1,physobj2,location1,location2,time]
%;PartOf(physobj1,physobj2) &
%;(!{object} PartOf(physobj2,object)) &
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(LetGoOf(agent,physobj1),At(physobj2,location2),time).
% [agent,physobj1,physobj2,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:885
% PartOf(physobj1,physobj2) &
% (!{object} PartOf(physobj2,object)) &
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj1),At(physobj2,location),time).

 /*  [partOf(Physobj1, Physobj2), not(partOf(Physobj2, Object)), holds_at(at(Agent, Location), Time)] ->
       ta(Time,
          initiates(letGoOf(Agent, Physobj1),
                    at(Physobj2, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:888
axiom(initiates(letGoOf(Agent, Physobj1), at(Physobj2, Location), Time),
   
    [ partOf(Physobj1, Physobj2),
      not(partOf(Physobj2, Object)),
      holds_at(at(Agent, Location), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:890
%; An effect axiom states that if an agent is at a location
%; and lets go of a physical object, the physical object
%; will be at the location:
% [agent,physobj,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:894
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).

 /*  [holds_at(at(Agent, Location), Time)] ->
       ta(Time,
          initiates(letGoOf(Agent, Physobj),
                    at(Physobj, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:895
axiom(initiates(letGoOf(Agent, Physobj), at(Physobj, Location), Time),
    [holds_at(at(Agent, Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:897
%; An effect axiom states that if an agent picks up
%; some stuff out of some other stuff, the agent will
%; be holding the first stuff:
% [agent,stuff1,stuff2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:901
% Initiates(HoldSome(agent,stuff1,stuff2),
%           Holding(agent,stuff1),
%           time).

 /*  [] ->
       ta(Time,
          initiates(holdSome(Agent, Stuff1, Stuff2),
                    holding(Agent, Stuff1),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:903
axiom(initiates(holdSome(Agent, Stuff1, Stuff2), holding(Agent, Stuff1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:905
%; A precondition axiom states that
%; for an agent to pick up some stuff out of some other stuff,
%; the first stuff must be a part of the second stuff and
%; there must be a location such that the agent is at the location,
%; the first stuff is at the location, and the second stuff is
%; at the location:
% [agent,stuff1,stuff2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:912
% Happens(HoldSome(agent,stuff1,stuff2),time) ->
% PartOf(stuff1,stuff2) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:914
% {location}% 
%   HoldsAt(At(agent,location),time) &
%   HoldsAt(At(stuff1,location),time) &
%   HoldsAt(At(stuff2,location),time).

 /*  exists([Location],
    happens(holdSome(Agent, Stuff1, Stuff2), Time) ->
       partOf(Stuff1, Stuff2),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Stuff1, Location), Time),
       holds_at(at(Stuff2, Location), Time)).
 */

 /*  not(happens(holdSome(Agent, Stuff1, Stuff2), Time)) :-
       (   not(partOf(Stuff1, Stuff2))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Stuff1, Location), Time))
       ;   not(holds_at(at(Stuff2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(partOf(Stuff1, Stuff2))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Stuff1, Location), Time))
       ;   not(holds_at(at(Stuff2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(partOf(Stuff1, Stuff2))
       ;   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Stuff1, Location)), Time)
       ;   holds_at(neg(at(Stuff2, Location)), Time)
       ).
 */

 /*  [(not(partOf(Stuff1, Stuff2));holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Stuff1, Location)), Time);holds_at(neg(at(Stuff2, Location)), Time)), some(Location, '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))] ->
       ta(Time,
          not(happens(holdSome(Agent, Stuff1, Stuff2), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:917
axiom(not(happens(holdSome(Agent, Stuff1, Stuff2), Time)),
   
    [  (not(partOf(Stuff1, Stuff2));holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Stuff1, Location)), Time);holds_at(neg(at(Stuff2, Location)), Time)),
      some(Location,
           '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))
    ]).

 /*  partOf(Stuff1, Stuff2) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Location,
            '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time)).
 */

 /*  [happens(holdSome(Agent, Stuff1, Stuff2), Time), some(Location, '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))] ->
       ta(Time, partOf(Stuff1, Stuff2)).
 */
axiom(partOf(Stuff1, Stuff2),
   
    [ happens(holdSome(Agent, Stuff1, Stuff2), Time),
      some(Location,
           '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Location,
            '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time)).
 */

 /*  [happens(holdSome(Agent, Stuff1, Stuff2), Time), some(Location, '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(holdSome(Agent, Stuff1, Stuff2), Time),
      some(Location,
           '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))
    ]).

 /*  holds_at(at(Stuff1, Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Location,
            '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time)).
 */

 /*  [happens(holdSome(Agent, Stuff1, Stuff2), Time), some(Location, '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))] ->
       ta(Time, holds_at(at(Stuff1, Location), Time)).
 */
axiom(holds_at(at(Stuff1, Location), Time),
   
    [ happens(holdSome(Agent, Stuff1, Stuff2), Time),
      some(Location,
           '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))
    ]).

 /*  holds_at(at(Stuff2, Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Location,
            '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time)).
 */

 /*  [happens(holdSome(Agent, Stuff1, Stuff2), Time), some(Location, '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))] ->
       ta(Time, holds_at(at(Stuff2, Location), Time)).
 */
axiom(holds_at(at(Stuff2, Location), Time),
   
    [ happens(holdSome(Agent, Stuff1, Stuff2), Time),
      some(Location,
           '$kolem_Fn_204'(Agent, Stuff1, Stuff2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:919
%; A releases axiom states that if an agent picks up some
%; stuff out of some other stuff,
%; the first stuff's location will be released
%; from inertia:
% [agent,stuff1,stuff2,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:926
% Releases(HoldSome(agent,stuff1,stuff2),At(stuff1,location),time).

 /*  [] ->
       ta(Time,
          releases(holdSome(Agent, Stuff1, Stuff2),
                   at(Stuff1, Location),
                   Time)).
 */
axiom(releases(holdSome(Agent, Stuff1, Stuff2), at(Stuff1, Location), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:928
%; Inside
%; physobj1 is inside physobj2.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:931
% fluent Inside(physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:932
fluent(inside(Inside_Param,Inside_Ret)).
==> mpred_prop(inside(physobj,physobj),fluent).
==> meta_argtypes(inside(physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:932
%; agent puts physobj1 inside physobj2.

% event PutInside(agent,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:934
event(putInside(PutInside_Param,_,PutInside_Ret)).
==> mpred_prop(putInside(agent,physobj,physobj),event).
==> meta_argtypes(putInside(agent,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:934
%; agent takes physobj1 out of physobj2.

% event TakeOutOf(agent,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:936
event(takeOutOf(TakeOutOf_Param,_,TakeOutOf_Ret)).
==> mpred_prop(takeOutOf(agent,physobj,physobj),event).
==> meta_argtypes(takeOutOf(agent,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:937
%; A state constraint says that a physical object cannot
%; be inside itself:
% [physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:941
% HoldsAt(Inside(physobj1,physobj2),time) ->
% physobj1!=physobj2.

 /*  allDifferent([Physobj1, Physobj2, Time]) ->
       ( holds_at(inside(Physobj1, Physobj2), Time)->diff(Physobj1, Physobj2)
       ).
 */

 /*  not(holds_at(inside(Physobj1, Physobj2), Time)) :-
       not(diff(Physobj1, Physobj2)),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [not(diff(Physobj1, Physobj2)), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time,
          holds_at(neg(inside(Physobj1, Physobj2)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:942
axiom(holds_at(neg(inside(Physobj1, Physobj2)), Time),
   
    [ not(diff(Physobj1, Physobj2)),
      allDifferent([Physobj1, Physobj2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:944
% holdsAt(inside(physobj1,physobj2),time) -> physobj1 != physobj2.

 /*  holds_at(inside(physobj1, physobj2), time) ->
       diff(physobj1, physobj2).
 */

 /*  not(holds_at(inside(physobj1, physobj2), time)) :-
       not(diff(physobj1, physobj2)).
 */

 /*  [not(diff(physobj1, physobj2))] ->
       ta(time, holds_at(neg(inside(physobj1, physobj2)), Time)).
 */
axiom(holds_at(neg(inside(physobj1, physobj2)), Time),
    [not(diff(physobj1, physobj2))]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:947
%; A state constraint says that if a physical object is
%; inside another physical object, the second physical object
%; is not inside the first physical object:
% [physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:951
% HoldsAt(Inside(physobj1,physobj2),time) ->
% !HoldsAt(Inside(physobj2,physobj1),time).

 /*  allDifferent([Physobj1, Physobj2, Time]) ->
       ( holds_at(inside(Physobj1, Physobj2), Time)->holds_at(neg(inside(Physobj2, Physobj1)), Time)
       ).
 */

 /*  holds_at(neg(inside(Physobj2, Physobj1)), Time) :-
       holds_at(inside(Physobj1, Physobj2), Time),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [holds_at(inside(Physobj1, Physobj2), Time), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time,
          holds_at(neg(inside(Physobj2, Physobj1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:952
axiom(holds_at(neg(inside(Physobj2, Physobj1)), Time),
   
    [ holds_at(inside(Physobj1, Physobj2), Time),
      allDifferent([Physobj1, Physobj2, Time])
    ]).

 /*  not(holds_at(inside(Physobj1, Physobj2), Time)) :-
       not(holds_at(neg(inside(Physobj2, Physobj1)), Time)),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [holds_at(neg(neg(inside(Physobj2, Physobj1))), Time), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time,
          holds_at(neg(inside(Physobj1, Physobj2)), Time)).
 */
axiom(holds_at(neg(inside(Physobj1, Physobj2)), Time),
   
    [ holds_at(neg(neg(inside(Physobj2, Physobj1))), Time),
      allDifferent([Physobj1, Physobj2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:954
%; An effect axiom states that if an agent puts a physical
%; object inside another physical object, the first
%; physical object will be inside the second physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:958
% Initiates(PutInside(agent,physobj1,physobj2),
%           Inside(physobj1,physobj2),time).

 /*  [] ->
       ta(Time,
          initiates(putInside(Agent, Physobj1, Physobj2),
                    inside(Physobj1, Physobj2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:959
axiom(initiates(putInside(Agent, Physobj1, Physobj2), inside(Physobj1, Physobj2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:961
%; An effect axiom states that if an agent puts a physical
%; object inside another physical object, the agent will
%; no longer be holding the first physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:965
% Terminates(PutInside(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).

 /*  [] ->
       ta(Time,
          terminates(putInside(Agent, Physobj1, Physobj2),
                     holding(Agent, Physobj1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:966
axiom(terminates(putInside(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:968
%; A precondition axiom states that
%; for an agent to put a physical object inside another
%; physical object,
%; the agent must be holding the first physical object
%; and there must be a location such that
%; the agent is at the location and
%; the second physical object is at the location:
%;[agent,physobj1,physobj2,time]
%;Happens(PutInside(agent,physobj1,physobj2),time) ->
%;HoldsAt(Holding(agent,physobj1),time) &
%;{location}
%; HoldsAt(At(agent,location),time) &
%; HoldsAt(At(physobj2,location),time).
%; An effect axiom states that
%; if an agent takes a physical object out of another
%; physical object, the first physical object
%; will no longer be inside the second physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:987
% Terminates(TakeOutOf(agent,physobj1,physobj2),
%            Inside(physobj1,physobj2),time).

 /*  [] ->
       ta(Time,
          terminates(takeOutOf(Agent, Physobj1, Physobj2),
                     inside(Physobj1, Physobj2),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:988
axiom(terminates(takeOutOf(Agent, Physobj1, Physobj2), inside(Physobj1, Physobj2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:990
%; A precondition axiom states that
%; for an agent to take a physical object out of another
%; physical object,
%; the first physical object must be inside the second physical object
%; and there must be a location such that
%; the agent is at the location,
%; the first physical object is at the location, and
%; the second physical object is at the location:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:999
% Happens(TakeOutOf(agent,physobj1,physobj2),time) ->
% HoldsAt(Inside(physobj1,physobj2),time) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1001
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).

 /*  exists([Location],
    happens(takeOutOf(Agent, Physobj1, Physobj2), Time) ->
       holds_at(inside(Physobj1, Physobj2), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Physobj1, Location), Time),
       holds_at(at(Physobj2, Location), Time)).
 */

 /*  not(happens(takeOutOf(Agent, Physobj1, Physobj2), Time)) :-
       (   not(holds_at(inside(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj1, Location), Time))
       ;   not(holds_at(at(Physobj2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(inside(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj1, Location), Time))
       ;   not(holds_at(at(Physobj2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(inside(Physobj1, Physobj2)), Time)
       ;   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Physobj1, Location)), Time)
       ;   holds_at(neg(at(Physobj2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(inside(Physobj1, Physobj2)), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj1, Location)), Time);holds_at(neg(at(Physobj2, Location)), Time)), some(Location, '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time,
          not(happens(takeOutOf(Agent, Physobj1, Physobj2),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1004
axiom(not(happens(takeOutOf(Agent, Physobj1, Physobj2), Time)),
   
    [  (holds_at(neg(inside(Physobj1, Physobj2)), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj1, Location)), Time);holds_at(neg(at(Physobj2, Location)), Time)),
      some(Location,
           '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(inside(Physobj1, Physobj2), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOutOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(inside(Physobj1, Physobj2), Time)).
 */
axiom(holds_at(inside(Physobj1, Physobj2), Time),
   
    [ happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOutOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Physobj1, Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOutOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Physobj1, Location), Time)).
 */
axiom(holds_at(at(Physobj1, Location), Time),
   
    [ happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Physobj2, Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOutOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Physobj2, Location), Time)).
 */
axiom(holds_at(at(Physobj2, Location), Time),
   
    [ happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_205'(Agent, Physobj1, Physobj2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1006
%; A releases axiom states that if an agent puts a physical
%; object inside another physical object,
%; the first physical object's location will be released
%; from inertia:
% [agent,physobj1,physobj2,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1011
% Releases(PutInside(agent,physobj1,physobj2),
%          At(physobj1,location),time).

 /*  [] ->
       ta(Time,
          releases(putInside(Agent, Physobj1, Physobj2),
                   at(Physobj1, Location),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1012
axiom(releases(putInside(Agent, Physobj1, Physobj2), at(Physobj1, Location), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1014
%; A state constraint says that if a physical object is inside
%; another physical object and the second physical object is
%; at a location, the first physical object is also at the location:
% [physobj1,physobj2,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1018
% HoldsAt(Inside(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).

 /*  allDifferent([Physobj1, Physobj2, Time, Location]) ->
       ( holds_at(inside(Physobj1, Physobj2), Time), holds_at(at(Physobj2, Location), Time)->holds_at(at(Physobj1, Location), Time)
       ).
 */

 /*  holds_at(at(Physobj1, Location), Time) :-
       ( holds_at(inside(Physobj1, Physobj2), Time),
         holds_at(at(Physobj2, Location), Time)
       ),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(inside(Physobj1, Physobj2), Time), holds_at(at(Physobj2, Location), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time, holds_at(at(Physobj1, Location), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1020
axiom(holds_at(at(Physobj1, Location), Time),
   
    [ holds_at(inside(Physobj1, Physobj2), Time),
      holds_at(at(Physobj2, Location), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).

 /*  not(holds_at(inside(Physobj1, Physobj2), Time)) :-
       holds_at(at(Physobj2, Location), Time),
       not(holds_at(at(Physobj1, Location), Time)),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(at(Physobj2, Location), Time), holds_at(neg(at(Physobj1, Location)), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time,
          holds_at(neg(inside(Physobj1, Physobj2)), Time)).
 */
axiom(holds_at(neg(inside(Physobj1, Physobj2)), Time),
   
    [ holds_at(at(Physobj2, Location), Time),
      holds_at(neg(at(Physobj1, Location)), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).

 /*  not(holds_at(at(Physobj2, Location), Time)) :-
       holds_at(inside(Physobj1, Physobj2), Time),
       not(holds_at(at(Physobj1, Location), Time)),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(inside(Physobj1, Physobj2), Time), holds_at(neg(at(Physobj1, Location)), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time, holds_at(neg(at(Physobj2, Location)), Time)).
 */
axiom(holds_at(neg(at(Physobj2, Location)), Time),
   
    [ holds_at(inside(Physobj1, Physobj2), Time),
      holds_at(neg(at(Physobj1, Location)), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1022
%; An effect axiom states that if an agent takes a physical
%; object out of another physical object,
%; the agent will be holding the first physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1026
% Initiates(TakeOutOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),
%           time).

 /*  [] ->
       ta(Time,
          initiates(takeOutOf(Agent, Physobj1, Physobj2),
                    holding(Agent, Physobj1),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1028
axiom(initiates(takeOutOf(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1030
%; On
%; physobj1 is on physobj2.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1033
% fluent On(physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1034
fluent(on(On_Param,On_Ret)).
==> mpred_prop(on(physobj,physobj),fluent).
==> meta_argtypes(on(physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1035
%; agent places physobj1 on physobj2.

% event PlaceOn(agent,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1037
event(placeOn(PlaceOn_Param,_,PlaceOn_Ret)).
==> mpred_prop(placeOn(agent,physobj,physobj),event).
==> meta_argtypes(placeOn(agent,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1037
%; agent takes physobj1 off of physobj2.

% event TakeOffOf(agent,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1039
event(takeOffOf(TakeOffOf_Param,_,TakeOffOf_Ret)).
==> mpred_prop(takeOffOf(agent,physobj,physobj),event).
==> meta_argtypes(takeOffOf(agent,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1040
%; A state constraint says that a physical object cannot
%; be on itself:
% [physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1043
% HoldsAt(On(physobj1,physobj2),time) ->
% physobj1!=physobj2.

 /*  allDifferent([Physobj1, Physobj2, Time]) ->
       ( holds_at(on(Physobj1, Physobj2), Time)->diff(Physobj1, Physobj2)
       ).
 */

 /*  not(holds_at(on(Physobj1, Physobj2), Time)) :-
       not(diff(Physobj1, Physobj2)),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [not(diff(Physobj1, Physobj2)), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time, holds_at(neg(on(Physobj1, Physobj2)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1044
axiom(holds_at(neg(on(Physobj1, Physobj2)), Time),
   
    [ not(diff(Physobj1, Physobj2)),
      allDifferent([Physobj1, Physobj2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1046
%; A state constraint says that if a physical object is
%; on another physical object, the second physical object
%; is not on the first physical object:
% [physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1050
% HoldsAt(On(physobj1,physobj2),time) ->
% !HoldsAt(On(physobj2,physobj1),time).

 /*  allDifferent([Physobj1, Physobj2, Time]) ->
       ( holds_at(on(Physobj1, Physobj2), Time)->holds_at(neg(on(Physobj2, Physobj1)), Time)
       ).
 */

 /*  holds_at(neg(on(Physobj2, Physobj1)), Time) :-
       holds_at(on(Physobj1, Physobj2), Time),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [holds_at(on(Physobj1, Physobj2), Time), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time, holds_at(neg(on(Physobj2, Physobj1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1051
axiom(holds_at(neg(on(Physobj2, Physobj1)), Time),
   
    [ holds_at(on(Physobj1, Physobj2), Time),
      allDifferent([Physobj1, Physobj2, Time])
    ]).

 /*  not(holds_at(on(Physobj1, Physobj2), Time)) :-
       not(holds_at(neg(on(Physobj2, Physobj1)), Time)),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [holds_at(neg(neg(on(Physobj2, Physobj1))), Time), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time, holds_at(neg(on(Physobj1, Physobj2)), Time)).
 */
axiom(holds_at(neg(on(Physobj1, Physobj2)), Time),
   
    [ holds_at(neg(neg(on(Physobj2, Physobj1))), Time),
      allDifferent([Physobj1, Physobj2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1053
%; An effect axiom states that if an agent places a physical
%; object on another physical object, the first
%; physical object will be on the second physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1057
% Initiates(PlaceOn(agent,physobj1,physobj2),
%           On(physobj1,physobj2),time).

 /*  [] ->
       ta(Time,
          initiates(placeOn(Agent, Physobj1, Physobj2),
                    on(Physobj1, Physobj2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1058
axiom(initiates(placeOn(Agent, Physobj1, Physobj2), on(Physobj1, Physobj2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1060
%; An effect axiom states that if an agent places a physical
%; object on another physical object, the agent will
%; no longer be holding the first physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1064
% Terminates(PlaceOn(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).

 /*  [] ->
       ta(Time,
          terminates(placeOn(Agent, Physobj1, Physobj2),
                     holding(Agent, Physobj1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1065
axiom(terminates(placeOn(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1067
%; A precondition axiom states that
%; for an agent to place a physical object on another
%; physical object,
%; the agent must be holding the first physical object
%; and there must be a location such that
%; the agent is at the location and
%; the second physical object is at the location:
%;[agent,physobj1,physobj2,time]
%;Happens(PlaceOn(agent,physobj1,physobj2),time) ->
%;HoldsAt(Holding(agent,physobj1),time) &
%;{location}
%; HoldsAt(At(agent,location),time) &
%; HoldsAt(At(physobj2,location),time).
%; An effect axiom states that
%; if an agent takes a physical object off of another
%; physical object, the first physical object
%; will no longer be on the second physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1086
% Terminates(TakeOffOf(agent,physobj1,physobj2),
%            On(physobj1,physobj2),time).

 /*  [] ->
       ta(Time,
          terminates(takeOffOf(Agent, Physobj1, Physobj2),
                     on(Physobj1, Physobj2),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1087
axiom(terminates(takeOffOf(Agent, Physobj1, Physobj2), on(Physobj1, Physobj2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1089
%; An effect axiom states that if an agent takes a physical
%; object off of another physical object,
%; the agent will be holding the first physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1093
% Initiates(TakeOffOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),time).

 /*  [] ->
       ta(Time,
          initiates(takeOffOf(Agent, Physobj1, Physobj2),
                    holding(Agent, Physobj1),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1094
axiom(initiates(takeOffOf(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1096
%; A precondition axiom states that
%; for an agent to take a physical object off of another
%; physical object,
%; the first physical object must be on the second physical object
%; and there must be a location such that
%; the agent is at the location and
%; the first physical object is at the location:
%; the second physical object is at the location:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1105
% Happens(TakeOffOf(agent,physobj1,physobj2),time) ->
% HoldsAt(On(physobj1,physobj2),time) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1107
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).

 /*  exists([Location],
    happens(takeOffOf(Agent, Physobj1, Physobj2), Time) ->
       holds_at(on(Physobj1, Physobj2), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Physobj1, Location), Time),
       holds_at(at(Physobj2, Location), Time)).
 */

 /*  not(happens(takeOffOf(Agent, Physobj1, Physobj2), Time)) :-
       (   not(holds_at(on(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj1, Location), Time))
       ;   not(holds_at(at(Physobj2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(on(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj1, Location), Time))
       ;   not(holds_at(at(Physobj2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(on(Physobj1, Physobj2)), Time)
       ;   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Physobj1, Location)), Time)
       ;   holds_at(neg(at(Physobj2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(on(Physobj1, Physobj2)), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj1, Location)), Time);holds_at(neg(at(Physobj2, Location)), Time)), some(Location, '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time,
          not(happens(takeOffOf(Agent, Physobj1, Physobj2),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1110
axiom(not(happens(takeOffOf(Agent, Physobj1, Physobj2), Time)),
   
    [  (holds_at(neg(on(Physobj1, Physobj2)), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj1, Location)), Time);holds_at(neg(at(Physobj2, Location)), Time)),
      some(Location,
           '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(on(Physobj1, Physobj2), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOffOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(on(Physobj1, Physobj2), Time)).
 */
axiom(holds_at(on(Physobj1, Physobj2), Time),
   
    [ happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOffOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Physobj1, Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOffOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Physobj1, Location), Time)).
 */
axiom(holds_at(at(Physobj1, Location), Time),
   
    [ happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Physobj2, Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOffOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Physobj2, Location), Time)).
 */
axiom(holds_at(at(Physobj2, Location), Time),
   
    [ happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_206'(Agent, Physobj1, Physobj2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1112
%; A releases axiom states that if an agent places a physical
%; object on another physical object,
%; the first physical object's location will be released
%; from inertia:
% [agent,physobj1,physobj2,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1117
% Releases(PlaceOn(agent,physobj1,physobj2),
%          At(physobj1,location),
%          time).

 /*  [] ->
       ta(Time,
          releases(placeOn(Agent, Physobj1, Physobj2),
                   at(Physobj1, Location),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1119
axiom(releases(placeOn(Agent, Physobj1, Physobj2), at(Physobj1, Location), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1121
%; A state constraint says that if a physical object is on
%; another physical object and the second physical object is
%; at a location, the first physical object is also at the location:
% [physobj1,physobj2,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1125
% HoldsAt(On(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).

 /*  allDifferent([Physobj1, Physobj2, Time, Location]) ->
       ( holds_at(on(Physobj1, Physobj2), Time), holds_at(at(Physobj2, Location), Time)->holds_at(at(Physobj1, Location), Time)
       ).
 */

 /*  holds_at(at(Physobj1, Location), Time) :-
       ( holds_at(on(Physobj1, Physobj2), Time),
         holds_at(at(Physobj2, Location), Time)
       ),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(on(Physobj1, Physobj2), Time), holds_at(at(Physobj2, Location), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time, holds_at(at(Physobj1, Location), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1127
axiom(holds_at(at(Physobj1, Location), Time),
   
    [ holds_at(on(Physobj1, Physobj2), Time),
      holds_at(at(Physobj2, Location), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).

 /*  not(holds_at(on(Physobj1, Physobj2), Time)) :-
       holds_at(at(Physobj2, Location), Time),
       not(holds_at(at(Physobj1, Location), Time)),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(at(Physobj2, Location), Time), holds_at(neg(at(Physobj1, Location)), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time, holds_at(neg(on(Physobj1, Physobj2)), Time)).
 */
axiom(holds_at(neg(on(Physobj1, Physobj2)), Time),
   
    [ holds_at(at(Physobj2, Location), Time),
      holds_at(neg(at(Physobj1, Location)), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).

 /*  not(holds_at(at(Physobj2, Location), Time)) :-
       holds_at(on(Physobj1, Physobj2), Time),
       not(holds_at(at(Physobj1, Location), Time)),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(on(Physobj1, Physobj2), Time), holds_at(neg(at(Physobj1, Location)), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time, holds_at(neg(at(Physobj2, Location)), Time)).
 */
axiom(holds_at(neg(at(Physobj2, Location)), Time),
   
    [ holds_at(on(Physobj1, Physobj2), Time),
      holds_at(neg(at(Physobj1, Location)), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1129
% fluent Near(agent,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1130
fluent(near(Near_Param,Near_Ret)).
==> mpred_prop(near(agent,object),fluent).
==> meta_argtypes(near(agent,object)).

% event WalkFromTo(agent,object,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1131
event(walkFromTo(WalkFromTo_Param,_,WalkFromTo_Ret)).
==> mpred_prop(walkFromTo(agent,object,object),event).
==> meta_argtypes(walkFromTo(agent,object,object)).

% event WalkFrom(agent,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1132
event(walkFrom(WalkFrom_Param,WalkFrom_Ret)).
==> mpred_prop(walkFrom(agent,object),event).
==> meta_argtypes(walkFrom(agent,object)).

% event RunFromTo(agent,object,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1133
event(runFromTo(RunFromTo_Param,_,RunFromTo_Ret)).
==> mpred_prop(runFromTo(agent,object,object),event).
==> meta_argtypes(runFromTo(agent,object,object)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1134
% [agent,object1,object2,time]
% Initiates(WalkFromTo(agent,object1,object2),
%           Near(agent,object2),
%           time).

 /*  [] ->
       ta(Time,
          initiates(walkFromTo(Agent, Object1, Object2),
                    near(Agent, Object2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1137
axiom(initiates(walkFromTo(Agent, Object1, Object2), near(Agent, Object2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1139
% [agent,object1,object2,time]
% Terminates(WalkFromTo(agent,object1,object2),
%            Near(agent,object1),
%            time).

 /*  [] ->
       ta(Time,
          terminates(walkFromTo(Agent, Object1, Object2),
                     near(Agent, Object1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1142
axiom(terminates(walkFromTo(Agent, Object1, Object2), near(Agent, Object1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1144
% [agent,object1,object2,time]
% Happens(WalkFromTo(agent,object1,object2),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1146
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object1,location),time) &
% HoldsAt(At(object2,location),time).

 /*  exists([Location],
    happens(walkFromTo(Agent, Object1, Object2), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Object1, Location), Time),
       holds_at(at(Object2, Location), Time)).
 */

 /*  not(happens(walkFromTo(Agent, Object1, Object2), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Object1, Location), Time))
       ;   not(holds_at(at(Object2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_207'(Agent, Object1, Object2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Object1, Location), Time))
       ;   not(holds_at(at(Object2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Object1, Location)), Time)
       ;   holds_at(neg(at(Object2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Object1, Location)), Time);holds_at(neg(at(Object2, Location)), Time)), some(Location, '$kolem_Fn_207'(Agent, Object1, Object2, Time))] ->
       ta(Time,
          not(happens(walkFromTo(Agent, Object1, Object2),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1149
axiom(not(happens(walkFromTo(Agent, Object1, Object2), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Object1, Location)), Time);holds_at(neg(at(Object2, Location)), Time)),
      some(Location,
           '$kolem_Fn_207'(Agent, Object1, Object2, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Location,
            '$kolem_Fn_207'(Agent, Object1, Object2, Time)).
 */

 /*  [happens(walkFromTo(Agent, Object1, Object2), Time), some(Location, '$kolem_Fn_207'(Agent, Object1, Object2, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(walkFromTo(Agent, Object1, Object2), Time),
      some(Location,
           '$kolem_Fn_207'(Agent, Object1, Object2, Time))
    ]).

 /*  holds_at(at(Object1, Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Location,
            '$kolem_Fn_207'(Agent, Object1, Object2, Time)).
 */

 /*  [happens(walkFromTo(Agent, Object1, Object2), Time), some(Location, '$kolem_Fn_207'(Agent, Object1, Object2, Time))] ->
       ta(Time, holds_at(at(Object1, Location), Time)).
 */
axiom(holds_at(at(Object1, Location), Time),
   
    [ happens(walkFromTo(Agent, Object1, Object2), Time),
      some(Location,
           '$kolem_Fn_207'(Agent, Object1, Object2, Time))
    ]).

 /*  holds_at(at(Object2, Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Location,
            '$kolem_Fn_207'(Agent, Object1, Object2, Time)).
 */

 /*  [happens(walkFromTo(Agent, Object1, Object2), Time), some(Location, '$kolem_Fn_207'(Agent, Object1, Object2, Time))] ->
       ta(Time, holds_at(at(Object2, Location), Time)).
 */
axiom(holds_at(at(Object2, Location), Time),
   
    [ happens(walkFromTo(Agent, Object1, Object2), Time),
      some(Location,
           '$kolem_Fn_207'(Agent, Object1, Object2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1151
% [agent,object1,object2,time]
% Initiates(RunFromTo(agent,object1,object2),
%           Near(agent,object2),
%           time).

 /*  [] ->
       ta(Time,
          initiates(runFromTo(Agent, Object1, Object2),
                    near(Agent, Object2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1154
axiom(initiates(runFromTo(Agent, Object1, Object2), near(Agent, Object2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1156
% [agent,object1,object2,time]
% Terminates(RunFromTo(agent,object1,object2),
%            Near(agent,object1),
%            time).

 /*  [] ->
       ta(Time,
          terminates(runFromTo(Agent, Object1, Object2),
                     near(Agent, Object1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1159
axiom(terminates(runFromTo(Agent, Object1, Object2), near(Agent, Object1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1161
% [agent,object1,object2,time]
% Happens(RunFromTo(agent,object1,object2),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1163
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object1,location),time) &
% HoldsAt(At(object2,location),time).

 /*  exists([Location],
    happens(runFromTo(Agent, Object1, Object2), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Object1, Location), Time),
       holds_at(at(Object2, Location), Time)).
 */

 /*  not(happens(runFromTo(Agent, Object1, Object2), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Object1, Location), Time))
       ;   not(holds_at(at(Object2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_208'(Agent, Object1, Object2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Object1, Location), Time))
       ;   not(holds_at(at(Object2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Object1, Location)), Time)
       ;   holds_at(neg(at(Object2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Object1, Location)), Time);holds_at(neg(at(Object2, Location)), Time)), some(Location, '$kolem_Fn_208'(Agent, Object1, Object2, Time))] ->
       ta(Time,
          not(happens(runFromTo(Agent, Object1, Object2),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1166
axiom(not(happens(runFromTo(Agent, Object1, Object2), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Object1, Location)), Time);holds_at(neg(at(Object2, Location)), Time)),
      some(Location,
           '$kolem_Fn_208'(Agent, Object1, Object2, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Location,
            '$kolem_Fn_208'(Agent, Object1, Object2, Time)).
 */

 /*  [happens(runFromTo(Agent, Object1, Object2), Time), some(Location, '$kolem_Fn_208'(Agent, Object1, Object2, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(runFromTo(Agent, Object1, Object2), Time),
      some(Location,
           '$kolem_Fn_208'(Agent, Object1, Object2, Time))
    ]).

 /*  holds_at(at(Object1, Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Location,
            '$kolem_Fn_208'(Agent, Object1, Object2, Time)).
 */

 /*  [happens(runFromTo(Agent, Object1, Object2), Time), some(Location, '$kolem_Fn_208'(Agent, Object1, Object2, Time))] ->
       ta(Time, holds_at(at(Object1, Location), Time)).
 */
axiom(holds_at(at(Object1, Location), Time),
   
    [ happens(runFromTo(Agent, Object1, Object2), Time),
      some(Location,
           '$kolem_Fn_208'(Agent, Object1, Object2, Time))
    ]).

 /*  holds_at(at(Object2, Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Location,
            '$kolem_Fn_208'(Agent, Object1, Object2, Time)).
 */

 /*  [happens(runFromTo(Agent, Object1, Object2), Time), some(Location, '$kolem_Fn_208'(Agent, Object1, Object2, Time))] ->
       ta(Time, holds_at(at(Object2, Location), Time)).
 */
axiom(holds_at(at(Object2, Location), Time),
   
    [ happens(runFromTo(Agent, Object1, Object2), Time),
      some(Location,
           '$kolem_Fn_208'(Agent, Object1, Object2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1168
% [agent,object,time]
% Terminates(WalkFrom(agent,object),
%            Near(agent,object),
%            time).

 /*  [] ->
       ta(Time,
          terminates(walkFrom(Agent, Object),
                     near(Agent, Object),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1171
axiom(terminates(walkFrom(Agent, Object), near(Agent, Object), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1173
% [agent,object,location,door,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time) &
% Side1(door)=location &
% Happens(WalkThroughDoor12(agent,door),time) ->
% Happens(WalkFrom(agent,object),time).

 /*  allDifferent([Agent, Object, Time, Location, Door]) ->
       ( holds_at(near(Agent, Object), Time), holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), side1(Door)=Location, happens(walkThroughDoor12(Agent, Door), Time)->happens(walkFrom(Agent, Object), Time)
       ).
 */

 /*  happens(walkFrom(Agent, Object), Time) :-
       ( holds_at(near(Agent, Object), Time),
         holds_at(at(Agent, Location), Time),
         holds_at(at(Object, Location), Time),
         equals(side1(Door), Location),
         happens(walkThroughDoor12(Agent, Door), Time)
       ),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [holds_at(near(Agent, Object), Time), holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), call(side1(Door)=Location), happens(walkThroughDoor12(Agent, Door), Time), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, happens(walkFrom(Agent, Object), Time)).
 */

 /*  [holds_at(near(Agent, Object), Time), holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), holds_at(call(side1(Door)=Location), Time), happens(walkThroughDoor12(Agent, Door), Time), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, happens(walkFrom(Agent, Object), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1179
axiom(happens(walkFrom(Agent, Object), Time),
   
    [ holds_at(near(Agent, Object), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(at(Object, Location), Time),
      holds_at(call(side1(Door)=Location), Time),
      happens(walkThroughDoor12(Agent, Door), Time),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(near(Agent, Object), Time)) :-
       ( holds_at(at(Agent, Location), Time),
         holds_at(at(Object, Location), Time),
         equals(side1(Door), Location),
         happens(walkThroughDoor12(Agent, Door), Time)
       ),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), call(side1(Door)=Location), happens(walkThroughDoor12(Agent, Door), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(near(Agent, Object)), Time)).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), holds_at(call(side1(Door)=Location), Time), happens(walkThroughDoor12(Agent, Door), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(near(Agent, Object)), Time)).
 */
axiom(holds_at(neg(near(Agent, Object)), Time),
   
    [ holds_at(at(Agent, Location), Time),
      holds_at(at(Object, Location), Time),
      holds_at(call(side1(Door)=Location), Time),
      happens(walkThroughDoor12(Agent, Door), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(at(Agent, Location), Time)) :-
       ( holds_at(at(Object, Location), Time),
         equals(side1(Door), Location),
         happens(walkThroughDoor12(Agent, Door), Time)
       ),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [holds_at(at(Object, Location), Time), call(side1(Door)=Location), happens(walkThroughDoor12(Agent, Door), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */

 /*  [holds_at(at(Object, Location), Time), holds_at(call(side1(Door)=Location), Time), happens(walkThroughDoor12(Agent, Door), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */
axiom(holds_at(neg(at(Agent, Location)), Time),
   
    [ holds_at(at(Object, Location), Time),
      holds_at(call(side1(Door)=Location), Time),
      happens(walkThroughDoor12(Agent, Door), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(at(Object, Location), Time)) :-
       ( equals(side1(Door), Location),
         happens(walkThroughDoor12(Agent, Door), Time)
       ),
       holds_at(at(Agent, Location), Time),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [call(side1(Door)=Location), happens(walkThroughDoor12(Agent, Door), Time), holds_at(at(Agent, Location), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */

 /*  [holds_at(call(side1(Door)=Location), Time), happens(walkThroughDoor12(Agent, Door), Time), holds_at(at(Agent, Location), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */
axiom(holds_at(neg(at(Object, Location)), Time),
   
    [ holds_at(call(side1(Door)=Location), Time),
      happens(walkThroughDoor12(Agent, Door), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(happens(walkThroughDoor12(Agent, Door), Time)) :-
       equals(side1(Door), Location),
       holds_at(at(Object, Location), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [call(side1(Door)=Location), holds_at(at(Object, Location), Time), holds_at(at(Agent, Location), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time,
          not(happens(walkThroughDoor12(Agent, Door), Time))).
 */

 /*  [holds_at(call(side1(Door)=Location), Time), holds_at(at(Object, Location), Time), holds_at(at(Agent, Location), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time,
          not(happens(walkThroughDoor12(Agent, Door), Time))).
 */
axiom(not(happens(walkThroughDoor12(Agent, Door), Time)),
   
    [ holds_at(call(side1(Door)=Location), Time),
      holds_at(at(Object, Location), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1181
% [agent,object,location,door,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time) &
% Side2(door)=location &
% Happens(WalkThroughDoor21(agent,door),time) ->
% Happens(WalkFrom(agent,object),time).

 /*  allDifferent([Agent, Object, Time, Location, Door]) ->
       ( holds_at(near(Agent, Object), Time), holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), side2(Door)=Location, happens(walkThroughDoor21(Agent, Door), Time)->happens(walkFrom(Agent, Object), Time)
       ).
 */

 /*  happens(walkFrom(Agent, Object), Time) :-
       ( holds_at(near(Agent, Object), Time),
         holds_at(at(Agent, Location), Time),
         holds_at(at(Object, Location), Time),
         equals(side2(Door), Location),
         happens(walkThroughDoor21(Agent, Door), Time)
       ),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [holds_at(near(Agent, Object), Time), holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), call(side2(Door)=Location), happens(walkThroughDoor21(Agent, Door), Time), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, happens(walkFrom(Agent, Object), Time)).
 */

 /*  [holds_at(near(Agent, Object), Time), holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), holds_at(call(side2(Door)=Location), Time), happens(walkThroughDoor21(Agent, Door), Time), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, happens(walkFrom(Agent, Object), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1187
axiom(happens(walkFrom(Agent, Object), Time),
   
    [ holds_at(near(Agent, Object), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(at(Object, Location), Time),
      holds_at(call(side2(Door)=Location), Time),
      happens(walkThroughDoor21(Agent, Door), Time),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(near(Agent, Object), Time)) :-
       ( holds_at(at(Agent, Location), Time),
         holds_at(at(Object, Location), Time),
         equals(side2(Door), Location),
         happens(walkThroughDoor21(Agent, Door), Time)
       ),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), call(side2(Door)=Location), happens(walkThroughDoor21(Agent, Door), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(near(Agent, Object)), Time)).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time), holds_at(call(side2(Door)=Location), Time), happens(walkThroughDoor21(Agent, Door), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(near(Agent, Object)), Time)).
 */
axiom(holds_at(neg(near(Agent, Object)), Time),
   
    [ holds_at(at(Agent, Location), Time),
      holds_at(at(Object, Location), Time),
      holds_at(call(side2(Door)=Location), Time),
      happens(walkThroughDoor21(Agent, Door), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(at(Agent, Location), Time)) :-
       ( holds_at(at(Object, Location), Time),
         equals(side2(Door), Location),
         happens(walkThroughDoor21(Agent, Door), Time)
       ),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [holds_at(at(Object, Location), Time), call(side2(Door)=Location), happens(walkThroughDoor21(Agent, Door), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */

 /*  [holds_at(at(Object, Location), Time), holds_at(call(side2(Door)=Location), Time), happens(walkThroughDoor21(Agent, Door), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */
axiom(holds_at(neg(at(Agent, Location)), Time),
   
    [ holds_at(at(Object, Location), Time),
      holds_at(call(side2(Door)=Location), Time),
      happens(walkThroughDoor21(Agent, Door), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(at(Object, Location), Time)) :-
       ( equals(side2(Door), Location),
         happens(walkThroughDoor21(Agent, Door), Time)
       ),
       holds_at(at(Agent, Location), Time),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [call(side2(Door)=Location), happens(walkThroughDoor21(Agent, Door), Time), holds_at(at(Agent, Location), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */

 /*  [holds_at(call(side2(Door)=Location), Time), happens(walkThroughDoor21(Agent, Door), Time), holds_at(at(Agent, Location), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */
axiom(holds_at(neg(at(Object, Location)), Time),
   
    [ holds_at(call(side2(Door)=Location), Time),
      happens(walkThroughDoor21(Agent, Door), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(happens(walkThroughDoor21(Agent, Door), Time)) :-
       equals(side2(Door), Location),
       holds_at(at(Object, Location), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Location,
                      Door
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [call(side2(Door)=Location), holds_at(at(Object, Location), Time), holds_at(at(Agent, Location), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time,
          not(happens(walkThroughDoor21(Agent, Door), Time))).
 */

 /*  [holds_at(call(side2(Door)=Location), Time), holds_at(at(Object, Location), Time), holds_at(at(Agent, Location), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Location, Door])] ->
       ta(Time,
          not(happens(walkThroughDoor21(Agent, Door), Time))).
 */
axiom(not(happens(walkThroughDoor21(Agent, Door), Time)),
   
    [ holds_at(call(side2(Door)=Location), Time),
      holds_at(at(Object, Location), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Location,
                     Door
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1189
% [agent,object,room,staircase,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(object,room),time) &
% Side1(staircase)=room &
% Happens(WalkUpStaircase(agent,staircase),time) ->
% Happens(WalkFrom(agent,object),time).

 /*  allDifferent([Agent, Object, Time, Room, Staircase]) ->
       ( holds_at(near(Agent, Object), Time), holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), side1(Staircase)=Room, happens(walkUpStaircase(Agent, Staircase), Time)->happens(walkFrom(Agent, Object), Time)
       ).
 */

 /*  happens(walkFrom(Agent, Object), Time) :-
       ( holds_at(near(Agent, Object), Time),
         holds_at(at(Agent, Room), Time),
         holds_at(at(Object, Room), Time),
         equals(side1(Staircase), Room),
         happens(walkUpStaircase(Agent, Staircase), Time)
       ),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Staircase)=Room).
 */

 /*  [holds_at(near(Agent, Object), Time), holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), call(side1(Staircase)=Room), happens(walkUpStaircase(Agent, Staircase), Time), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, happens(walkFrom(Agent, Object), Time)).
 */

 /*  [holds_at(near(Agent, Object), Time), holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), holds_at(call(side1(Staircase)=Room), Time), happens(walkUpStaircase(Agent, Staircase), Time), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, happens(walkFrom(Agent, Object), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1195
axiom(happens(walkFrom(Agent, Object), Time),
   
    [ holds_at(near(Agent, Object), Time),
      holds_at(at(Agent, Room), Time),
      holds_at(at(Object, Room), Time),
      holds_at(call(side1(Staircase)=Room), Time),
      happens(walkUpStaircase(Agent, Staircase), Time),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).

 /*  not(holds_at(near(Agent, Object), Time)) :-
       ( holds_at(at(Agent, Room), Time),
         holds_at(at(Object, Room), Time),
         equals(side1(Staircase), Room),
         happens(walkUpStaircase(Agent, Staircase), Time)
       ),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Staircase)=Room).
 */

 /*  [holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), call(side1(Staircase)=Room), happens(walkUpStaircase(Agent, Staircase), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(near(Agent, Object)), Time)).
 */

 /*  [holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), holds_at(call(side1(Staircase)=Room), Time), happens(walkUpStaircase(Agent, Staircase), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(near(Agent, Object)), Time)).
 */
axiom(holds_at(neg(near(Agent, Object)), Time),
   
    [ holds_at(at(Agent, Room), Time),
      holds_at(at(Object, Room), Time),
      holds_at(call(side1(Staircase)=Room), Time),
      happens(walkUpStaircase(Agent, Staircase), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).

 /*  not(holds_at(at(Agent, Room), Time)) :-
       ( holds_at(at(Object, Room), Time),
         equals(side1(Staircase), Room),
         happens(walkUpStaircase(Agent, Staircase), Time)
       ),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Staircase)=Room).
 */

 /*  [holds_at(at(Object, Room), Time), call(side1(Staircase)=Room), happens(walkUpStaircase(Agent, Staircase), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(at(Agent, Room)), Time)).
 */

 /*  [holds_at(at(Object, Room), Time), holds_at(call(side1(Staircase)=Room), Time), happens(walkUpStaircase(Agent, Staircase), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(at(Agent, Room)), Time)).
 */
axiom(holds_at(neg(at(Agent, Room)), Time),
   
    [ holds_at(at(Object, Room), Time),
      holds_at(call(side1(Staircase)=Room), Time),
      happens(walkUpStaircase(Agent, Staircase), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).

 /*  not(holds_at(at(Object, Room), Time)) :-
       ( equals(side1(Staircase), Room),
         happens(walkUpStaircase(Agent, Staircase), Time)
       ),
       holds_at(at(Agent, Room), Time),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Staircase)=Room).
 */

 /*  [call(side1(Staircase)=Room), happens(walkUpStaircase(Agent, Staircase), Time), holds_at(at(Agent, Room), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(at(Object, Room)), Time)).
 */

 /*  [holds_at(call(side1(Staircase)=Room), Time), happens(walkUpStaircase(Agent, Staircase), Time), holds_at(at(Agent, Room), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(at(Object, Room)), Time)).
 */
axiom(holds_at(neg(at(Object, Room)), Time),
   
    [ holds_at(call(side1(Staircase)=Room), Time),
      happens(walkUpStaircase(Agent, Staircase), Time),
      holds_at(at(Agent, Room), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).

 /*  not(happens(walkUpStaircase(Agent, Staircase), Time)) :-
       equals(side1(Staircase), Room),
       holds_at(at(Object, Room), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Staircase)=Room).
 */

 /*  [call(side1(Staircase)=Room), holds_at(at(Object, Room), Time), holds_at(at(Agent, Room), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time,
          not(happens(walkUpStaircase(Agent, Staircase), Time))).
 */

 /*  [holds_at(call(side1(Staircase)=Room), Time), holds_at(at(Object, Room), Time), holds_at(at(Agent, Room), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time,
          not(happens(walkUpStaircase(Agent, Staircase), Time))).
 */
axiom(not(happens(walkUpStaircase(Agent, Staircase), Time)),
   
    [ holds_at(call(side1(Staircase)=Room), Time),
      holds_at(at(Object, Room), Time),
      holds_at(at(Agent, Room), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1197
% [agent,object,room,staircase,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(object,room),time) &
% Side2(staircase)=room &
% Happens(WalkDownStaircase(agent,staircase),time) ->
% Happens(WalkFrom(agent,object),time).

 /*  allDifferent([Agent, Object, Time, Room, Staircase]) ->
       ( holds_at(near(Agent, Object), Time), holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), side2(Staircase)=Room, happens(walkDownStaircase(Agent, Staircase), Time)->happens(walkFrom(Agent, Object), Time)
       ).
 */

 /*  happens(walkFrom(Agent, Object), Time) :-
       ( holds_at(near(Agent, Object), Time),
         holds_at(at(Agent, Room), Time),
         holds_at(at(Object, Room), Time),
         equals(side2(Staircase), Room),
         happens(walkDownStaircase(Agent, Staircase), Time)
       ),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Staircase)=Room).
 */

 /*  [holds_at(near(Agent, Object), Time), holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), call(side2(Staircase)=Room), happens(walkDownStaircase(Agent, Staircase), Time), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, happens(walkFrom(Agent, Object), Time)).
 */

 /*  [holds_at(near(Agent, Object), Time), holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), holds_at(call(side2(Staircase)=Room), Time), happens(walkDownStaircase(Agent, Staircase), Time), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, happens(walkFrom(Agent, Object), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1203
axiom(happens(walkFrom(Agent, Object), Time),
   
    [ holds_at(near(Agent, Object), Time),
      holds_at(at(Agent, Room), Time),
      holds_at(at(Object, Room), Time),
      holds_at(call(side2(Staircase)=Room), Time),
      happens(walkDownStaircase(Agent, Staircase), Time),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).

 /*  not(holds_at(near(Agent, Object), Time)) :-
       ( holds_at(at(Agent, Room), Time),
         holds_at(at(Object, Room), Time),
         equals(side2(Staircase), Room),
         happens(walkDownStaircase(Agent, Staircase), Time)
       ),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Staircase)=Room).
 */

 /*  [holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), call(side2(Staircase)=Room), happens(walkDownStaircase(Agent, Staircase), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(near(Agent, Object)), Time)).
 */

 /*  [holds_at(at(Agent, Room), Time), holds_at(at(Object, Room), Time), holds_at(call(side2(Staircase)=Room), Time), happens(walkDownStaircase(Agent, Staircase), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(near(Agent, Object)), Time)).
 */
axiom(holds_at(neg(near(Agent, Object)), Time),
   
    [ holds_at(at(Agent, Room), Time),
      holds_at(at(Object, Room), Time),
      holds_at(call(side2(Staircase)=Room), Time),
      happens(walkDownStaircase(Agent, Staircase), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).

 /*  not(holds_at(at(Agent, Room), Time)) :-
       ( holds_at(at(Object, Room), Time),
         equals(side2(Staircase), Room),
         happens(walkDownStaircase(Agent, Staircase), Time)
       ),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Staircase)=Room).
 */

 /*  [holds_at(at(Object, Room), Time), call(side2(Staircase)=Room), happens(walkDownStaircase(Agent, Staircase), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(at(Agent, Room)), Time)).
 */

 /*  [holds_at(at(Object, Room), Time), holds_at(call(side2(Staircase)=Room), Time), happens(walkDownStaircase(Agent, Staircase), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(at(Agent, Room)), Time)).
 */
axiom(holds_at(neg(at(Agent, Room)), Time),
   
    [ holds_at(at(Object, Room), Time),
      holds_at(call(side2(Staircase)=Room), Time),
      happens(walkDownStaircase(Agent, Staircase), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).

 /*  not(holds_at(at(Object, Room), Time)) :-
       ( equals(side2(Staircase), Room),
         happens(walkDownStaircase(Agent, Staircase), Time)
       ),
       holds_at(at(Agent, Room), Time),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Staircase)=Room).
 */

 /*  [call(side2(Staircase)=Room), happens(walkDownStaircase(Agent, Staircase), Time), holds_at(at(Agent, Room), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(at(Object, Room)), Time)).
 */

 /*  [holds_at(call(side2(Staircase)=Room), Time), happens(walkDownStaircase(Agent, Staircase), Time), holds_at(at(Agent, Room), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time, holds_at(neg(at(Object, Room)), Time)).
 */
axiom(holds_at(neg(at(Object, Room)), Time),
   
    [ holds_at(call(side2(Staircase)=Room), Time),
      happens(walkDownStaircase(Agent, Staircase), Time),
      holds_at(at(Agent, Room), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).

 /*  not(happens(walkDownStaircase(Agent, Staircase), Time)) :-
       equals(side2(Staircase), Room),
       holds_at(at(Object, Room), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(near(Agent, Object), Time),
       not(happens(walkFrom(Agent, Object), Time)),
       allDifferent(
                    [ Agent,
                      Object,
                      Time,
                      Room,
                      Staircase
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Staircase), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Staircase)=Room).
 */

 /*  [call(side2(Staircase)=Room), holds_at(at(Object, Room), Time), holds_at(at(Agent, Room), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time,
          not(happens(walkDownStaircase(Agent, Staircase), Time))).
 */

 /*  [holds_at(call(side2(Staircase)=Room), Time), holds_at(at(Object, Room), Time), holds_at(at(Agent, Room), Time), holds_at(near(Agent, Object), Time), not(happens(walkFrom(Agent, Object), Time)), allDifferent([Agent, Object, Time, Room, Staircase])] ->
       ta(Time,
          not(happens(walkDownStaircase(Agent, Staircase), Time))).
 */
axiom(not(happens(walkDownStaircase(Agent, Staircase), Time)),
   
    [ holds_at(call(side2(Staircase)=Room), Time),
      holds_at(at(Object, Room), Time),
      holds_at(at(Agent, Room), Time),
      holds_at(near(Agent, Object), Time),
      not(happens(walkFrom(Agent, Object), Time)),
      allDifferent(
                   [ Agent,
                     Object,
                     Time,
                     Room,
                     Staircase
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1205
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/OMSpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; OMSpace: object-scale metric space
%;
%; The OMSpace representation deals with metric space at
%; the scale of objects.
%;
%; @article{Morgenstern:2001,
%;   author = "Morgenstern, Leora",
%;   year = "2001",
%;   title = "Mid-sized axiomatizations of commonsense problems: A case study in egg cracking",
%;   journal = "Studia Logica",
%;   volume = "67",
%;   pages = "333--384",
%; }
%;
%; @article{Shanahan:2003,
%;   author = "Shanahan, Murray",
%;   year = "2004",
%;   title = "An attempt to formalise a non-trivial benchmark problem in common sense reasoning",
%;   journal = "Artificial Intelligence",
%;   volume = "153",
%;   pages = "141--165",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1247
% sort height: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1248
==> subsort(height,integer).

% sort distance: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1249
==> subsort(distance,integer).
%; Height
%; The height of object is height.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1253
% fluent Height(object,height)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1254
fluent(height(Height_Param,Height_Ret)).
==> mpred_prop(height(object,height),fluent).
==> meta_argtypes(height(object,height)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1255
%; State constraint represent the fact that each
%; object has a unique height:
% [object,height1,height2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1258
% HoldsAt(Height(object,height1),time) &
% HoldsAt(Height(object,height2),time) ->
% height1=height2.

 /*  allDifferent([Object, Height1, Time, Height2]) ->
       ( holds_at(height(Object, Height1), Time), holds_at(height(Object, Height2), Time)->Height1=Height2
       ).
 */

 /*  not(holds_at(height(Object, Height1), Time)) :-
       holds_at(height(Object, Height2), Time),
       not(equals(Height1, Height2)),
       allDifferent([Object, Height1, Time, Height2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Height1, Height2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Height1=Height2)).
 */

 /*  [holds_at(height(Object, Height2), Time), not(call(Height1=Height2)), allDifferent([Object, Height1, Time, Height2])] ->
       ta(Time,
          holds_at(neg(height(Object, Height1)), Time)).
 */

 /*  [holds_at(height(Object, Height2), Time), holds_at(neg(call(Height1=Height2)), Time), allDifferent([Object, Height1, Time, Height2])] ->
       ta(Time,
          holds_at(neg(height(Object, Height1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1260
axiom(holds_at(neg(height(Object, Height1)), Time),
   
    [ holds_at(height(Object, Height2), Time),
      holds_at(neg(call(Height1=Height2)), Time),
      allDifferent([Object, Height1, Time, Height2])
    ]).

 /*  not(holds_at(height(Object, Height2), Time)) :-
       holds_at(height(Object, Height1), Time),
       not(equals(Height1, Height2)),
       allDifferent([Object, Height1, Time, Height2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Height1, Height2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Height1=Height2)).
 */

 /*  [holds_at(height(Object, Height1), Time), not(call(Height1=Height2)), allDifferent([Object, Height1, Time, Height2])] ->
       ta(Time,
          holds_at(neg(height(Object, Height2)), Time)).
 */

 /*  [holds_at(height(Object, Height1), Time), holds_at(neg(call(Height1=Height2)), Time), allDifferent([Object, Height1, Time, Height2])] ->
       ta(Time,
          holds_at(neg(height(Object, Height2)), Time)).
 */
axiom(holds_at(neg(height(Object, Height2)), Time),
   
    [ holds_at(height(Object, Height1), Time),
      holds_at(neg(call(Height1=Height2)), Time),
      allDifferent([Object, Height1, Time, Height2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1262
% [object,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1263
% {height}% HoldsAt(Height(object,height),time).

 /*  exists([Height],
    holds_at(height(Object,Height),Time)).
 */

 /*  holds_at(height(Object, Height), Time) :-
       some(Height, '$kolem_Fn_209'(Object, Time)).
 */

 /*  [some(Height, '$kolem_Fn_209'(Object, Time))] ->
       ta(Time, holds_at(height(Object, Height), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1264
axiom(holds_at(height(Object, Height), Time),
    [some(Height, '$kolem_Fn_209'(Object, Time))]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1266
%; falling
%; physobj1 is falling from physobj2 to physobj3.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1269
% fluent FallingFromTo(physobj,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1270
fluent(fallingFromTo(FallingFromTo_Param,
		     _,
		     FallingFromTo_Ret)).
==> mpred_prop(fallingFromTo(physobj,physobj,physobj),fluent).
==> meta_argtypes(fallingFromTo(physobj,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1270
%; physobj1 starts falling from physobj2 to physobj3.

% event StartFallingFromTo(physobj,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1272
event(startFallingFromTo(StartFallingFromTo_Param,
			 _,
			 StartFallingFromTo_Ret)).
==> mpred_prop(startFallingFromTo(physobj,physobj,physobj),event).
==> meta_argtypes(startFallingFromTo(physobj,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1272
%; physobj1 collides with physobj2.

% event CollideWith(physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1274
event(collideWith(CollideWith_Param,CollideWith_Ret)).
==> mpred_prop(collideWith(physobj,physobj),event).
==> meta_argtypes(collideWith(physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1275
%; An effect axiom states that if a first physical object starts
%; falling from a second physical object to a third physical
%; object, the first physical object will be falling from the
%; second physical object to the third physical object:
% [physobj1,physobj2,physobj3,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1280
% Initiates(StartFallingFromTo(physobj1,physobj2,physobj3),
%           FallingFromTo(physobj1,physobj2,physobj3),
%           time).

 /*  [] ->
       ta(Time,
          initiates(startFallingFromTo(Physobj1,
                                       Physobj2,
                                       Physobj3),
                    fallingFromTo(Physobj1, Physobj2, Physobj3),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1282
axiom(initiates(startFallingFromTo(Physobj1, Physobj2, Physobj3), fallingFromTo(Physobj1, Physobj2, Physobj3), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1284
%; A precondition axiom states that for
%; a first physical object to start
%; falling from a second physical object to a third physical
%; object,
%; the height of the first physical object and the
%; second physical object must be the same.
% [physobj1,physobj2,physobj3,height1,height2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1291
% Happens(StartFallingFromTo(physobj1,physobj2,physobj3),time) &
% HoldsAt(Height(physobj1,height1),time) &
% HoldsAt(Height(physobj2,height2),time) ->
% height1=height2.

 /*  allDifferent([Physobj1, Physobj2, Physobj3, Time, Height1, Height2]) ->
       ( happens(startFallingFromTo(Physobj1, Physobj2, Physobj3), Time), holds_at(height(Physobj1, Height1), Time), holds_at(height(Physobj2, Height2), Time)->Height1=Height2
       ).
 */

 /*  not(happens(startFallingFromTo(Physobj1, Physobj2, Physobj3), Time)) :-
       ( holds_at(height(Physobj1, Height1), Time),
         holds_at(height(Physobj2, Height2), Time)
       ),
       not(equals(Height1, Height2)),
       allDifferent(
                    [ Physobj1,
                      Physobj2,
                      Physobj3,
                      Time,
                      Height1,
                      Height2
                    ]).
 */

 /*  axiom_head(Time) ->
       not(equals(Height1, Height2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Height1=Height2)).
 */

 /*  [holds_at(height(Physobj1, Height1), Time), holds_at(height(Physobj2, Height2), Time), not(call(Height1=Height2)), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height1, Height2])] ->
       ta(Time,
          not(happens(startFallingFromTo(Physobj1,
                                         Physobj2,
                                         Physobj3),
                      Time))).
 */

 /*  [holds_at(height(Physobj1, Height1), Time), holds_at(height(Physobj2, Height2), Time), holds_at(neg(call(Height1=Height2)), Time), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height1, Height2])] ->
       ta(Time,
          not(happens(startFallingFromTo(Physobj1,
                                         Physobj2,
                                         Physobj3),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1294
axiom(not(happens(startFallingFromTo(Physobj1, Physobj2, Physobj3), Time)),
   
    [ holds_at(height(Physobj1, Height1), Time),
      holds_at(height(Physobj2, Height2), Time),
      holds_at(neg(call(Height1=Height2)), Time),
      allDifferent(
                   [ Physobj1,
                     Physobj2,
                     Physobj3,
                     Time,
                     Height1,
                     Height2
                   ])
    ]).

 /*  not(holds_at(height(Physobj1, Height1), Time)) :-
       holds_at(height(Physobj2, Height2), Time),
       happens(startFallingFromTo(Physobj1, Physobj2, Physobj3),
               Time),
       not(equals(Height1, Height2)),
       allDifferent(
                    [ Physobj1,
                      Physobj2,
                      Physobj3,
                      Time,
                      Height1,
                      Height2
                    ]).
 */

 /*  axiom_head(Time) ->
       not(equals(Height1, Height2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Height1=Height2)).
 */

 /*  [holds_at(height(Physobj2, Height2), Time), happens(startFallingFromTo(Physobj1, Physobj2, Physobj3), Time), not(call(Height1=Height2)), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height1, Height2])] ->
       ta(Time,
          holds_at(neg(height(Physobj1, Height1)), Time)).
 */

 /*  [holds_at(height(Physobj2, Height2), Time), happens(startFallingFromTo(Physobj1, Physobj2, Physobj3), Time), holds_at(neg(call(Height1=Height2)), Time), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height1, Height2])] ->
       ta(Time,
          holds_at(neg(height(Physobj1, Height1)), Time)).
 */
axiom(holds_at(neg(height(Physobj1, Height1)), Time),
   
    [ holds_at(height(Physobj2, Height2), Time),
      happens(startFallingFromTo(Physobj1, Physobj2, Physobj3),
              Time),
      holds_at(neg(call(Height1=Height2)), Time),
      allDifferent(
                   [ Physobj1,
                     Physobj2,
                     Physobj3,
                     Time,
                     Height1,
                     Height2
                   ])
    ]).

 /*  not(holds_at(height(Physobj2, Height2), Time)) :-
       holds_at(height(Physobj1, Height1), Time),
       happens(startFallingFromTo(Physobj1, Physobj2, Physobj3),
               Time),
       not(equals(Height1, Height2)),
       allDifferent(
                    [ Physobj1,
                      Physobj2,
                      Physobj3,
                      Time,
                      Height1,
                      Height2
                    ]).
 */

 /*  axiom_head(Time) ->
       not(equals(Height1, Height2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Height1=Height2)).
 */

 /*  [holds_at(height(Physobj1, Height1), Time), happens(startFallingFromTo(Physobj1, Physobj2, Physobj3), Time), not(call(Height1=Height2)), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height1, Height2])] ->
       ta(Time,
          holds_at(neg(height(Physobj2, Height2)), Time)).
 */

 /*  [holds_at(height(Physobj1, Height1), Time), happens(startFallingFromTo(Physobj1, Physobj2, Physobj3), Time), holds_at(neg(call(Height1=Height2)), Time), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height1, Height2])] ->
       ta(Time,
          holds_at(neg(height(Physobj2, Height2)), Time)).
 */
axiom(holds_at(neg(height(Physobj2, Height2)), Time),
   
    [ holds_at(height(Physobj1, Height1), Time),
      happens(startFallingFromTo(Physobj1, Physobj2, Physobj3),
              Time),
      holds_at(neg(call(Height1=Height2)), Time),
      allDifferent(
                   [ Physobj1,
                     Physobj2,
                     Physobj3,
                     Time,
                     Height1,
                     Height2
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1296
%; A state constraint says that a physical object
%; cannot fall from itself, cannot fall to itself,
%; and cannot fall from and to the same physical object:
% [physobj1,physobj2,physobj3,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1300
% HoldsAt(FallingFromTo(physobj1,physobj2,physobj3),time) ->
% physobj1!=physobj2 &
% physobj1!=physobj3 &
% physobj2!=physobj3.

 /*  allDifferent([Physobj1, Physobj2, Physobj3, Time]) ->
       ( holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time)->diff(Physobj1, Physobj2), diff(Physobj1, Physobj3), diff(Physobj2, Physobj3)
       ).
 */

 /*  not(holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time)) :-
       (   not(diff(Physobj1, Physobj2))
       ;   not(diff(Physobj1, Physobj3))
       ;   not(diff(Physobj2, Physobj3))
       ),
       allDifferent([Physobj1, Physobj2, Physobj3, Time]).
 */

 /*  [(not(diff(Physobj1, Physobj2));not(diff(Physobj1, Physobj3));not(diff(Physobj2, Physobj3))), allDifferent([Physobj1, Physobj2, Physobj3, Time])] ->
       ta(Time,
          holds_at(neg(fallingFromTo(Physobj1,
                                     Physobj2,
                                     Physobj3)),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1303
axiom(holds_at(neg(fallingFromTo(Physobj1, Physobj2, Physobj3)), Time),
   
    [  (not(diff(Physobj1, Physobj2));not(diff(Physobj1, Physobj3));not(diff(Physobj2, Physobj3))),
      allDifferent([Physobj1, Physobj2, Physobj3, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1305
%; A state constraint says that the sky cannot fall:
% [sky,physobj1,physobj2,time]
% !HoldsAt(FallingFromTo(sky,physobj1,physobj2),time).
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1307
holds_at(neg(fallingFromTo(Sky,Physobj1,Physobj2)),
	 Time).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1309
%; A releases axiom states that if
%; if a first physical object starts
%; falling from a second physical object to a third physical
%; object, the height of the first physical object
%; will be released from inertia:
% [physobj1,physobj2,physobj3,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1315
% Releases(StartFallingFromTo(physobj1,physobj2,physobj3),
%          Height(physobj1,height),
%          time).

 /*  [] ->
       ta(Time,
          releases(startFallingFromTo(Physobj1,
                                      Physobj2,
                                      Physobj3),
                   height(Physobj1, Height),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1317
axiom(releases(startFallingFromTo(Physobj1, Physobj2, Physobj3), height(Physobj1, Height), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1319
%; A trajectory axiom states that
%; if a first physical object starts falling
%; from a second physical object
%; to a third physical object
%; at a time and
%; the first physical object has a height at the time,
%; then the first physical object will have a height
%; equal to the height minus an offset
%; at a time equal to the time plus the offset:
% [physobj1,physobj2,physobj3,height1,height2,offset,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1329
% HoldsAt(Height(physobj1,height1),time) &
% height2=height1-offset ->
% Trajectory(FallingFromTo(physobj1,physobj2,physobj3),time,
%            Height(physobj1,height2),offset).

 /*  allDifferent([Physobj1, Height1, Time, Height2, Offset, Physobj2, Physobj3]) ->
       ( holds_at(height(Physobj1, Height1), Time), Height2=Height1-Offset->trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3), Time, height(Physobj1, Height2), Offset)
       ).
 */

 /*  trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3), Time, height(Physobj1, Height2), Offset) :-
       ( holds_at(height(Physobj1, Height1), Time),
         equals(Height2, Height1-Offset)
       ),
       allDifferent(
                    [ Physobj1,
                      Height1,
                      Time,
                      Height2,
                      Offset,
                      Physobj2,
                      Physobj3
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(Height2, Height1-Offset).
 */

 /*  fix_axiom_head(Time) ->
       call(Height2=Height1-Offset).
 */

 /*  [holds_at(height(Physobj1, Height1), Time), call(Height2=Height1-Offset), allDifferent([Physobj1, Height1, Time, Height2, Offset, Physobj2, Physobj3])] ->
       ta(Time,
          trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3),
                     Time,
                     height(Physobj1, Height2),
                     Offset)).
 */

 /*  [holds_at(height(Physobj1, Height1), Time), holds_at(call(Height2=Height1-Offset), Time), allDifferent([Physobj1, Height1, Time, Height2, Offset, Physobj2, Physobj3])] ->
       ta(Time,
          trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3),
                     Time,
                     height(Physobj1, Height2),
                     Offset)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1332
axiom(trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3), Time, height(Physobj1, Height2), Offset),
   
    [ holds_at(height(Physobj1, Height1), Time),
      holds_at(call(Height2=Height1-Offset), Time),
      allDifferent(
                   [ Physobj1,
                     Height1,
                     Time,
                     Height2,
                     Offset,
                     Physobj2,
                     Physobj3
                   ])
    ]).

 /*  not(holds_at(height(Physobj1, Height1), Time)) :-
       equals(Height2, Height1-Offset),
       not(trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3),
                      Time,
                      height(Physobj1, Height2),
                      Offset)),
       allDifferent(
                    [ Physobj1,
                      Height1,
                      Time,
                      Height2,
                      Offset,
                      Physobj2,
                      Physobj3
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(Height2, Height1-Offset).
 */

 /*  fix_axiom_head(Time) ->
       call(Height2=Height1-Offset).
 */

 /*  [call(Height2=Height1-Offset), not(trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3), Time, height(Physobj1, Height2), Offset)), allDifferent([Physobj1, Height1, Time, Height2, Offset, Physobj2, Physobj3])] ->
       ta(Time,
          holds_at(neg(height(Physobj1, Height1)), Time)).
 */

 /*  [holds_at(call(Height2=Height1-Offset), Time), not(trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3), Time, height(Physobj1, Height2), Offset)), allDifferent([Physobj1, Height1, Time, Height2, Offset, Physobj2, Physobj3])] ->
       ta(Time,
          holds_at(neg(height(Physobj1, Height1)), Time)).
 */
axiom(holds_at(neg(height(Physobj1, Height1)), Time),
   
    [ holds_at(call(Height2=Height1-Offset), Time),
      not(trajectory(fallingFromTo(Physobj1,
                                   Physobj2,
                                   Physobj3),
                     Time,
                     height(Physobj1, Height2),
                     Offset)),
      allDifferent(
                   [ Physobj1,
                     Height1,
                     Time,
                     Height2,
                     Offset,
                     Physobj2,
                     Physobj3
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1334
%; A trigger axiom states that
%; if a first physical object is falling
%; from a second physical object
%; to a third physical object and
%; the height of the first physical object
%; is the same as the height of the third physical object,
%; the first physical object collides with the
%; third physical object:
% [physobj1,physobj2,physobj3,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1343
% HoldsAt(FallingFromTo(physobj1,physobj2,physobj3),time) &
% HoldsAt(Height(physobj1,height),time) &
% HoldsAt(Height(physobj3,height),time) ->
% Happens(CollideWith(physobj1,physobj3),time).

 /*  allDifferent([Physobj1, Physobj2, Physobj3, Time, Height]) ->
       ( holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time), holds_at(height(Physobj1, Height), Time), holds_at(height(Physobj3, Height), Time)->happens(collideWith(Physobj1, Physobj3), Time)
       ).
 */

 /*  happens(collideWith(Physobj1, Physobj3), Time) :-
       ( holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3),
                  Time),
         holds_at(height(Physobj1, Height), Time),
         holds_at(height(Physobj3, Height), Time)
       ),
       allDifferent(
                    [ Physobj1,
                      Physobj2,
                      Physobj3,
                      Time,
                      Height
                    ]).
 */

 /*  [holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time), holds_at(height(Physobj1, Height), Time), holds_at(height(Physobj3, Height), Time), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height])] ->
       ta(Time,
          happens(collideWith(Physobj1, Physobj3), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1346
axiom(happens(collideWith(Physobj1, Physobj3), Time),
   
    [ holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3),
               Time),
      holds_at(height(Physobj1, Height), Time),
      holds_at(height(Physobj3, Height), Time),
      allDifferent(
                   [ Physobj1,
                     Physobj2,
                     Physobj3,
                     Time,
                     Height
                   ])
    ]).

 /*  not(holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time)) :-
       ( holds_at(height(Physobj1, Height), Time),
         holds_at(height(Physobj3, Height), Time)
       ),
       not(happens(collideWith(Physobj1, Physobj3), Time)),
       allDifferent(
                    [ Physobj1,
                      Physobj2,
                      Physobj3,
                      Time,
                      Height
                    ]).
 */

 /*  [holds_at(height(Physobj1, Height), Time), holds_at(height(Physobj3, Height), Time), not(happens(collideWith(Physobj1, Physobj3), Time)), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height])] ->
       ta(Time,
          holds_at(neg(fallingFromTo(Physobj1,
                                     Physobj2,
                                     Physobj3)),
                   Time)).
 */
axiom(holds_at(neg(fallingFromTo(Physobj1, Physobj2, Physobj3)), Time),
   
    [ holds_at(height(Physobj1, Height), Time),
      holds_at(height(Physobj3, Height), Time),
      not(happens(collideWith(Physobj1, Physobj3), Time)),
      allDifferent(
                   [ Physobj1,
                     Physobj2,
                     Physobj3,
                     Time,
                     Height
                   ])
    ]).

 /*  not(holds_at(height(Physobj1, Height), Time)) :-
       holds_at(height(Physobj3, Height), Time),
       holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3),
                Time),
       not(happens(collideWith(Physobj1, Physobj3), Time)),
       allDifferent(
                    [ Physobj1,
                      Physobj2,
                      Physobj3,
                      Time,
                      Height
                    ]).
 */

 /*  [holds_at(height(Physobj3, Height), Time), holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time), not(happens(collideWith(Physobj1, Physobj3), Time)), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height])] ->
       ta(Time,
          holds_at(neg(height(Physobj1, Height)), Time)).
 */
axiom(holds_at(neg(height(Physobj1, Height)), Time),
   
    [ holds_at(height(Physobj3, Height), Time),
      holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3),
               Time),
      not(happens(collideWith(Physobj1, Physobj3), Time)),
      allDifferent(
                   [ Physobj1,
                     Physobj2,
                     Physobj3,
                     Time,
                     Height
                   ])
    ]).

 /*  not(holds_at(height(Physobj3, Height), Time)) :-
       holds_at(height(Physobj1, Height), Time),
       holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3),
                Time),
       not(happens(collideWith(Physobj1, Physobj3), Time)),
       allDifferent(
                    [ Physobj1,
                      Physobj2,
                      Physobj3,
                      Time,
                      Height
                    ]).
 */

 /*  [holds_at(height(Physobj1, Height), Time), holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time), not(happens(collideWith(Physobj1, Physobj3), Time)), allDifferent([Physobj1, Physobj2, Physobj3, Time, Height])] ->
       ta(Time,
          holds_at(neg(height(Physobj3, Height)), Time)).
 */
axiom(holds_at(neg(height(Physobj3, Height)), Time),
   
    [ holds_at(height(Physobj1, Height), Time),
      holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3),
               Time),
      not(happens(collideWith(Physobj1, Physobj3), Time)),
      allDifferent(
                   [ Physobj1,
                     Physobj2,
                     Physobj3,
                     Time,
                     Height
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1348
%; An effect axiom states that
%; if a first physical object is falling
%; from a second physical object
%; to a third physical object and
%; the first physical object collides with
%; the third physical object,
%; the first physical object will be on the third physical object:
% [physobj1,physobj2,physobj3,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1356
% HoldsAt(FallingFromTo(physobj1,physobj2,physobj3),time) ->
% Initiates(CollideWith(physobj1,physobj3),
%           On(physobj1,physobj3),
%           time).

 /*  [holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time)] ->
       ta(Time,
          initiates(collideWith(Physobj1, Physobj3),
                    on(Physobj1, Physobj3),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1359
axiom(initiates(collideWith(Physobj1, Physobj3), on(Physobj1, Physobj3), Time),
   
    [ holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3),
               Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1361
%; An effect axiom states that
%; if a physical object collides with another
%; physical object,
%; the height of the first physical object will
%; be the height of the second physical object:
% [physobj1,physobj2,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1367
% HoldsAt(Height(physobj2,height),time) ->
% Initiates(CollideWith(physobj1,physobj2),
%           Height(physobj1,height),
%           time).

 /*  [holds_at(height(Physobj2, Height), Time)] ->
       ta(Time,
          initiates(collideWith(Physobj1, Physobj2),
                    height(Physobj1, Height),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1370
axiom(initiates(collideWith(Physobj1, Physobj2), height(Physobj1, Height), Time),
    [holds_at(height(Physobj2, Height), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1372
%;[physobj1,physobj2,height1,height2,time]
%;HoldsAt(Height(physobj2,height1),time) &
%;height1 != height2 ->
%;Terminates(CollideWith(physobj1,physobj2),
%;           Height(physobj1,height2),
%;           time).
%; An effect axiom states that
%; if a first physical object is falling
%; from a second physical object
%; to a third physical object and
%; the first physical object collides with
%; the third physical object,
%; the first physical object will no longer be
%; falling from the second physical object to the
%; third physical object:
% [physobj1,physobj2,physobj3,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1389
% HoldsAt(FallingFromTo(physobj1,physobj2,physobj3),time) ->
% Terminates(CollideWith(physobj1,physobj3),
%            FallingFromTo(physobj1,physobj2,physobj3),
%            time).

 /*  [holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time)] ->
       ta(Time,
          terminates(collideWith(Physobj1, Physobj3),
                     fallingFromTo(Physobj1, Physobj2, Physobj3),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1392
axiom(terminates(collideWith(Physobj1, Physobj3), fallingFromTo(Physobj1, Physobj2, Physobj3), Time),
   
    [ holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3),
               Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1394
%; flying
%; agent is flying from physobj1 to physobj2.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1397
% fluent FlyingFromTo(agent,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1398
fluent(flyingFromTo(FlyingFromTo_Param,
		    _,
		    FlyingFromTo_Ret)).
==> mpred_prop(flyingFromTo(agent,physobj,physobj),fluent).
==> meta_argtypes(flyingFromTo(agent,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1398
%; agent starts flying from physobj1 to physobj2.

% event StartFlyingFromTo(agent,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1400
event(startFlyingFromTo(StartFlyingFromTo_Param,
			_,
			StartFlyingFromTo_Ret)).
==> mpred_prop(startFlyingFromTo(agent,physobj,physobj),event).
==> meta_argtypes(startFlyingFromTo(agent,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1400
%; agent reaches physobj.

% event Reach(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1402
event(reach(Reach_Param,Reach_Ret)).
==> mpred_prop(reach(agent,physobj),event).
==> meta_argtypes(reach(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1403
%; An effect axiom states that if an agent starts
%; flying from a physical object to another physical object,
%; the agent will be flying from the first physical object
%; to the second physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1408
% Initiates(StartFlyingFromTo(agent,physobj1,physobj2),
%           FlyingFromTo(agent,physobj1,physobj2),
%           time).

 /*  [] ->
       ta(Time,
          initiates(startFlyingFromTo(Agent, Physobj1, Physobj2),
                    flyingFromTo(Agent, Physobj1, Physobj2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1410
axiom(initiates(startFlyingFromTo(Agent, Physobj1, Physobj2), flyingFromTo(Agent, Physobj1, Physobj2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1412
%; A precondition axiom states that for
%; an agent to start flying from a physical object to
%; another physical object,
%; the height of the agent and
%; the first physical object must be the same:
% [agent,physobj1,physobj2,height1,height2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1418
% Happens(StartFlyingFromTo(agent,physobj1,physobj2),time) &
% HoldsAt(Height(agent,height1),time) &
% HoldsAt(Height(physobj1,height2),time) ->
% height1=height2.

 /*  allDifferent([Agent, Physobj1, Physobj2, Time, Height1, Height2]) ->
       ( happens(startFlyingFromTo(Agent, Physobj1, Physobj2), Time), holds_at(height(Agent, Height1), Time), holds_at(height(Physobj1, Height2), Time)->Height1=Height2
       ).
 */

 /*  not(happens(startFlyingFromTo(Agent, Physobj1, Physobj2), Time)) :-
       ( holds_at(height(Agent, Height1), Time),
         holds_at(height(Physobj1, Height2), Time)
       ),
       not(equals(Height1, Height2)),
       allDifferent(
                    [ Agent,
                      Physobj1,
                      Physobj2,
                      Time,
                      Height1,
                      Height2
                    ]).
 */

 /*  axiom_head(Time) ->
       not(equals(Height1, Height2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Height1=Height2)).
 */

 /*  [holds_at(height(Agent, Height1), Time), holds_at(height(Physobj1, Height2), Time), not(call(Height1=Height2)), allDifferent([Agent, Physobj1, Physobj2, Time, Height1, Height2])] ->
       ta(Time,
          not(happens(startFlyingFromTo(Agent,
                                        Physobj1,
                                        Physobj2),
                      Time))).
 */

 /*  [holds_at(height(Agent, Height1), Time), holds_at(height(Physobj1, Height2), Time), holds_at(neg(call(Height1=Height2)), Time), allDifferent([Agent, Physobj1, Physobj2, Time, Height1, Height2])] ->
       ta(Time,
          not(happens(startFlyingFromTo(Agent,
                                        Physobj1,
                                        Physobj2),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1421
axiom(not(happens(startFlyingFromTo(Agent, Physobj1, Physobj2), Time)),
   
    [ holds_at(height(Agent, Height1), Time),
      holds_at(height(Physobj1, Height2), Time),
      holds_at(neg(call(Height1=Height2)), Time),
      allDifferent(
                   [ Agent,
                     Physobj1,
                     Physobj2,
                     Time,
                     Height1,
                     Height2
                   ])
    ]).

 /*  not(holds_at(height(Agent, Height1), Time)) :-
       holds_at(height(Physobj1, Height2), Time),
       happens(startFlyingFromTo(Agent, Physobj1, Physobj2),
               Time),
       not(equals(Height1, Height2)),
       allDifferent(
                    [ Agent,
                      Physobj1,
                      Physobj2,
                      Time,
                      Height1,
                      Height2
                    ]).
 */

 /*  axiom_head(Time) ->
       not(equals(Height1, Height2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Height1=Height2)).
 */

 /*  [holds_at(height(Physobj1, Height2), Time), happens(startFlyingFromTo(Agent, Physobj1, Physobj2), Time), not(call(Height1=Height2)), allDifferent([Agent, Physobj1, Physobj2, Time, Height1, Height2])] ->
       ta(Time, holds_at(neg(height(Agent, Height1)), Time)).
 */

 /*  [holds_at(height(Physobj1, Height2), Time), happens(startFlyingFromTo(Agent, Physobj1, Physobj2), Time), holds_at(neg(call(Height1=Height2)), Time), allDifferent([Agent, Physobj1, Physobj2, Time, Height1, Height2])] ->
       ta(Time, holds_at(neg(height(Agent, Height1)), Time)).
 */
axiom(holds_at(neg(height(Agent, Height1)), Time),
   
    [ holds_at(height(Physobj1, Height2), Time),
      happens(startFlyingFromTo(Agent, Physobj1, Physobj2),
              Time),
      holds_at(neg(call(Height1=Height2)), Time),
      allDifferent(
                   [ Agent,
                     Physobj1,
                     Physobj2,
                     Time,
                     Height1,
                     Height2
                   ])
    ]).

 /*  not(holds_at(height(Physobj1, Height2), Time)) :-
       holds_at(height(Agent, Height1), Time),
       happens(startFlyingFromTo(Agent, Physobj1, Physobj2),
               Time),
       not(equals(Height1, Height2)),
       allDifferent(
                    [ Agent,
                      Physobj1,
                      Physobj2,
                      Time,
                      Height1,
                      Height2
                    ]).
 */

 /*  axiom_head(Time) ->
       not(equals(Height1, Height2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Height1=Height2)).
 */

 /*  [holds_at(height(Agent, Height1), Time), happens(startFlyingFromTo(Agent, Physobj1, Physobj2), Time), not(call(Height1=Height2)), allDifferent([Agent, Physobj1, Physobj2, Time, Height1, Height2])] ->
       ta(Time,
          holds_at(neg(height(Physobj1, Height2)), Time)).
 */

 /*  [holds_at(height(Agent, Height1), Time), happens(startFlyingFromTo(Agent, Physobj1, Physobj2), Time), holds_at(neg(call(Height1=Height2)), Time), allDifferent([Agent, Physobj1, Physobj2, Time, Height1, Height2])] ->
       ta(Time,
          holds_at(neg(height(Physobj1, Height2)), Time)).
 */
axiom(holds_at(neg(height(Physobj1, Height2)), Time),
   
    [ holds_at(height(Agent, Height1), Time),
      happens(startFlyingFromTo(Agent, Physobj1, Physobj2),
              Time),
      holds_at(neg(call(Height1=Height2)), Time),
      allDifferent(
                   [ Agent,
                     Physobj1,
                     Physobj2,
                     Time,
                     Height1,
                     Height2
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1423
%; A state constraint says that an agent
%; cannot fly from and to the same physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1426
% HoldsAt(FlyingFromTo(agent,physobj1,physobj2),time) ->
% physobj1!=physobj2.

 /*  allDifferent([Agent, Physobj1, Physobj2, Time]) ->
       ( holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time)->diff(Physobj1, Physobj2)
       ).
 */

 /*  not(holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time)) :-
       not(diff(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Physobj2, Time]).
 */

 /*  [not(diff(Physobj1, Physobj2)), allDifferent([Agent, Physobj1, Physobj2, Time])] ->
       ta(Time,
          holds_at(neg(flyingFromTo(Agent, Physobj1, Physobj2)),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1427
axiom(holds_at(neg(flyingFromTo(Agent, Physobj1, Physobj2)), Time),
   
    [ not(diff(Physobj1, Physobj2)),
      allDifferent([Agent, Physobj1, Physobj2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1429
%; A releases axiom states that if an agent
%; starts flying from a physical object to another
%; physical object, the height of the agent will
%; be released from inertia:
% [agent,physobj1,physobj2,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1434
% Releases(StartFlyingFromTo(agent,physobj1,physobj2),
%          Height(agent,height),
%          time).

 /*  [] ->
       ta(Time,
          releases(startFlyingFromTo(Agent, Physobj1, Physobj2),
                   height(Agent, Height),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1436
axiom(releases(startFlyingFromTo(Agent, Physobj1, Physobj2), height(Agent, Height), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1438
%; A trajectory axiom states that
%; if an agent starts flying from
%; from a physical object
%; to another physical object
%; at a time and
%; the agent has a height at the time,
%; then the agent will have a height
%; equal to the height plus an offset
%; at a time equal to the time plus the offset:
% [agent,physobj1,physobj2,height1,height2,offset,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1448
% HoldsAt(Height(agent,height1),time) &
% height2=height1+offset ->
% Trajectory(FlyingFromTo(agent,physobj1,physobj2),time,
%            Height(agent,height2),offset).

 /*  allDifferent([Agent, Height1, Time, Height2, Offset, Physobj1, Physobj2]) ->
       ( holds_at(height(Agent, Height1), Time), Height2=Height1+Offset->trajectory(flyingFromTo(Agent, Physobj1, Physobj2), Time, height(Agent, Height2), Offset)
       ).
 */

 /*  trajectory(flyingFromTo(Agent, Physobj1, Physobj2), Time, height(Agent, Height2), Offset) :-
       ( holds_at(height(Agent, Height1), Time),
         equals(Height2, Height1+Offset)
       ),
       allDifferent(
                    [ Agent,
                      Height1,
                      Time,
                      Height2,
                      Offset,
                      Physobj1,
                      Physobj2
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(Height2, Height1+Offset).
 */

 /*  fix_axiom_head(Time) ->
       call(Height2=Height1+Offset).
 */

 /*  [holds_at(height(Agent, Height1), Time), call(Height2=Height1+Offset), allDifferent([Agent, Height1, Time, Height2, Offset, Physobj1, Physobj2])] ->
       ta(Time,
          trajectory(flyingFromTo(Agent, Physobj1, Physobj2),
                     Time,
                     height(Agent, Height2),
                     Offset)).
 */

 /*  [holds_at(height(Agent, Height1), Time), holds_at(call(Height2=Height1+Offset), Time), allDifferent([Agent, Height1, Time, Height2, Offset, Physobj1, Physobj2])] ->
       ta(Time,
          trajectory(flyingFromTo(Agent, Physobj1, Physobj2),
                     Time,
                     height(Agent, Height2),
                     Offset)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1451
axiom(trajectory(flyingFromTo(Agent, Physobj1, Physobj2), Time, height(Agent, Height2), Offset),
   
    [ holds_at(height(Agent, Height1), Time),
      holds_at(call(Height2=Height1+Offset), Time),
      allDifferent(
                   [ Agent,
                     Height1,
                     Time,
                     Height2,
                     Offset,
                     Physobj1,
                     Physobj2
                   ])
    ]).

 /*  not(holds_at(height(Agent, Height1), Time)) :-
       equals(Height2, Height1+Offset),
       not(trajectory(flyingFromTo(Agent, Physobj1, Physobj2),
                      Time,
                      height(Agent, Height2),
                      Offset)),
       allDifferent(
                    [ Agent,
                      Height1,
                      Time,
                      Height2,
                      Offset,
                      Physobj1,
                      Physobj2
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(Height2, Height1+Offset).
 */

 /*  fix_axiom_head(Time) ->
       call(Height2=Height1+Offset).
 */

 /*  [call(Height2=Height1+Offset), not(trajectory(flyingFromTo(Agent, Physobj1, Physobj2), Time, height(Agent, Height2), Offset)), allDifferent([Agent, Height1, Time, Height2, Offset, Physobj1, Physobj2])] ->
       ta(Time, holds_at(neg(height(Agent, Height1)), Time)).
 */

 /*  [holds_at(call(Height2=Height1+Offset), Time), not(trajectory(flyingFromTo(Agent, Physobj1, Physobj2), Time, height(Agent, Height2), Offset)), allDifferent([Agent, Height1, Time, Height2, Offset, Physobj1, Physobj2])] ->
       ta(Time, holds_at(neg(height(Agent, Height1)), Time)).
 */
axiom(holds_at(neg(height(Agent, Height1)), Time),
   
    [ holds_at(call(Height2=Height1+Offset), Time),
      not(trajectory(flyingFromTo(Agent, Physobj1, Physobj2),
                     Time,
                     height(Agent, Height2),
                     Offset)),
      allDifferent(
                   [ Agent,
                     Height1,
                     Time,
                     Height2,
                     Offset,
                     Physobj1,
                     Physobj2
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1453
%; A trigger axiom states that
%; if an agent is flying
%; from a physical object
%; to another physical object and
%; the height of the agent
%; is the same as the height of the second physical object,
%; the agent reaches the second physical object:
% [agent,physobj1,physobj2,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1461
% HoldsAt(FlyingFromTo(agent,physobj1,physobj2),time) &
% HoldsAt(Height(agent,height),time) &
% HoldsAt(Height(physobj2,height),time) ->
% Happens(Reach(agent,physobj2),time).

 /*  allDifferent([Agent, Physobj1, Physobj2, Time, Height]) ->
       ( holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time), holds_at(height(Agent, Height), Time), holds_at(height(Physobj2, Height), Time)->happens(reach(Agent, Physobj2), Time)
       ).
 */

 /*  happens(reach(Agent, Physobj2), Time) :-
       ( holds_at(flyingFromTo(Agent, Physobj1, Physobj2),
                  Time),
         holds_at(height(Agent, Height), Time),
         holds_at(height(Physobj2, Height), Time)
       ),
       allDifferent(
                    [ Agent,
                      Physobj1,
                      Physobj2,
                      Time,
                      Height
                    ]).
 */

 /*  [holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time), holds_at(height(Agent, Height), Time), holds_at(height(Physobj2, Height), Time), allDifferent([Agent, Physobj1, Physobj2, Time, Height])] ->
       ta(Time, happens(reach(Agent, Physobj2), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1464
axiom(happens(reach(Agent, Physobj2), Time),
   
    [ holds_at(flyingFromTo(Agent, Physobj1, Physobj2),
               Time),
      holds_at(height(Agent, Height), Time),
      holds_at(height(Physobj2, Height), Time),
      allDifferent(
                   [ Agent,
                     Physobj1,
                     Physobj2,
                     Time,
                     Height
                   ])
    ]).

 /*  not(holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time)) :-
       ( holds_at(height(Agent, Height), Time),
         holds_at(height(Physobj2, Height), Time)
       ),
       not(happens(reach(Agent, Physobj2), Time)),
       allDifferent(
                    [ Agent,
                      Physobj1,
                      Physobj2,
                      Time,
                      Height
                    ]).
 */

 /*  [holds_at(height(Agent, Height), Time), holds_at(height(Physobj2, Height), Time), not(happens(reach(Agent, Physobj2), Time)), allDifferent([Agent, Physobj1, Physobj2, Time, Height])] ->
       ta(Time,
          holds_at(neg(flyingFromTo(Agent, Physobj1, Physobj2)),
                   Time)).
 */
axiom(holds_at(neg(flyingFromTo(Agent, Physobj1, Physobj2)), Time),
   
    [ holds_at(height(Agent, Height), Time),
      holds_at(height(Physobj2, Height), Time),
      not(happens(reach(Agent, Physobj2), Time)),
      allDifferent(
                   [ Agent,
                     Physobj1,
                     Physobj2,
                     Time,
                     Height
                   ])
    ]).

 /*  not(holds_at(height(Agent, Height), Time)) :-
       holds_at(height(Physobj2, Height), Time),
       holds_at(flyingFromTo(Agent, Physobj1, Physobj2),
                Time),
       not(happens(reach(Agent, Physobj2), Time)),
       allDifferent(
                    [ Agent,
                      Physobj1,
                      Physobj2,
                      Time,
                      Height
                    ]).
 */

 /*  [holds_at(height(Physobj2, Height), Time), holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time), not(happens(reach(Agent, Physobj2), Time)), allDifferent([Agent, Physobj1, Physobj2, Time, Height])] ->
       ta(Time, holds_at(neg(height(Agent, Height)), Time)).
 */
axiom(holds_at(neg(height(Agent, Height)), Time),
   
    [ holds_at(height(Physobj2, Height), Time),
      holds_at(flyingFromTo(Agent, Physobj1, Physobj2),
               Time),
      not(happens(reach(Agent, Physobj2), Time)),
      allDifferent(
                   [ Agent,
                     Physobj1,
                     Physobj2,
                     Time,
                     Height
                   ])
    ]).

 /*  not(holds_at(height(Physobj2, Height), Time)) :-
       holds_at(height(Agent, Height), Time),
       holds_at(flyingFromTo(Agent, Physobj1, Physobj2),
                Time),
       not(happens(reach(Agent, Physobj2), Time)),
       allDifferent(
                    [ Agent,
                      Physobj1,
                      Physobj2,
                      Time,
                      Height
                    ]).
 */

 /*  [holds_at(height(Agent, Height), Time), holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time), not(happens(reach(Agent, Physobj2), Time)), allDifferent([Agent, Physobj1, Physobj2, Time, Height])] ->
       ta(Time,
          holds_at(neg(height(Physobj2, Height)), Time)).
 */
axiom(holds_at(neg(height(Physobj2, Height)), Time),
   
    [ holds_at(height(Agent, Height), Time),
      holds_at(flyingFromTo(Agent, Physobj1, Physobj2),
               Time),
      not(happens(reach(Agent, Physobj2), Time)),
      allDifferent(
                   [ Agent,
                     Physobj1,
                     Physobj2,
                     Time,
                     Height
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1466
%; An effect axiom states that
%; if an agent reaches a physical object,
%; the height of the agent will be the
%; height of the physical object:
% [agent,physobj,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1471
% HoldsAt(Height(physobj,height),time) ->
% Initiates(Reach(agent,physobj),Height(agent,height),time).

 /*  [holds_at(height(Physobj, Height), Time)] ->
       ta(Time,
          initiates(reach(Agent, Physobj),
                    height(Agent, Height),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1472
axiom(initiates(reach(Agent, Physobj), height(Agent, Height), Time),
    [holds_at(height(Physobj, Height), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1474
%;[agent,physobj,height1,height2,time]
%;HoldsAt(Height(physobj,height1),time) &
%;height1!=height2 ->
%;Terminates(Reach(agent,physobj),Height(agent,height2),time).
%; An effect axiom states that
%; if an agent is flying
%; from a physical object
%; to another physical object and
%; the agent reaches the second physical object,
%; the agent will no longer be
%; flying from the first physical object
%; to the second physical object:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1488
% HoldsAt(FlyingFromTo(agent,physobj1,physobj2),time) ->
% Terminates(Reach(agent,physobj2),
%            FlyingFromTo(agent,physobj1,physobj2),
%            time).

 /*  [holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time)] ->
       ta(Time,
          terminates(reach(Agent, Physobj2),
                     flyingFromTo(Agent, Physobj1, Physobj2),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1491
axiom(terminates(reach(Agent, Physobj2), flyingFromTo(Agent, Physobj1, Physobj2), Time),
   
    [ holds_at(flyingFromTo(Agent, Physobj1, Physobj2),
               Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1493
%; A releases axiom states that
%; if an agent holds a physical object,
%; the height of the physical object is released from inertia:
% [agent,physobj,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1497
% Releases(Hold(agent,physobj),Height(physobj,height),time).

 /*  [] ->
       ta(Time,
          releases(hold(Agent, Physobj),
                   height(Physobj, Height),
                   Time)).
 */
axiom(releases(hold(Agent, Physobj), height(Physobj, Height), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1499
%;[agent,physobj,height1,height2,time]
%;(!{object} PartOf(physobj,object)) &
%;HoldsAt(Height(physobj,height1),time) &
%;height1 != height2 ->
%;Terminates(LetGoOf(agent,physobj),Height(physobj,height2),time).
% [agent,physobj,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1506
% (!{object} PartOf(physobj,object)) &
% HoldsAt(Height(physobj,height),time) ->
% Initiates(LetGoOf(agent,physobj),Height(physobj,height),time).

 /*  [not(partOf(Physobj, Object)), holds_at(height(Physobj, Height), Time)] ->
       ta(Time,
          initiates(letGoOf(Agent, Physobj),
                    height(Physobj, Height),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1508
axiom(initiates(letGoOf(Agent, Physobj), height(Physobj, Height), Time),
   
    [ not(partOf(Physobj, Object)),
      holds_at(height(Physobj, Height), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1510
%; A state constraint says that
%; if an agent is holding a physical object and
%; the height of the agent is height,
%; the height of the physical object is height:
% [agent,physobj,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1515
% HoldsAt(Holding(agent,physobj),time) &
% HoldsAt(Height(agent,height),time) ->
% HoldsAt(Height(physobj,height),time).

 /*  allDifferent([Agent, Physobj, Time, Height]) ->
       ( holds_at(holding(Agent, Physobj), Time), holds_at(height(Agent, Height), Time)->holds_at(height(Physobj, Height), Time)
       ).
 */

 /*  holds_at(height(Physobj, Height), Time) :-
       ( holds_at(holding(Agent, Physobj), Time),
         holds_at(height(Agent, Height), Time)
       ),
       allDifferent([Agent, Physobj, Time, Height]).
 */

 /*  [holds_at(holding(Agent, Physobj), Time), holds_at(height(Agent, Height), Time), allDifferent([Agent, Physobj, Time, Height])] ->
       ta(Time, holds_at(height(Physobj, Height), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1517
axiom(holds_at(height(Physobj, Height), Time),
   
    [ holds_at(holding(Agent, Physobj), Time),
      holds_at(height(Agent, Height), Time),
      allDifferent([Agent, Physobj, Time, Height])
    ]).

 /*  not(holds_at(holding(Agent, Physobj), Time)) :-
       holds_at(height(Agent, Height), Time),
       not(holds_at(height(Physobj, Height), Time)),
       allDifferent([Agent, Physobj, Time, Height]).
 */

 /*  [holds_at(height(Agent, Height), Time), holds_at(neg(height(Physobj, Height)), Time), allDifferent([Agent, Physobj, Time, Height])] ->
       ta(Time,
          holds_at(neg(holding(Agent, Physobj)), Time)).
 */
axiom(holds_at(neg(holding(Agent, Physobj)), Time),
   
    [ holds_at(height(Agent, Height), Time),
      holds_at(neg(height(Physobj, Height)), Time),
      allDifferent([Agent, Physobj, Time, Height])
    ]).

 /*  not(holds_at(height(Agent, Height), Time)) :-
       holds_at(holding(Agent, Physobj), Time),
       not(holds_at(height(Physobj, Height), Time)),
       allDifferent([Agent, Physobj, Time, Height]).
 */

 /*  [holds_at(holding(Agent, Physobj), Time), holds_at(neg(height(Physobj, Height)), Time), allDifferent([Agent, Physobj, Time, Height])] ->
       ta(Time, holds_at(neg(height(Agent, Height)), Time)).
 */
axiom(holds_at(neg(height(Agent, Height)), Time),
   
    [ holds_at(holding(Agent, Physobj), Time),
      holds_at(neg(height(Physobj, Height)), Time),
      allDifferent([Agent, Physobj, Time, Height])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1519
%; A state constraint says that if a physical object
%; is part of an object,
%; the height of the physical object
%; is the same as the height of the object:
% [physobj,object,height,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1524
% PartOf(physobj,object) &
% HoldsAt(Height(object,height),time) ->
% HoldsAt(Height(physobj,height),time).

 /*  allDifferent([Physobj, Object, Height, Time]) ->
       ( partOf(Physobj, Object), holds_at(height(Object, Height), Time)->holds_at(height(Physobj, Height), Time)
       ).
 */

 /*  holds_at(height(Physobj, Height), Time) :-
       ( partOf(Physobj, Object),
         holds_at(height(Object, Height), Time)
       ),
       allDifferent([Physobj, Object, Height, Time]).
 */

 /*  [partOf(Physobj, Object), holds_at(height(Object, Height), Time), allDifferent([Physobj, Object, Height, Time])] ->
       ta(Time, holds_at(height(Physobj, Height), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1526
axiom(holds_at(height(Physobj, Height), Time),
   
    [ partOf(Physobj, Object),
      holds_at(height(Object, Height), Time),
      allDifferent([Physobj, Object, Height, Time])
    ]).

 /*  not(partOf(Physobj, Object)) :-
       holds_at(height(Object, Height), Time),
       not(holds_at(height(Physobj, Height), Time)),
       allDifferent([Physobj, Object, Height, Time]).
 */

 /*  [holds_at(height(Object, Height), Time), holds_at(neg(height(Physobj, Height)), Time), allDifferent([Physobj, Object, Height, Time])] ->
       ta(Time, not(partOf(Physobj, Object))).
 */
axiom(not(partOf(Physobj, Object)),
   
    [ holds_at(height(Object, Height), Time),
      holds_at(neg(height(Physobj, Height)), Time),
      allDifferent([Physobj, Object, Height, Time])
    ]).

 /*  not(holds_at(height(Object, Height), Time)) :-
       partOf(Physobj, Object),
       not(holds_at(height(Physobj, Height), Time)),
       allDifferent([Physobj, Object, Height, Time]).
 */

 /*  [partOf(Physobj, Object), holds_at(neg(height(Physobj, Height)), Time), allDifferent([Physobj, Object, Height, Time])] ->
       ta(Time, holds_at(neg(height(Object, Height)), Time)).
 */
axiom(holds_at(neg(height(Object, Height)), Time),
   
    [ partOf(Physobj, Object),
      holds_at(neg(height(Physobj, Height)), Time),
      allDifferent([Physobj, Object, Height, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1528
%;event Catch(agent,physobj)
%;event HitFromTo(agent,physobj,object,object)
%;fluent Distance(physobj,physobj,distance)
%;fluent FlyingAcrossFromTo(physobj,object,object)
%;[agent,physobj1,physobj2,physobj3,time]
%;Initiates(HitFromTo(agent,physobj1,physobj2,physobj3),
%;          FlyingAcrossFromTo(physobj1,physobj2,physobj3),
%;          time).
%;[agent,physobj1,physobj2,physobj3,distance,time]
%;Releases(HitFromTo(agent,physobj1,physobj2,physobj3),
%;         Distance(physobj1,physobj2,distance),
%;         time).
%;[agent,physobj1,physobj2,physobj3,distance,time]
%;Releases(HitFromTo(agent,physobj1,physobj2,physobj3),
%;         Distance(physobj1,physobj3,distance),
%;         time).
%;[physobj1,physobj2,physobj3,offset,time]
%;Trajectory(FlyingAcrossFromTo(physobj1,physobj2,physobj3),time,
%;           Distance(physobj1,physobj2,offset),offset).
%;[physobj1,physobj2,physobj3,distance1,distance2,offset,time]
%;HoldsAt(Distance(physobj2,physobj3,distance1),time) &
%;distance2 = distance1 - time ->
%;Trajectory(FlyingAcrossFromTo(physobj1,physobj2,physobj3),time,
%;           Distance(physobj1,physobj3,distance2),offset).
%;[agent,physobj1,physobj2,physobj3,time]
%;HoldsAt(FlyingAcrossFromTo(physobj1,physobj2,physobj3),time) ->
%;Initiates(Catch(agent,physobj1),
%;          Holding(agent,physobj1),
%;          time).
%;[agent,physobj1,physobj2,physobj3,time]
%;HoldsAt(FlyingAcrossFromTo(physobj1,physobj2,physobj3),time) ->
%;Terminates(Catch(agent,physobj1),
%;           FlyingAcrossFromTo(physobj1,physobj2,physobj3),
%;           time).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/GSpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; GSpace: grid space
%;
%; @book{Mueller:1998,
%;   author = "Erik T. Mueller",
%;   year = "1998",
%;   title = "Natural Language Processing with \uppercase{T}hought\uppercase{T}reasure",
%;   address = "New York",
%;   publisher = "Signiform",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1599
% sort coord: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1600
==> subsort(coord,integer).

% sort grid
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1601
==> sort(grid).
%; object is at (coord1, coord2) in grid.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1603
% fluent GridAt(grid,object,coord,coord)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1604
fluent(gridAt(GridAt_Param,_,_,GridAt_Ret)).
==> mpred_prop(gridAt(grid,object,coord,coord),fluent).
==> meta_argtypes(gridAt(grid,object,coord,coord)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1605
%; agent walks from (coord1, coord2)
%; to (coord3, coord4) in grid.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1607
% event GridWalk(grid,agent,coord,coord,coord,coord)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1608
event(gridWalk(GridWalk_Param,
	       _,
	       _,
	       _,
	       _,
	       GridWalk_Ret)).
==> mpred_prop(gridWalk(grid,agent,coord,coord,coord,coord),event).
==> meta_argtypes(gridWalk(grid,agent,coord,coord,coord,coord)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1609
%; A state constraint says that for a given grid an
%; object is at one cell in that grid at a time:
% [grid,object,coord1,coord2,coord3,coord4,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1612
% HoldsAt(GridAt(grid,object,coord1,coord2),time) &
% HoldsAt(GridAt(grid,object,coord3,coord4),time) ->
% coord1=coord3 & coord2=coord4.

 /*  allDifferent([Grid, Object, Coord1, Coord2, Time, Coord3, Coord4]) ->
       ( holds_at(gridAt(Grid, Object, Coord1, Coord2), Time), holds_at(gridAt(Grid, Object, Coord3, Coord4), Time)->Coord1=Coord3, Coord2=Coord4
       ).
 */

 /*  not(holds_at(gridAt(Grid, Object, Coord1, Coord2), Time)) :-
       holds_at(gridAt(Grid, Object, Coord3, Coord4),
                Time),
       (   not(equals(Coord1, Coord3))
       ;   not(equals(Coord2, Coord4))
       ),
       allDifferent(
                    [ Grid,
                      Object,
                      Coord1,
                      Coord2,
                      Time,
                      Coord3,
                      Coord4
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(equals(Coord1, Coord3))
       ;   not(equals(Coord2, Coord4))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(Coord1=Coord3))
       ;   not(call(Coord2=Coord4))
       ).
 */

 /*  [holds_at(gridAt(Grid, Object, Coord3, Coord4), Time),  (not(call(Coord1=Coord3));not(call(Coord2=Coord4))), allDifferent([Grid, Object, Coord1, Coord2, Time, Coord3, Coord4])] ->
       ta(Time,
          holds_at(neg(gridAt(Grid, Object, Coord1, Coord2)),
                   Time)).
 */

 /*  [holds_at(gridAt(Grid, Object, Coord3, Coord4), Time),  (holds_at(neg(call(Coord1=Coord3)), Time);holds_at(neg(call(Coord2=Coord4)), Time)), allDifferent([Grid, Object, Coord1, Coord2, Time, Coord3, Coord4])] ->
       ta(Time,
          holds_at(neg(gridAt(Grid, Object, Coord1, Coord2)),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1614
axiom(holds_at(neg(gridAt(Grid, Object, Coord1, Coord2)), Time),
   
    [ holds_at(gridAt(Grid, Object, Coord3, Coord4),
               Time),
       (holds_at(neg(call(Coord1=Coord3)), Time);holds_at(neg(call(Coord2=Coord4)), Time)),
      allDifferent(
                   [ Grid,
                     Object,
                     Coord1,
                     Coord2,
                     Time,
                     Coord3,
                     Coord4
                   ])
    ]).

 /*  not(holds_at(gridAt(Grid, Object, Coord3, Coord4), Time)) :-
       holds_at(gridAt(Grid, Object, Coord1, Coord2),
                Time),
       (   not(equals(Coord1, Coord3))
       ;   not(equals(Coord2, Coord4))
       ),
       allDifferent(
                    [ Grid,
                      Object,
                      Coord1,
                      Coord2,
                      Time,
                      Coord3,
                      Coord4
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(equals(Coord1, Coord3))
       ;   not(equals(Coord2, Coord4))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(Coord1=Coord3))
       ;   not(call(Coord2=Coord4))
       ).
 */

 /*  [holds_at(gridAt(Grid, Object, Coord1, Coord2), Time),  (not(call(Coord1=Coord3));not(call(Coord2=Coord4))), allDifferent([Grid, Object, Coord1, Coord2, Time, Coord3, Coord4])] ->
       ta(Time,
          holds_at(neg(gridAt(Grid, Object, Coord3, Coord4)),
                   Time)).
 */

 /*  [holds_at(gridAt(Grid, Object, Coord1, Coord2), Time),  (holds_at(neg(call(Coord1=Coord3)), Time);holds_at(neg(call(Coord2=Coord4)), Time)), allDifferent([Grid, Object, Coord1, Coord2, Time, Coord3, Coord4])] ->
       ta(Time,
          holds_at(neg(gridAt(Grid, Object, Coord3, Coord4)),
                   Time)).
 */
axiom(holds_at(neg(gridAt(Grid, Object, Coord3, Coord4)), Time),
   
    [ holds_at(gridAt(Grid, Object, Coord1, Coord2),
               Time),
       (holds_at(neg(call(Coord1=Coord3)), Time);holds_at(neg(call(Coord2=Coord4)), Time)),
      allDifferent(
                   [ Grid,
                     Object,
                     Coord1,
                     Coord2,
                     Time,
                     Coord3,
                     Coord4
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1616
%; An effect axiom states that
%; if an agent walks from one cell in a grid to another cell,
%; the agent will be at second cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1620
% Initiates(GridWalk(grid,agent,coord1,coord2,coord3,coord4),
%           GridAt(grid,agent,coord3,coord4),
%           time).

 /*  [] ->
       ta(Time,
          initiates(gridWalk(Grid,
                             Agent,
                             Coord1,
                             Coord2,
                             Coord3,
                             Coord4),
                    gridAt(Grid, Agent, Coord3, Coord4),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1622
axiom(initiates(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), gridAt(Grid, Agent, Coord3, Coord4), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1624
%; An effect axiom states that
%; if an agent walks from one cell in a grid to another cell,
%; the agent will no longer be at the first cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1628
% Terminates(GridWalk(grid,agent,coord1,coord2,coord3,coord4),
%            GridAt(grid,agent,coord1,coord2),
%            time).

 /*  [] ->
       ta(Time,
          terminates(gridWalk(Grid,
                              Agent,
                              Coord1,
                              Coord2,
                              Coord3,
                              Coord4),
                     gridAt(Grid, Agent, Coord1, Coord2),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1630
axiom(terminates(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), gridAt(Grid, Agent, Coord1, Coord2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1632
%; A precondition axiom states that for an agent to walk
%; from one cell in a grid to another cell, the agent
%; must be at the first cell, the second cell must not
%; be occupied, and the first cell must be adjacent to
%; the second cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1638
% Happens(GridWalk(grid,agent,coord1,coord2,coord3,coord4),time) ->
% HoldsAt(GridAt(grid,agent,coord1,coord2),time) &
% (!{object} HoldsAt(GridAt(grid,object,coord3,coord4),time)) &
% (coord1=coord3 |
%  coord1=coord3+1 |
%  coord1=coord3-1) &
% (coord2=coord4 |
%  coord2=coord4+1 |
%  coord2=coord4-1).

 /*  allDifferent([Grid, Agent, Coord1, Coord2, Coord3, Coord4, Time, Object]) ->
       ( happens(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), Time)->holds_at(gridAt(Grid, Agent, Coord1, Coord2), Time), not(exists([Object], holds_at(gridAt(Grid, Object, Coord3, Coord4), Time))), (Coord1=Coord3;Coord1=Coord3+1;Coord1=Coord3-1), (Coord2=Coord4;Coord2=Coord4+1;Coord2=Coord4-1)
       ).
 */

 /*  not(happens(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), Time)) :-
       (   not(holds_at(gridAt(Grid, Agent, Coord1, Coord2),
                        Time))
       ;   holds_at(gridAt(Grid, Object, Coord3, Coord4),
                    Time)
       ;   not(equals(Coord1, Coord3)),
           not(equals(Coord1, Coord3+1)),
           not(equals(Coord1, Coord3-1))
       ;   not(equals(Coord2, Coord4)),
           not(equals(Coord2, Coord4+1)),
           not(equals(Coord2, Coord4-1))
       ),
       allDifferent(
                    [ Grid,
                      Agent,
                      Coord1,
                      Coord2,
                      Coord3,
                      Coord4,
                      Time,
                      Object
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(gridAt(Grid, Agent, Coord1, Coord2),
                        Time))
       ;   holds_at(gridAt(Grid, Object, Coord3, Coord4),
                    Time)
       ;   not(equals(Coord1, Coord3)),
           not(equals(Coord1, Coord3+1)),
           not(equals(Coord1, Coord3-1))
       ;   not(equals(Coord2, Coord4)),
           not(equals(Coord2, Coord4+1)),
           not(equals(Coord2, Coord4-1))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(gridAt(Grid, Agent, Coord1, Coord2)),
                    Time)
       ;   holds_at(gridAt(Grid, Object, Coord3, Coord4),
                    Time)
       ;   not(call(Coord1=Coord3)),
           not(call(Coord1=Coord3+1)),
           not(call(Coord1=Coord3-1))
       ;   not(call(Coord2=Coord4)),
           not(call(Coord2=Coord4+1)),
           not(call(Coord2=Coord4-1))
       ).
 */

 /*  [(holds_at(neg(gridAt(Grid, Agent, Coord1, Coord2)), Time);holds_at(gridAt(Grid, Object, Coord3, Coord4), Time);not(call(Coord1=Coord3)), not(call(Coord1=Coord3+1)), not(call(Coord1=Coord3-1));not(call(Coord2=Coord4)), not(call(Coord2=Coord4+1)), not(call(Coord2=Coord4-1))), allDifferent([Grid, Agent, Coord1, Coord2, Coord3, Coord4, Time, Object])] ->
       ta(Time,
          not(happens(gridWalk(Grid,
                               Agent,
                               Coord1,
                               Coord2,
                               Coord3,
                               Coord4),
                      Time))).
 */

 /*  [(holds_at(neg(gridAt(Grid, Agent, Coord1, Coord2)), Time);holds_at(gridAt(Grid, Object, Coord3, Coord4), Time);holds_at(neg(call(Coord1=Coord3)), Time), holds_at(neg(call(Coord1=Coord3+1)), Time), holds_at(neg(call(Coord1=Coord3-1)), Time);holds_at(neg(call(Coord2=Coord4)), Time), holds_at(neg(call(Coord2=Coord4+1)), Time), holds_at(neg(call(Coord2=Coord4-1)), Time)), allDifferent([Grid, Agent, Coord1, Coord2, Coord3, Coord4, Time, Object])] ->
       ta(Time,
          not(happens(gridWalk(Grid,
                               Agent,
                               Coord1,
                               Coord2,
                               Coord3,
                               Coord4),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1646
axiom(not(happens(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), Time)),
   
    [  (holds_at(neg(gridAt(Grid, Agent, Coord1, Coord2)), Time);holds_at(gridAt(Grid, Object, Coord3, Coord4), Time);holds_at(neg(call(Coord1=Coord3)), Time), holds_at(neg(call(Coord1=Coord3+1)), Time), holds_at(neg(call(Coord1=Coord3-1)), Time);holds_at(neg(call(Coord2=Coord4)), Time), holds_at(neg(call(Coord2=Coord4+1)), Time), holds_at(neg(call(Coord2=Coord4-1)), Time)),
      allDifferent(
                   [ Grid,
                     Agent,
                     Coord1,
                     Coord2,
                     Coord3,
                     Coord4,
                     Time,
                     Object
                   ])
    ]).

 /*  holds_at(gridAt(Grid, Agent, Coord1, Coord2), Time) :-
       happens(gridWalk(Grid,
                        Agent,
                        Coord1,
                        Coord2,
                        Coord3,
                        Coord4),
               Time),
       allDifferent(
                    [ Grid,
                      Agent,
                      Coord1,
                      Coord2,
                      Coord3,
                      Coord4,
                      Time,
                      Object
                    ]).
 */

 /*  [happens(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), Time), allDifferent([Grid, Agent, Coord1, Coord2, Coord3, Coord4, Time, Object])] ->
       ta(Time,
          holds_at(gridAt(Grid, Agent, Coord1, Coord2),
                   Time)).
 */
axiom(holds_at(gridAt(Grid, Agent, Coord1, Coord2), Time),
   
    [ happens(gridWalk(Grid,
                       Agent,
                       Coord1,
                       Coord2,
                       Coord3,
                       Coord4),
              Time),
      allDifferent(
                   [ Grid,
                     Agent,
                     Coord1,
                     Coord2,
                     Coord3,
                     Coord4,
                     Time,
                     Object
                   ])
    ]).

 /*  not(holds_at(gridAt(Grid, Object, Coord3, Coord4), Time)) :-
       happens(gridWalk(Grid,
                        Agent,
                        Coord1,
                        Coord2,
                        Coord3,
                        Coord4),
               Time),
       allDifferent(
                    [ Grid,
                      Agent,
                      Coord1,
                      Coord2,
                      Coord3,
                      Coord4,
                      Time,
                      Object
                    ]).
 */

 /*  [happens(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), Time), allDifferent([Grid, Agent, Coord1, Coord2, Coord3, Coord4, Time, Object])] ->
       ta(Time,
          holds_at(neg(gridAt(Grid, Object, Coord3, Coord4)),
                   Time)).
 */
axiom(holds_at(neg(gridAt(Grid, Object, Coord3, Coord4)), Time),
   
    [ happens(gridWalk(Grid,
                       Agent,
                       Coord1,
                       Coord2,
                       Coord3,
                       Coord4),
              Time),
      allDifferent(
                   [ Grid,
                     Agent,
                     Coord1,
                     Coord2,
                     Coord3,
                     Coord4,
                     Time,
                     Object
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1648
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/PolySpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @phdthesis{Cassimatis:2002,
%;   author = "Nicholas L. Cassimatis",
%;   year = "2002",
%;   title = "Polyscheme: A Cognitive Architecture for Integrating Multiple Representation and Inference Schemes",
%;   address = "Cambridge, MA",
%;   school = "Program in Media Arts and Sciences, School of Architecture and Planning, Massachusetts Institute of Technology",
%; }
%;
%; sorts

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1676
% sort object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1677
==> sort(object).

% sort xcoord: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1678
==> subsort(xcoord,integer).

% sort ycoord: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1679
==> subsort(ycoord,integer).

% sort grid
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1680
==> sort(grid).

% sort shape
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1681
==> sort(shape).

% sort color
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1682
==> sort(color).
%; constants

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1684
% shape Round,Square
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1685
==> t(shape,round).
==> t(shape,square).

% color Red,Green
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1686
==> t(color,red).
==> t(color,green).
%; predicates, fluents, and events

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1688
% predicate Equal(object,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1689
predicate(equal(Equal_Param,Equal_Ret)).
==> mpred_prop(equal(object,object),predicate).
==> meta_argtypes(equal(object,object)).

% predicate Shape(object,shape)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1690
predicate(shape(Shape_Param,Shape_Ret)).
==> mpred_prop(shape(object,shape),predicate).
==> meta_argtypes(shape(object,shape)).

% predicate Color(object,color)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1691
predicate(color(Color_Param,Color_Ret)).
==> mpred_prop(color(object,color),predicate).
==> meta_argtypes(color(object,color)).

% fluent Location(grid,object,xcoord,ycoord)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1692
fluent(location(Location_Param,
		_,
		_,
		Location_Ret)).
==> mpred_prop(location(grid,object,xcoord,ycoord),fluent).
==> meta_argtypes(location(grid,object,xcoord,ycoord)).

% event Move(grid,object,xcoord,ycoord,xcoord,ycoord)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1693
event(move(Move_Param,
	   _,
	   _,
	   _,
	   _,
	   Move_Ret)).
==> mpred_prop(move(grid,object,xcoord,ycoord,xcoord,ycoord),event).
==> meta_argtypes(move(grid,object,xcoord,ycoord,xcoord,ycoord)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1694
%; axioms
% [object1,object2]
 % Equal(object1,object2) -> Equal(object2,object1).

 /*  allDifferent([Object1, Object2]) ->
       ( equal(Object1, Object2)->equal(Object2, Object1)
       ).
 */

 /*  equal(Object2, Object1) :-
       equal(Object1, Object2),
       allDifferent([Object1, Object2]).
 */

 /*  [equal(Object1, Object2), allDifferent([Object1, Object2])] ->
       ta(Ta_Param, equal(Object2, Object1)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1696
axiom(equal(Object2, Object1),
   
    [ equal(Object1, Object2),
      allDifferent([Object1, Object2])
    ]).

 /*  not(equal(Object1, Object2)) :-
       not(equal(Object2, Object1)),
       allDifferent([Object1, Object2]).
 */

 /*  [not(equal(Object2, Object1)), allDifferent([Object1, Object2])] ->
       ta(Ta_Param3, not(equal(Object1, Object2))).
 */
axiom(not(equal(Object1, Object2)),
   
    [ not(equal(Object2, Object1)),
      allDifferent([Object1, Object2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1698
%; objects have unique shape
% [object,shape1,shape2]
% Shape(object,shape1) & Shape(object,shape2) ->
% shape1=shape2.

 /*  allDifferent([Object, Shape1, Shape2]) ->
       ( shape(Object, Shape1), shape(Object, Shape2)->Shape1=Shape2
       ).
 */

 /*  not(shape(Object, Shape1)) :-
       shape(Object, Shape2),
       not(equals(Shape1, Shape2)),
       allDifferent([Object, Shape1, Shape2]).
 */

 /*  axiom_head(Axiom_head_Ret) ->
       not(equals(Shape1, Shape2)).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       not(call(Shape1=Shape2)).
 */

 /*  [shape(Object, Shape2), not(call(Shape1=Shape2)), allDifferent([Object, Shape1, Shape2])] ->
       ta(Axiom_head_Ret, not(shape(Object, Shape1))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1701
axiom(not(shape(Object, Shape1)),
   
    [ shape(Object, Shape2),
      not(call(Shape1=Shape2)),
      allDifferent([Object, Shape1, Shape2])
    ]).

 /*  not(shape(Object, Shape2)) :-
       shape(Object, Shape1),
       not(equals(Shape1, Shape2)),
       allDifferent([Object, Shape1, Shape2]).
 */

 /*  axiom_head(Axiom_head_Ret4) ->
       not(equals(Shape1, Shape2)).
 */

 /*  fix_axiom_head(Axiom_head_Ret4) ->
       not(call(Shape1=Shape2)).
 */

 /*  [shape(Object, Shape1), not(call(Shape1=Shape2)), allDifferent([Object, Shape1, Shape2])] ->
       ta(Axiom_head_Ret4, not(shape(Object, Shape2))).
 */
axiom(not(shape(Object, Shape2)),
   
    [ shape(Object, Shape1),
      not(call(Shape1=Shape2)),
      allDifferent([Object, Shape1, Shape2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1703
%; objects have unique color
% [object,color1,color2]
% Color(object,color1) & Color(object,color2) ->
% color1=color2.

 /*  allDifferent([Object, Color1, Color2]) ->
       ( color(Object, Color1), color(Object, Color2)->Color1=Color2
       ).
 */

 /*  not(color(Object, Color1)) :-
       color(Object, Color2),
       not(equals(Color1, Color2)),
       allDifferent([Object, Color1, Color2]).
 */

 /*  axiom_head(Axiom_head_Ret) ->
       not(equals(Color1, Color2)).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       not(call(Color1=Color2)).
 */

 /*  [color(Object, Color2), not(call(Color1=Color2)), allDifferent([Object, Color1, Color2])] ->
       ta(Axiom_head_Ret, not(color(Object, Color1))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1706
axiom(not(color(Object, Color1)),
   
    [ color(Object, Color2),
      not(call(Color1=Color2)),
      allDifferent([Object, Color1, Color2])
    ]).

 /*  not(color(Object, Color2)) :-
       color(Object, Color1),
       not(equals(Color1, Color2)),
       allDifferent([Object, Color1, Color2]).
 */

 /*  axiom_head(Axiom_head_Ret4) ->
       not(equals(Color1, Color2)).
 */

 /*  fix_axiom_head(Axiom_head_Ret4) ->
       not(call(Color1=Color2)).
 */

 /*  [color(Object, Color1), not(call(Color1=Color2)), allDifferent([Object, Color1, Color2])] ->
       ta(Axiom_head_Ret4, not(color(Object, Color2))).
 */
axiom(not(color(Object, Color2)),
   
    [ color(Object, Color1),
      not(call(Color1=Color2)),
      allDifferent([Object, Color1, Color2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1708
%; if objects are the same, they have the same shape
% [object1,object2]
% Equal(object1,object2) ->
% ({shape} Shape(object1,shape) & Shape(object2,shape)).

 /*  allDifferent([Object1, Object2, Shape]) ->
       ( equal(Object1, Object2)->exists([Shape],  (shape(Object1, Shape), shape(Object2, Shape)))
       ).
 */

 /*  not(equal(Object1, Object2)) :-
       (   not(shape(Object1, Shape))
       ;   not(shape(Object2, Shape))
       ),
       allDifferent([Object1, Object2, Shape]).
 */

 /*  [(not(shape(Object1, Shape));not(shape(Object2, Shape))), allDifferent([Object1, Object2, Shape])] ->
       ta(Ta_Param, not(equal(Object1, Object2))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1711
axiom(not(equal(Object1, Object2)),
   
    [  (not(shape(Object1, Shape));not(shape(Object2, Shape))),
      allDifferent([Object1, Object2, Shape])
    ]).

 /*  shape(Object1, Shape) :-
       equal(Object1, Object2),
       allDifferent([Object1, Object2, Shape]).
 */

 /*  [equal(Object1, Object2), allDifferent([Object1, Object2, Shape])] ->
       ta(Ta_Param4, shape(Object1, Shape)).
 */
axiom(shape(Object1, Shape),
   
    [ equal(Object1, Object2),
      allDifferent([Object1, Object2, Shape])
    ]).

 /*  shape(Object2, Shape) :-
       equal(Object1, Object2),
       allDifferent([Object1, Object2, Shape]).
 */

 /*  [equal(Object1, Object2), allDifferent([Object1, Object2, Shape])] ->
       ta(Ta_Param5, shape(Object2, Shape)).
 */
axiom(shape(Object2, Shape),
   
    [ equal(Object1, Object2),
      allDifferent([Object1, Object2, Shape])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1713
%; if objects are the same, they have the same color
% [object1,object2]
% Equal(object1,object2) ->
% ({color} Color(object1,color) & Color(object2,color)).

 /*  allDifferent([Object1, Object2, Color]) ->
       ( equal(Object1, Object2)->exists([Color],  (color(Object1, Color), color(Object2, Color)))
       ).
 */

 /*  not(equal(Object1, Object2)) :-
       (   not(color(Object1, Color))
       ;   not(color(Object2, Color))
       ),
       allDifferent([Object1, Object2, Color]).
 */

 /*  [(not(color(Object1, Color));not(color(Object2, Color))), allDifferent([Object1, Object2, Color])] ->
       ta(Ta_Param, not(equal(Object1, Object2))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1716
axiom(not(equal(Object1, Object2)),
   
    [  (not(color(Object1, Color));not(color(Object2, Color))),
      allDifferent([Object1, Object2, Color])
    ]).

 /*  color(Object1, Color) :-
       equal(Object1, Object2),
       allDifferent([Object1, Object2, Color]).
 */

 /*  [equal(Object1, Object2), allDifferent([Object1, Object2, Color])] ->
       ta(Ta_Param4, color(Object1, Color)).
 */
axiom(color(Object1, Color),
   
    [ equal(Object1, Object2),
      allDifferent([Object1, Object2, Color])
    ]).

 /*  color(Object2, Color) :-
       equal(Object1, Object2),
       allDifferent([Object1, Object2, Color]).
 */

 /*  [equal(Object1, Object2), allDifferent([Object1, Object2, Color])] ->
       ta(Ta_Param5, color(Object2, Color)).
 */
axiom(color(Object2, Color),
   
    [ equal(Object1, Object2),
      allDifferent([Object1, Object2, Color])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1718
%; if objects are the same, they have the same location
% [grid,object1,object2,xcoord1,ycoord1,xcoord2,ycoord2,time]
% Equal(object1,object2) ->
% (HoldsAt(Location(grid,object1,xcoord1,ycoord1),time) &
%  HoldsAt(Location(grid,object2,xcoord2,ycoord2),time) ->
%  xcoord1=xcoord2 & ycoord1=ycoord2).

 /*  allDifferent([Object1, Object2, Grid, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2]) ->
       ( equal(Object1, Object2)->(holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time), holds_at(location(Grid, Object2, Xcoord2, Ycoord2), Time)->Xcoord1=Xcoord2, Ycoord1=Ycoord2)
       ).
 */

 /*  not(equal(Object1, Object2)) :-
       ( ( holds_at(location(Grid,
                             Object1,
                             Xcoord1,
                             Ycoord1),
                    Time),
           holds_at(location(Grid,
                             Object2,
                             Xcoord2,
                             Ycoord2),
                    Time)
         ),
         (   not(equals(Xcoord1, Xcoord2))
         ;   not(equals(Ycoord1, Ycoord2))
         )
       ),
       allDifferent(
                    [ Object1,
                      Object2,
                      Grid,
                      Xcoord1,
                      Ycoord1,
                      Time,
                      Xcoord2,
                      Ycoord2
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(Xcoord1=Xcoord2))
       ;   not(call(Ycoord1=Ycoord2))
       ).
 */

 /*  [holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time), holds_at(location(Grid, Object2, Xcoord2, Ycoord2), Time),  (not(call(Xcoord1=Xcoord2));not(call(Ycoord1=Ycoord2))), allDifferent([Object1, Object2, Grid, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time, not(equal(Object1, Object2))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1723
axiom(not(equal(Object1, Object2)),
   
    [ holds_at(location(Grid, Object1, Xcoord1, Ycoord1),
               Time),
      holds_at(location(Grid, Object2, Xcoord2, Ycoord2),
               Time),
       (not(call(Xcoord1=Xcoord2));not(call(Ycoord1=Ycoord2))),
      allDifferent(
                   [ Object1,
                     Object2,
                     Grid,
                     Xcoord1,
                     Ycoord1,
                     Time,
                     Xcoord2,
                     Ycoord2
                   ])
    ]).

 /*  not(holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time)) :-
       holds_at(location(Grid, Object2, Xcoord2, Ycoord2),
                Time),
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ),
       equal(Object1, Object2),
       allDifferent(
                    [ Object1,
                      Object2,
                      Grid,
                      Xcoord1,
                      Ycoord1,
                      Time,
                      Xcoord2,
                      Ycoord2
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(Xcoord1=Xcoord2))
       ;   not(call(Ycoord1=Ycoord2))
       ).
 */

 /*  [holds_at(location(Grid, Object2, Xcoord2, Ycoord2), Time),  (not(call(Xcoord1=Xcoord2));not(call(Ycoord1=Ycoord2))), equal(Object1, Object2), allDifferent([Object1, Object2, Grid, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object1,
                                Xcoord1,
                                Ycoord1)),
                   Time)).
 */

 /*  [holds_at(location(Grid, Object2, Xcoord2, Ycoord2), Time),  (holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2)), Time)), equal(Object1, Object2), allDifferent([Object1, Object2, Grid, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object1,
                                Xcoord1,
                                Ycoord1)),
                   Time)).
 */
axiom(holds_at(neg(location(Grid, Object1, Xcoord1, Ycoord1)), Time),
   
    [ holds_at(location(Grid, Object2, Xcoord2, Ycoord2),
               Time),
       (holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2)), Time)),
      equal(Object1, Object2),
      allDifferent(
                   [ Object1,
                     Object2,
                     Grid,
                     Xcoord1,
                     Ycoord1,
                     Time,
                     Xcoord2,
                     Ycoord2
                   ])
    ]).

 /*  not(holds_at(location(Grid, Object2, Xcoord2, Ycoord2), Time)) :-
       holds_at(location(Grid, Object1, Xcoord1, Ycoord1),
                Time),
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ),
       equal(Object1, Object2),
       allDifferent(
                    [ Object1,
                      Object2,
                      Grid,
                      Xcoord1,
                      Ycoord1,
                      Time,
                      Xcoord2,
                      Ycoord2
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(Xcoord1=Xcoord2))
       ;   not(call(Ycoord1=Ycoord2))
       ).
 */

 /*  [holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time),  (not(call(Xcoord1=Xcoord2));not(call(Ycoord1=Ycoord2))), equal(Object1, Object2), allDifferent([Object1, Object2, Grid, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object2,
                                Xcoord2,
                                Ycoord2)),
                   Time)).
 */

 /*  [holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time),  (holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2)), Time)), equal(Object1, Object2), allDifferent([Object1, Object2, Grid, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object2,
                                Xcoord2,
                                Ycoord2)),
                   Time)).
 */
axiom(holds_at(neg(location(Grid, Object2, Xcoord2, Ycoord2)), Time),
   
    [ holds_at(location(Grid, Object1, Xcoord1, Ycoord1),
               Time),
       (holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2)), Time)),
      equal(Object1, Object2),
      allDifferent(
                   [ Object1,
                     Object2,
                     Grid,
                     Xcoord1,
                     Ycoord1,
                     Time,
                     Xcoord2,
                     Ycoord2
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1725
%; object in one location at a time
% [grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
% HoldsAt(Location(grid,object,xcoord1,ycoord1),time) &
% HoldsAt(Location(grid,object,xcoord2,ycoord2),time) ->
% xcoord1=xcoord2 & ycoord1=ycoord2.

 /*  allDifferent([Grid, Object, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2]) ->
       ( holds_at(location(Grid, Object, Xcoord1, Ycoord1), Time), holds_at(location(Grid, Object, Xcoord2, Ycoord2), Time)->Xcoord1=Xcoord2, Ycoord1=Ycoord2
       ).
 */

 /*  not(holds_at(location(Grid, Object, Xcoord1, Ycoord1), Time)) :-
       holds_at(location(Grid, Object, Xcoord2, Ycoord2),
                Time),
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ),
       allDifferent(
                    [ Grid,
                      Object,
                      Xcoord1,
                      Ycoord1,
                      Time,
                      Xcoord2,
                      Ycoord2
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(Xcoord1=Xcoord2))
       ;   not(call(Ycoord1=Ycoord2))
       ).
 */

 /*  [holds_at(location(Grid, Object, Xcoord2, Ycoord2), Time),  (not(call(Xcoord1=Xcoord2));not(call(Ycoord1=Ycoord2))), allDifferent([Grid, Object, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object,
                                Xcoord1,
                                Ycoord1)),
                   Time)).
 */

 /*  [holds_at(location(Grid, Object, Xcoord2, Ycoord2), Time),  (holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2)), Time)), allDifferent([Grid, Object, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object,
                                Xcoord1,
                                Ycoord1)),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1729
axiom(holds_at(neg(location(Grid, Object, Xcoord1, Ycoord1)), Time),
   
    [ holds_at(location(Grid, Object, Xcoord2, Ycoord2),
               Time),
       (holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2)), Time)),
      allDifferent(
                   [ Grid,
                     Object,
                     Xcoord1,
                     Ycoord1,
                     Time,
                     Xcoord2,
                     Ycoord2
                   ])
    ]).

 /*  not(holds_at(location(Grid, Object, Xcoord2, Ycoord2), Time)) :-
       holds_at(location(Grid, Object, Xcoord1, Ycoord1),
                Time),
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ),
       allDifferent(
                    [ Grid,
                      Object,
                      Xcoord1,
                      Ycoord1,
                      Time,
                      Xcoord2,
                      Ycoord2
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(equals(Xcoord1, Xcoord2))
       ;   not(equals(Ycoord1, Ycoord2))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(Xcoord1=Xcoord2))
       ;   not(call(Ycoord1=Ycoord2))
       ).
 */

 /*  [holds_at(location(Grid, Object, Xcoord1, Ycoord1), Time),  (not(call(Xcoord1=Xcoord2));not(call(Ycoord1=Ycoord2))), allDifferent([Grid, Object, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object,
                                Xcoord2,
                                Ycoord2)),
                   Time)).
 */

 /*  [holds_at(location(Grid, Object, Xcoord1, Ycoord1), Time),  (holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2)), Time)), allDifferent([Grid, Object, Xcoord1, Ycoord1, Time, Xcoord2, Ycoord2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object,
                                Xcoord2,
                                Ycoord2)),
                   Time)).
 */
axiom(holds_at(neg(location(Grid, Object, Xcoord2, Ycoord2)), Time),
   
    [ holds_at(location(Grid, Object, Xcoord1, Ycoord1),
               Time),
       (holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2)), Time)),
      allDifferent(
                   [ Grid,
                     Object,
                     Xcoord1,
                     Ycoord1,
                     Time,
                     Xcoord2,
                     Ycoord2
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1731
%; objects have locations
% [grid,object,time]
% (
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1733
% {xcoord,ycoord} HoldsAt(Location(grid,object,xcoord,ycoord),time)).

 /*  exists([Xcoord,Ycoord],
    holds_at(location(Grid,Object,Xcoord,Ycoord),
   	 Time)).
 */

 /*  [] ->
       ta(Time,
          holds_at(location(Grid, Object, Xcoord, Ycoord),
                   Time)).
 */
axiom(holds_at(location(Grid, Object, Xcoord, Ycoord), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1735
%; different objects are not at same location
% [grid,object1,object2,xcoord1,ycoord1,time]
% HoldsAt(Location(grid,object1,xcoord1,ycoord1),time) &
% HoldsAt(Location(grid,object2,xcoord1,ycoord1),time) ->
% Equal(object1,object2).

 /*  allDifferent([Grid, Object1, Xcoord1, Ycoord1, Time, Object2]) ->
       ( holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time), holds_at(location(Grid, Object2, Xcoord1, Ycoord1), Time)->equal(Object1, Object2)
       ).
 */

 /*  equal(Object1, Object2) :-
       ( holds_at(location(Grid, Object1, Xcoord1, Ycoord1),
                  Time),
         holds_at(location(Grid, Object2, Xcoord1, Ycoord1),
                  Time)
       ),
       allDifferent(
                    [ Grid,
                      Object1,
                      Xcoord1,
                      Ycoord1,
                      Time,
                      Object2
                    ]).
 */

 /*  [holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time), holds_at(location(Grid, Object2, Xcoord1, Ycoord1), Time), allDifferent([Grid, Object1, Xcoord1, Ycoord1, Time, Object2])] ->
       ta(Time, equal(Object1, Object2)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1739
axiom(equal(Object1, Object2),
   
    [ holds_at(location(Grid, Object1, Xcoord1, Ycoord1),
               Time),
      holds_at(location(Grid, Object2, Xcoord1, Ycoord1),
               Time),
      allDifferent(
                   [ Grid,
                     Object1,
                     Xcoord1,
                     Ycoord1,
                     Time,
                     Object2
                   ])
    ]).

 /*  not(holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time)) :-
       holds_at(location(Grid, Object2, Xcoord1, Ycoord1),
                Time),
       not(equal(Object1, Object2)),
       allDifferent(
                    [ Grid,
                      Object1,
                      Xcoord1,
                      Ycoord1,
                      Time,
                      Object2
                    ]).
 */

 /*  [holds_at(location(Grid, Object2, Xcoord1, Ycoord1), Time), not(equal(Object1, Object2)), allDifferent([Grid, Object1, Xcoord1, Ycoord1, Time, Object2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object1,
                                Xcoord1,
                                Ycoord1)),
                   Time)).
 */
axiom(holds_at(neg(location(Grid, Object1, Xcoord1, Ycoord1)), Time),
   
    [ holds_at(location(Grid, Object2, Xcoord1, Ycoord1),
               Time),
      not(equal(Object1, Object2)),
      allDifferent(
                   [ Grid,
                     Object1,
                     Xcoord1,
                     Ycoord1,
                     Time,
                     Object2
                   ])
    ]).

 /*  not(holds_at(location(Grid, Object2, Xcoord1, Ycoord1), Time)) :-
       holds_at(location(Grid, Object1, Xcoord1, Ycoord1),
                Time),
       not(equal(Object1, Object2)),
       allDifferent(
                    [ Grid,
                      Object1,
                      Xcoord1,
                      Ycoord1,
                      Time,
                      Object2
                    ]).
 */

 /*  [holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time), not(equal(Object1, Object2)), allDifferent([Grid, Object1, Xcoord1, Ycoord1, Time, Object2])] ->
       ta(Time,
          holds_at(neg(location(Grid,
                                Object2,
                                Xcoord1,
                                Ycoord1)),
                   Time)).
 */
axiom(holds_at(neg(location(Grid, Object2, Xcoord1, Ycoord1)), Time),
   
    [ holds_at(location(Grid, Object1, Xcoord1, Ycoord1),
               Time),
      not(equal(Object1, Object2)),
      allDifferent(
                   [ Grid,
                     Object1,
                     Xcoord1,
                     Ycoord1,
                     Time,
                     Object2
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1741
%; moving to a location causes an object to be at that location
% [grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
% Initiates(Move(grid,object,xcoord1,ycoord1,xcoord2,ycoord2),
%           Location(grid,object,xcoord2,ycoord2),
%           time).

 /*  [] ->
       ta(Time,
          initiates(move(Grid,
                         Object,
                         Xcoord1,
                         Ycoord1,
                         Xcoord2,
                         Ycoord2),
                    location(Grid, Object, Xcoord2, Ycoord2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1745
axiom(initiates(move(Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2), location(Grid, Object, Xcoord2, Ycoord2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1747
%; moving to a location causes the object no longer to be at its previous
%; location
% [grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1750
% Terminates(Move(grid,object,xcoord1,ycoord1,xcoord2,ycoord2),
%            Location(grid,object,xcoord1,ycoord1),
%            time).

 /*  [] ->
       ta(Time,
          terminates(move(Grid,
                          Object,
                          Xcoord1,
                          Ycoord1,
                          Xcoord2,
                          Ycoord2),
                     location(Grid,
                              Object,
                              Xcoord1,
                              Ycoord1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1752
axiom(terminates(move(Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2), location(Grid, Object, Xcoord1, Ycoord1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1754
%;; allow diagonal movements
%;[grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
%;Happens(Move(grid,object,xcoord1,ycoord1,xcoord2,ycoord2),time) ->
%;HoldsAt(Location(grid,object,xcoord1,ycoord1),time) &
%;(xcoord1=xcoord2 |
%; xcoord1=xcoord2+1 |
%; xcoord1=xcoord2-1) &
%;(ycoord1=ycoord2 |
%; ycoord1=ycoord2+1 |
%; ycoord1=ycoord2-1).
%; only allow right angle movements
% [grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1767
% Happens(Move(grid,object,xcoord1,ycoord1,xcoord2,ycoord2),time) ->
% HoldsAt(Location(grid,object,xcoord1,ycoord1),time) &
% ((xcoord1=xcoord2 & (ycoord1=ycoord2+1 | ycoord1=ycoord2-1)) |
%  (ycoord1=ycoord2 & (xcoord1=xcoord2+1 | xcoord1=xcoord2-1))).

 /*  allDifferent([Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2, Time]) ->
       ( happens(move(Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2), Time)->holds_at(location(Grid, Object, Xcoord1, Ycoord1), Time), (Xcoord1=Xcoord2, (Ycoord1=Ycoord2+1;Ycoord1=Ycoord2-1);Ycoord1=Ycoord2, (Xcoord1=Xcoord2+1;Xcoord1=Xcoord2-1))
       ).
 */

 /*  not(happens(move(Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2), Time)) :-
       (   not(holds_at(location(Grid,
                                 Object,
                                 Xcoord1,
                                 Ycoord1),
                        Time))
       ;   (   not(equals(Xcoord1, Xcoord2))
           ;   not(equals(Ycoord1, Ycoord2+1)),
               not(equals(Ycoord1, Ycoord2-1))
           ),
           (   not(equals(Ycoord1, Ycoord2))
           ;   not(equals(Xcoord1, Xcoord2+1)),
               not(equals(Xcoord1, Xcoord2-1))
           )
       ),
       allDifferent(
                    [ Grid,
                      Object,
                      Xcoord1,
                      Ycoord1,
                      Xcoord2,
                      Ycoord2,
                      Time
                    ]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(location(Grid,
                                 Object,
                                 Xcoord1,
                                 Ycoord1),
                        Time))
       ;   (   not(equals(Xcoord1, Xcoord2))
           ;   not(equals(Ycoord1, Ycoord2+1)),
               not(equals(Ycoord1, Ycoord2-1))
           ),
           (   not(equals(Ycoord1, Ycoord2))
           ;   not(equals(Xcoord1, Xcoord2+1)),
               not(equals(Xcoord1, Xcoord2-1))
           )
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(location(Grid,
                                 Object,
                                 Xcoord1,
                                 Ycoord1)),
                    Time)
       ;   (   not(call(Xcoord1=Xcoord2))
           ;   not(call(Ycoord1=Ycoord2+1)),
               not(call(Ycoord1=Ycoord2-1))
           ),
           (   not(call(Ycoord1=Ycoord2))
           ;   not(call(Xcoord1=Xcoord2+1)),
               not(call(Xcoord1=Xcoord2-1))
           )
       ).
 */

 /*  [(holds_at(neg(location(Grid, Object, Xcoord1, Ycoord1)), Time);(not(call(Xcoord1=Xcoord2));not(call(Ycoord1=Ycoord2+1)), not(call(Ycoord1=Ycoord2-1))), (not(call(Ycoord1=Ycoord2));not(call(Xcoord1=Xcoord2+1)), not(call(Xcoord1=Xcoord2-1)))), allDifferent([Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2, Time])] ->
       ta(Time,
          not(happens(move(Grid,
                           Object,
                           Xcoord1,
                           Ycoord1,
                           Xcoord2,
                           Ycoord2),
                      Time))).
 */

 /*  [(holds_at(neg(location(Grid, Object, Xcoord1, Ycoord1)), Time);(holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2+1)), Time), holds_at(neg(call(Ycoord1=Ycoord2-1)), Time)), (holds_at(neg(call(Ycoord1=Ycoord2)), Time);holds_at(neg(call(Xcoord1=Xcoord2+1)), Time), holds_at(neg(call(Xcoord1=Xcoord2-1)), Time))), allDifferent([Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2, Time])] ->
       ta(Time,
          not(happens(move(Grid,
                           Object,
                           Xcoord1,
                           Ycoord1,
                           Xcoord2,
                           Ycoord2),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1770
axiom(not(happens(move(Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2), Time)),
   
    [  (holds_at(neg(location(Grid, Object, Xcoord1, Ycoord1)), Time);(holds_at(neg(call(Xcoord1=Xcoord2)), Time);holds_at(neg(call(Ycoord1=Ycoord2+1)), Time), holds_at(neg(call(Ycoord1=Ycoord2-1)), Time)), (holds_at(neg(call(Ycoord1=Ycoord2)), Time);holds_at(neg(call(Xcoord1=Xcoord2+1)), Time), holds_at(neg(call(Xcoord1=Xcoord2-1)), Time))),
      allDifferent(
                   [ Grid,
                     Object,
                     Xcoord1,
                     Ycoord1,
                     Xcoord2,
                     Ycoord2,
                     Time
                   ])
    ]).

 /*  holds_at(location(Grid, Object, Xcoord1, Ycoord1), Time) :-
       happens(move(Grid,
                    Object,
                    Xcoord1,
                    Ycoord1,
                    Xcoord2,
                    Ycoord2),
               Time),
       allDifferent(
                    [ Grid,
                      Object,
                      Xcoord1,
                      Ycoord1,
                      Xcoord2,
                      Ycoord2,
                      Time
                    ]).
 */

 /*  [happens(move(Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2), Time), allDifferent([Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2, Time])] ->
       ta(Time,
          holds_at(location(Grid, Object, Xcoord1, Ycoord1),
                   Time)).
 */
axiom(holds_at(location(Grid, Object, Xcoord1, Ycoord1), Time),
   
    [ happens(move(Grid,
                   Object,
                   Xcoord1,
                   Ycoord1,
                   Xcoord2,
                   Ycoord2),
              Time),
      allDifferent(
                   [ Grid,
                     Object,
                     Xcoord1,
                     Ycoord1,
                     Xcoord2,
                     Ycoord2,
                     Time
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1772
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/HandTo.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1791
% event HandTo(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1792
event(handTo(HandTo_Param,_,HandTo_Ret)).
==> mpred_prop(handTo(agent,agent,physobj),event).
==> meta_argtypes(handTo(agent,agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1793
% [agent1,agent2,physobj,time]
% Initiates(HandTo(agent1,agent2,physobj),
%           Holding(agent2,physobj),
%           time).

 /*  [] ->
       ta(Time,
          initiates(handTo(Agent1, Agent2, Physobj),
                    holding(Agent2, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1796
axiom(initiates(handTo(Agent1, Agent2, Physobj), holding(Agent2, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1798
% [agent1,agent2,physobj,time]
% Terminates(HandTo(agent1,agent2,physobj),
%            Holding(agent1,physobj),
%            time).

 /*  [] ->
       ta(Time,
          terminates(handTo(Agent1, Agent2, Physobj),
                     holding(Agent1, Physobj),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1801
axiom(terminates(handTo(Agent1, Agent2, Physobj), holding(Agent1, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1803
% [agent1,agent2,physobj,time]
% Happens(HandTo(agent1,agent2,physobj),time) ->
% HoldsAt(Holding(agent1,physobj),time).

 /*  allDifferent([Agent1, Agent2, Physobj, Time]) ->
       ( happens(handTo(Agent1, Agent2, Physobj), Time)->holds_at(holding(Agent1, Physobj), Time)
       ).
 */

 /*  holds_at(holding(Agent1, Physobj), Time) :-
       happens(handTo(Agent1, Agent2, Physobj), Time),
       allDifferent([Agent1, Agent2, Physobj, Time]).
 */

 /*  [happens(handTo(Agent1, Agent2, Physobj), Time), allDifferent([Agent1, Agent2, Physobj, Time])] ->
       ta(Time, holds_at(holding(Agent1, Physobj), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1805
axiom(holds_at(holding(Agent1, Physobj), Time),
   
    [ happens(handTo(Agent1, Agent2, Physobj), Time),
      allDifferent([Agent1, Agent2, Physobj, Time])
    ]).

 /*  not(happens(handTo(Agent1, Agent2, Physobj), Time)) :-
       not(holds_at(holding(Agent1, Physobj), Time)),
       allDifferent([Agent1, Agent2, Physobj, Time]).
 */

 /*  [holds_at(neg(holding(Agent1, Physobj)), Time), allDifferent([Agent1, Agent2, Physobj, Time])] ->
       ta(Time,
          not(happens(handTo(Agent1, Agent2, Physobj), Time))).
 */
axiom(not(happens(handTo(Agent1, Agent2, Physobj), Time)),
   
    [ holds_at(neg(holding(Agent1, Physobj)), Time),
      allDifferent([Agent1, Agent2, Physobj, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1807
% event ShakeHands(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1808
event(shakeHands(ShakeHands_Param,ShakeHands_Ret)).
==> mpred_prop(shakeHands(agent,agent),event).
==> meta_argtypes(shakeHands(agent,agent)).

% event WriteOn(agent,paper,pen)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1810
event(writeOn(WriteOn_Param,_,WriteOn_Ret)).
==> mpred_prop(writeOn(agent,paper,pen),event).
==> meta_argtypes(writeOn(agent,paper,pen)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1813
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Container.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%;
%; Container: container
%;
%; linkage to OTSpace(M):
% [agent,container1,container2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1833
% Happens(TakeOutOf(agent,container1,container2),time) ->
% HoldsAt(ContainerIsOpen(container2),time).

 /*  allDifferent([Agent, Container1, Container2, Time]) ->
       ( happens(takeOutOf(Agent, Container1, Container2), Time)->holds_at(containerIsOpen(Container2), Time)
       ).
 */

 /*  holds_at(containerIsOpen(Container2), Time) :-
       happens(takeOutOf(Agent, Container1, Container2),
               Time),
       allDifferent([Agent, Container1, Container2, Time]).
 */

 /*  [happens(takeOutOf(Agent, Container1, Container2), Time), allDifferent([Agent, Container1, Container2, Time])] ->
       ta(Time, holds_at(containerIsOpen(Container2), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1834
axiom(holds_at(containerIsOpen(Container2), Time),
   
    [ happens(takeOutOf(Agent, Container1, Container2),
              Time),
      allDifferent([Agent, Container1, Container2, Time])
    ]).

 /*  not(happens(takeOutOf(Agent, Container1, Container2), Time)) :-
       not(holds_at(containerIsOpen(Container2), Time)),
       allDifferent([Agent, Container1, Container2, Time]).
 */

 /*  [holds_at(neg(containerIsOpen(Container2)), Time), allDifferent([Agent, Container1, Container2, Time])] ->
       ta(Time,
          not(happens(takeOutOf(Agent, Container1, Container2),
                      Time))).
 */
axiom(not(happens(takeOutOf(Agent, Container1, Container2), Time)),
   
    [ holds_at(neg(containerIsOpen(Container2)), Time),
      allDifferent([Agent, Container1, Container2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1836
% [agent,container1,container2,time]
% Happens(PutInside(agent,container1,container2),time) ->
% HoldsAt(ContainerIsOpen(container2),time).

 /*  allDifferent([Agent, Container1, Container2, Time]) ->
       ( happens(putInside(Agent, Container1, Container2), Time)->holds_at(containerIsOpen(Container2), Time)
       ).
 */

 /*  holds_at(containerIsOpen(Container2), Time) :-
       happens(putInside(Agent, Container1, Container2),
               Time),
       allDifferent([Agent, Container1, Container2, Time]).
 */

 /*  [happens(putInside(Agent, Container1, Container2), Time), allDifferent([Agent, Container1, Container2, Time])] ->
       ta(Time, holds_at(containerIsOpen(Container2), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1838
axiom(holds_at(containerIsOpen(Container2), Time),
   
    [ happens(putInside(Agent, Container1, Container2),
              Time),
      allDifferent([Agent, Container1, Container2, Time])
    ]).

 /*  not(happens(putInside(Agent, Container1, Container2), Time)) :-
       not(holds_at(containerIsOpen(Container2), Time)),
       allDifferent([Agent, Container1, Container2, Time]).
 */

 /*  [holds_at(neg(containerIsOpen(Container2)), Time), allDifferent([Agent, Container1, Container2, Time])] ->
       ta(Time,
          not(happens(putInside(Agent, Container1, Container2),
                      Time))).
 */
axiom(not(happens(putInside(Agent, Container1, Container2), Time)),
   
    [ holds_at(neg(containerIsOpen(Container2)), Time),
      allDifferent([Agent, Container1, Container2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1840
%; agent opens container.

% event ContainerOpen(agent,container)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1842
event(containerOpen(ContainerOpen_Param,ContainerOpen_Ret)).
==> mpred_prop(containerOpen(agent,container),event).
==> meta_argtypes(containerOpen(agent,container)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1843
%; agent closes container.

% event ContainerClose(agent,container)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1845
event(containerClose(ContainerClose_Param,
		     ContainerClose_Ret)).
==> mpred_prop(containerClose(agent,container),event).
==> meta_argtypes(containerClose(agent,container)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1846
%; container is open.

% fluent ContainerIsOpen(container)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1848
fluent(containerIsOpen(ContainerIsOpen_Ret)).
==> mpred_prop(containerIsOpen(container),fluent).
==> meta_argtypes(containerIsOpen(container)).

% fluent ContainerClosed(container)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1850
fluent(containerClosed(ContainerClosed_Ret)).
==> mpred_prop(containerClosed(container),fluent).
==> meta_argtypes(containerClosed(container)).

% noninertial ContainerClosed
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1851
==> noninertial(containerClosed).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1852
% [container,time]
% HoldsAt(ContainerClosed(container),time) <->
% !HoldsAt(ContainerIsOpen(container),time).

 /*  holds_at(containerClosed(Container), Time) <->
       holds_at(neg(containerIsOpen(Container)), Time).
 */

 /*  [holds_at, containerClosed] <->
       [holds_at, neg, containerIsOpen].
 */

 /*  allDifferent([Container, Time]) ->
       ( holds_at(containerClosed(Container), Time)->holds_at(neg(containerIsOpen(Container)), Time)
       ).
 */

 /*  holds_at(neg(containerIsOpen(Container)), Time) :-
       holds_at(containerClosed(Container), Time),
       allDifferent([Container, Time]).
 */

 /*  [holds_at(containerClosed(Container), Time), allDifferent([Container, Time])] ->
       ta(Time, holds_at(neg(containerIsOpen(Container)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1854
axiom(holds_at(neg(containerIsOpen(Container)), Time),
   
    [ holds_at(containerClosed(Container), Time),
      allDifferent([Container, Time])
    ]).

 /*  not(holds_at(containerClosed(Container), Time)) :-
       not(holds_at(neg(containerIsOpen(Container)), Time)),
       allDifferent([Container, Time]).
 */

 /*  [holds_at(neg(neg(containerIsOpen(Container))), Time), allDifferent([Container, Time])] ->
       ta(Time, holds_at(neg(containerClosed(Container)), Time)).
 */
axiom(holds_at(neg(containerClosed(Container)), Time),
   
    [ holds_at(neg(neg(containerIsOpen(Container))), Time),
      allDifferent([Container, Time])
    ]).

 /*  allDifferent([Container, Time]) ->
       ( holds_at(neg(containerIsOpen(Container)), Time)->holds_at(containerClosed(Container), Time)
       ).
 */

 /*  holds_at(containerClosed(Container), Time) :-
       holds_at(neg(containerIsOpen(Container)), Time),
       allDifferent([Container, Time]).
 */

 /*  [holds_at(neg(containerIsOpen(Container)), Time), allDifferent([Container, Time])] ->
       ta(Time, holds_at(containerClosed(Container), Time)).
 */
axiom(holds_at(containerClosed(Container), Time),
   
    [ holds_at(neg(containerIsOpen(Container)), Time),
      allDifferent([Container, Time])
    ]).

 /*  not(holds_at(neg(containerIsOpen(Container)), Time)) :-
       not(holds_at(containerClosed(Container), Time)),
       allDifferent([Container, Time]).
 */

 /*  [holds_at(neg(containerClosed(Container)), Time), allDifferent([Container, Time])] ->
       ta(Time,
          holds_at(neg(neg(containerIsOpen(Container))), Time)).
 */
axiom(holds_at(neg(neg(containerIsOpen(Container))), Time),
   
    [ holds_at(neg(containerClosed(Container)), Time),
      allDifferent([Container, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1856
%; A precondition axiom states that
%; for an agent to open a container,
%; the agent must be awake,
%; the container must not already be open, and
%; the agent must be holding the container.
% [agent,container,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1862
% Happens(ContainerOpen(agent,container),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(ContainerIsOpen(container),time) &
% HoldsAt(Holding(agent,container),time).

 /*  allDifferent([Agent, Container, Time]) ->
       ( happens(containerOpen(Agent, Container), Time)->holds_at(awake(Agent), Time), holds_at(neg(containerIsOpen(Container)), Time), holds_at(holding(Agent, Container), Time)
       ).
 */

 /*  not(happens(containerOpen(Agent, Container), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(neg(containerIsOpen(Container)), Time))
       ;   not(holds_at(holding(Agent, Container), Time))
       ),
       allDifferent([Agent, Container, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(neg(containerIsOpen(Container)), Time))
       ;   not(holds_at(holding(Agent, Container), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(neg(containerIsOpen(Container))), Time)
       ;   holds_at(neg(holding(Agent, Container)), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(neg(containerIsOpen(Container))), Time);holds_at(neg(holding(Agent, Container)), Time)), allDifferent([Agent, Container, Time])] ->
       ta(Time,
          not(happens(containerOpen(Agent, Container), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1865
axiom(not(happens(containerOpen(Agent, Container), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(neg(containerIsOpen(Container))), Time);holds_at(neg(holding(Agent, Container)), Time)),
      allDifferent([Agent, Container, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(containerOpen(Agent, Container), Time),
       allDifferent([Agent, Container, Time]).
 */

 /*  [happens(containerOpen(Agent, Container), Time), allDifferent([Agent, Container, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(containerOpen(Agent, Container), Time),
      allDifferent([Agent, Container, Time])
    ]).

 /*  holds_at(neg(containerIsOpen(Container)), Time) :-
       happens(containerOpen(Agent, Container), Time),
       allDifferent([Agent, Container, Time]).
 */

 /*  [happens(containerOpen(Agent, Container), Time), allDifferent([Agent, Container, Time])] ->
       ta(Time, holds_at(neg(containerIsOpen(Container)), Time)).
 */
axiom(holds_at(neg(containerIsOpen(Container)), Time),
   
    [ happens(containerOpen(Agent, Container), Time),
      allDifferent([Agent, Container, Time])
    ]).

 /*  holds_at(holding(Agent, Container), Time) :-
       happens(containerOpen(Agent, Container), Time),
       allDifferent([Agent, Container, Time]).
 */

 /*  [happens(containerOpen(Agent, Container), Time), allDifferent([Agent, Container, Time])] ->
       ta(Time, holds_at(holding(Agent, Container), Time)).
 */
axiom(holds_at(holding(Agent, Container), Time),
   
    [ happens(containerOpen(Agent, Container), Time),
      allDifferent([Agent, Container, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1867
%; An effect axiom states that
%; if an agent opens a container,
%; the container will be open:
% [agent,container,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1871
% Initiates(ContainerOpen(agent,container),ContainerIsOpen(container),time).

 /*  [] ->
       ta(Time,
          initiates(containerOpen(Agent, Container),
                    containerIsOpen(Container),
                    Time)).
 */
axiom(initiates(containerOpen(Agent, Container), containerIsOpen(Container), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1873
%; A precondition axiom states that
%; for an agent to close a container,
%; the agent must be awake,
%; the container must be open, and
%; the agent must be holding the container.
% [agent,container,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1879
% Happens(ContainerClose(agent,container),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(ContainerIsOpen(container),time) &
% HoldsAt(Holding(agent,container),time).

 /*  allDifferent([Agent, Container, Time]) ->
       ( happens(containerClose(Agent, Container), Time)->holds_at(awake(Agent), Time), holds_at(containerIsOpen(Container), Time), holds_at(holding(Agent, Container), Time)
       ).
 */

 /*  not(happens(containerClose(Agent, Container), Time)) :-
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(containerIsOpen(Container), Time))
       ;   not(holds_at(holding(Agent, Container), Time))
       ),
       allDifferent([Agent, Container, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(awake(Agent), Time))
       ;   not(holds_at(containerIsOpen(Container), Time))
       ;   not(holds_at(holding(Agent, Container), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(awake(Agent)), Time)
       ;   holds_at(neg(containerIsOpen(Container)), Time)
       ;   holds_at(neg(holding(Agent, Container)), Time)
       ).
 */

 /*  [(holds_at(neg(awake(Agent)), Time);holds_at(neg(containerIsOpen(Container)), Time);holds_at(neg(holding(Agent, Container)), Time)), allDifferent([Agent, Container, Time])] ->
       ta(Time,
          not(happens(containerClose(Agent, Container), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1882
axiom(not(happens(containerClose(Agent, Container), Time)),
   
    [  (holds_at(neg(awake(Agent)), Time);holds_at(neg(containerIsOpen(Container)), Time);holds_at(neg(holding(Agent, Container)), Time)),
      allDifferent([Agent, Container, Time])
    ]).

 /*  holds_at(awake(Agent), Time) :-
       happens(containerClose(Agent, Container), Time),
       allDifferent([Agent, Container, Time]).
 */

 /*  [happens(containerClose(Agent, Container), Time), allDifferent([Agent, Container, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [ happens(containerClose(Agent, Container), Time),
      allDifferent([Agent, Container, Time])
    ]).

 /*  holds_at(containerIsOpen(Container), Time) :-
       happens(containerClose(Agent, Container), Time),
       allDifferent([Agent, Container, Time]).
 */

 /*  [happens(containerClose(Agent, Container), Time), allDifferent([Agent, Container, Time])] ->
       ta(Time, holds_at(containerIsOpen(Container), Time)).
 */
axiom(holds_at(containerIsOpen(Container), Time),
   
    [ happens(containerClose(Agent, Container), Time),
      allDifferent([Agent, Container, Time])
    ]).

 /*  holds_at(holding(Agent, Container), Time) :-
       happens(containerClose(Agent, Container), Time),
       allDifferent([Agent, Container, Time]).
 */

 /*  [happens(containerClose(Agent, Container), Time), allDifferent([Agent, Container, Time])] ->
       ta(Time, holds_at(holding(Agent, Container), Time)).
 */
axiom(holds_at(holding(Agent, Container), Time),
   
    [ happens(containerClose(Agent, Container), Time),
      allDifferent([Agent, Container, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1884
%; An effect axiom states that
%; if an agent closes a container,
%; the container will no longer be open:
% [agent,container,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1888
% Terminates(ContainerClose(agent,container),ContainerIsOpen(container),time).

 /*  [] ->
       ta(Time,
          terminates(containerClose(Agent, Container),
                     containerIsOpen(Container),
                     Time)).
 */
axiom(terminates(containerClose(Agent, Container), containerIsOpen(Container), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1890
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/SpeechAct.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; The SpeechAct representation deals with a few speech acts
%; \fullcite{Searle:1969}.
%;
%; @book{Searle:1969,
%;   author = "John R. Searle",
%;   year = "1969",
%;   title = "Speech Acts: An Essay in the Philosophy of Language",
%;   address = "Cambridge",
%;   publisher = "Cambridge University Press",
%; }
%;
%; We handle
%; the illocutionary acts of
%; inviting someone into one's house (a form of request) and
%; greeting someone,
%; and the expressive speech act of crying for joy.
%;
%; inviting in
%; agent1 invites agent2 into room.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1929
% event InviteIn(agent,agent,room)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1930
event(inviteIn(InviteIn_Param,_,InviteIn_Ret)).
==> mpred_prop(inviteIn(agent,agent,room),event).
==> meta_argtypes(inviteIn(agent,agent,room)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1930
%; agent1 is invited into room by agent2.

% fluent InvitedIn(agent,room,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1932
fluent(invitedIn(InvitedIn_Param,_,InvitedIn_Ret)).
==> mpred_prop(invitedIn(agent,room,agent),fluent).
==> meta_argtypes(invitedIn(agent,room,agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1933
%; A precondition axiom states that for
%; an agent to invite another agent into a room,
%; the first agent must be in the room and
%; there must be an outside area such that
%; the second agent is at the outside area and
%; the outside area is adjacent to the room:
% [agent1,agent2,room,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1940
% Happens(InviteIn(agent1,agent2,room),time) ->
% HoldsAt(At(agent1,room),time) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1942
% {outside}% 
% HoldsAt(At(agent2,outside),time) &
% Adjacent(room,outside).

 /*  exists([Outside],
    happens(inviteIn(Agent1, Agent2, Room), Time) ->
       holds_at(at(Agent1, Room), Time),
       holds_at(at(Agent2, Outside), Time),
       adjacent(Room, Outside)).
 */

 /*  not(happens(inviteIn(Agent1, Agent2, Room), Time)) :-
       (   not(holds_at(at(Agent1, Room), Time))
       ;   not(holds_at(at(Agent2, Outside), Time))
       ;   not(adjacent(Room, Outside))
       ),
       some(Outside,
            '$kolem_Fn_215'(Agent1, Agent2, Room, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent1, Room), Time))
       ;   not(holds_at(at(Agent2, Outside), Time))
       ;   not(adjacent(Room, Outside))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent1, Room)), Time)
       ;   holds_at(neg(at(Agent2, Outside)), Time)
       ;   not(adjacent(Room, Outside))
       ).
 */

 /*  [(holds_at(neg(at(Agent1, Room)), Time);holds_at(neg(at(Agent2, Outside)), Time);not(adjacent(Room, Outside))), some(Outside, '$kolem_Fn_215'(Agent1, Agent2, Room, Time))] ->
       ta(Time,
          not(happens(inviteIn(Agent1, Agent2, Room), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1944
axiom(not(happens(inviteIn(Agent1, Agent2, Room), Time)),
   
    [  (holds_at(neg(at(Agent1, Room)), Time);holds_at(neg(at(Agent2, Outside)), Time);not(adjacent(Room, Outside))),
      some(Outside,
           '$kolem_Fn_215'(Agent1, Agent2, Room, Time))
    ]).

 /*  holds_at(at(Agent1, Room), Time) :-
       happens(inviteIn(Agent1, Agent2, Room), Time),
       some(Outside,
            '$kolem_Fn_215'(Agent1, Agent2, Room, Time)).
 */

 /*  [happens(inviteIn(Agent1, Agent2, Room), Time), some(Outside, '$kolem_Fn_215'(Agent1, Agent2, Room, Time))] ->
       ta(Time, holds_at(at(Agent1, Room), Time)).
 */
axiom(holds_at(at(Agent1, Room), Time),
   
    [ happens(inviteIn(Agent1, Agent2, Room), Time),
      some(Outside,
           '$kolem_Fn_215'(Agent1, Agent2, Room, Time))
    ]).

 /*  holds_at(at(Agent2, Outside), Time) :-
       happens(inviteIn(Agent1, Agent2, Room), Time),
       some(Outside,
            '$kolem_Fn_215'(Agent1, Agent2, Room, Time)).
 */

 /*  [happens(inviteIn(Agent1, Agent2, Room), Time), some(Outside, '$kolem_Fn_215'(Agent1, Agent2, Room, Time))] ->
       ta(Time, holds_at(at(Agent2, Outside), Time)).
 */
axiom(holds_at(at(Agent2, Outside), Time),
   
    [ happens(inviteIn(Agent1, Agent2, Room), Time),
      some(Outside,
           '$kolem_Fn_215'(Agent1, Agent2, Room, Time))
    ]).

 /*  adjacent(Room, Outside) :-
       happens(inviteIn(Agent1, Agent2, Room), Time),
       some(Outside,
            '$kolem_Fn_215'(Agent1, Agent2, Room, Time)).
 */

 /*  [happens(inviteIn(Agent1, Agent2, Room), Time), some(Outside, '$kolem_Fn_215'(Agent1, Agent2, Room, Time))] ->
       ta(Time, adjacent(Room, Outside)).
 */
axiom(adjacent(Room, Outside),
   
    [ happens(inviteIn(Agent1, Agent2, Room), Time),
      some(Outside,
           '$kolem_Fn_215'(Agent1, Agent2, Room, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1946
%; An effect axiom states that if
%; an agent invites another agent into a room,
%; the second agent will be invited into the room by the first agent:
% [agent1,agent2,room,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1950
% Initiates(InviteIn(agent1,agent2,room),
%           InvitedIn(agent2,room,agent1),
%           time).

 /*  [] ->
       ta(Time,
          initiates(inviteIn(Agent1, Agent2, Room),
                    invitedIn(Agent2, Room, Agent1),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1952
axiom(initiates(inviteIn(Agent1, Agent2, Room), invitedIn(Agent2, Room, Agent1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1954
%; agent intends to walk into room.

% event IntendToWalkIn(agent,room)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1956
event(intendToWalkIn(IntendToWalkIn_Param,
		     IntendToWalkIn_Ret)).
==> mpred_prop(intendToWalkIn(agent,room),event).
==> meta_argtypes(intendToWalkIn(agent,room)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1956
%; agent has the intention to walk into room.

% fluent IntentionToWalkIn(agent,room)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1958
fluent(intentionToWalkIn(IntentionToWalkIn_Param,
			 IntentionToWalkIn_Ret)).
==> mpred_prop(intentionToWalkIn(agent,room),fluent).
==> meta_argtypes(intentionToWalkIn(agent,room)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1958
%; agent acts on the intention to walk into room.

% fluent ActOnIntentionToWalkIn(agent,room)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1960
fluent(actOnIntentionToWalkIn(ActOnIntentionToWalkIn_Param,
			      ActOnIntentionToWalkIn_Ret)).
==> mpred_prop(actOnIntentionToWalkIn(agent,room),fluent).
==> meta_argtypes(actOnIntentionToWalkIn(agent,room)).

% noninertial ActOnIntentionToWalkIn
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1961
==> noninertial(actOnIntentionToWalkIn).
%; A trigger axiom states that
%; if an agent is invited into a room by another agent,
%; the first agent likes the second agent, and
%; the first agent does not already have the intention to
%; walk into the room,
%; the first agent intends to walk into the room:
% [agent1,agent2,room,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1969
% HoldsAt(InvitedIn(agent1,room,agent2),time) &
% HoldsAt(Like(agent1,agent2),time) &
% !HoldsAt(IntentionToWalkIn(agent1,room),time) ->
% Happens(IntendToWalkIn(agent1,room),time).

 /*  allDifferent([Agent1, Room, Agent2, Time]) ->
       ( holds_at(invitedIn(Agent1, Room, Agent2), Time), holds_at(like(Agent1, Agent2), Time), holds_at(neg(intentionToWalkIn(Agent1, Room)), Time)->happens(intendToWalkIn(Agent1, Room), Time)
       ).
 */

 /*  happens(intendToWalkIn(Agent1, Room), Time) :-
       ( holds_at(invitedIn(Agent1, Room, Agent2), Time),
         holds_at(like(Agent1, Agent2), Time),
         holds_at(neg(intentionToWalkIn(Agent1, Room)), Time)
       ),
       allDifferent([Agent1, Room, Agent2, Time]).
 */

 /*  [holds_at(invitedIn(Agent1, Room, Agent2), Time), holds_at(like(Agent1, Agent2), Time), holds_at(neg(intentionToWalkIn(Agent1, Room)), Time), allDifferent([Agent1, Room, Agent2, Time])] ->
       ta(Time, happens(intendToWalkIn(Agent1, Room), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1972
axiom(happens(intendToWalkIn(Agent1, Room), Time),
   
    [ holds_at(invitedIn(Agent1, Room, Agent2), Time),
      holds_at(like(Agent1, Agent2), Time),
      holds_at(neg(intentionToWalkIn(Agent1, Room)), Time),
      allDifferent([Agent1, Room, Agent2, Time])
    ]).

 /*  not(holds_at(invitedIn(Agent1, Room, Agent2), Time)) :-
       ( holds_at(like(Agent1, Agent2), Time),
         holds_at(neg(intentionToWalkIn(Agent1, Room)), Time)
       ),
       not(happens(intendToWalkIn(Agent1, Room), Time)),
       allDifferent([Agent1, Room, Agent2, Time]).
 */

 /*  [holds_at(like(Agent1, Agent2), Time), holds_at(neg(intentionToWalkIn(Agent1, Room)), Time), not(happens(intendToWalkIn(Agent1, Room), Time)), allDifferent([Agent1, Room, Agent2, Time])] ->
       ta(Time,
          holds_at(neg(invitedIn(Agent1, Room, Agent2)),
                   Time)).
 */
axiom(holds_at(neg(invitedIn(Agent1, Room, Agent2)), Time),
   
    [ holds_at(like(Agent1, Agent2), Time),
      holds_at(neg(intentionToWalkIn(Agent1, Room)), Time),
      not(happens(intendToWalkIn(Agent1, Room), Time)),
      allDifferent([Agent1, Room, Agent2, Time])
    ]).

 /*  not(holds_at(like(Agent1, Agent2), Time)) :-
       holds_at(neg(intentionToWalkIn(Agent1, Room)), Time),
       holds_at(invitedIn(Agent1, Room, Agent2), Time),
       not(happens(intendToWalkIn(Agent1, Room), Time)),
       allDifferent([Agent1, Room, Agent2, Time]).
 */

 /*  [holds_at(neg(intentionToWalkIn(Agent1, Room)), Time), holds_at(invitedIn(Agent1, Room, Agent2), Time), not(happens(intendToWalkIn(Agent1, Room), Time)), allDifferent([Agent1, Room, Agent2, Time])] ->
       ta(Time, holds_at(neg(like(Agent1, Agent2)), Time)).
 */
axiom(holds_at(neg(like(Agent1, Agent2)), Time),
   
    [ holds_at(neg(intentionToWalkIn(Agent1, Room)), Time),
      holds_at(invitedIn(Agent1, Room, Agent2), Time),
      not(happens(intendToWalkIn(Agent1, Room), Time)),
      allDifferent([Agent1, Room, Agent2, Time])
    ]).

 /*  not(holds_at(neg(intentionToWalkIn(Agent1, Room)), Time)) :-
       holds_at(like(Agent1, Agent2), Time),
       holds_at(invitedIn(Agent1, Room, Agent2), Time),
       not(happens(intendToWalkIn(Agent1, Room), Time)),
       allDifferent([Agent1, Room, Agent2, Time]).
 */

 /*  [holds_at(like(Agent1, Agent2), Time), holds_at(invitedIn(Agent1, Room, Agent2), Time), not(happens(intendToWalkIn(Agent1, Room), Time)), allDifferent([Agent1, Room, Agent2, Time])] ->
       ta(Time,
          holds_at(neg(neg(intentionToWalkIn(Agent1, Room))),
                   Time)).
 */
axiom(holds_at(neg(neg(intentionToWalkIn(Agent1, Room))), Time),
   
    [ holds_at(like(Agent1, Agent2), Time),
      holds_at(invitedIn(Agent1, Room, Agent2), Time),
      not(happens(intendToWalkIn(Agent1, Room), Time)),
      allDifferent([Agent1, Room, Agent2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1974
%; An effect axiom states that
%; if an agent intends to walk into a room,
%; the agent will have the intention to walk into the room:
% [agent,room,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1978
% Initiates(IntendToWalkIn(agent,room),
%           IntentionToWalkIn(agent,room),
%           time).

 /*  [] ->
       ta(Time,
          initiates(intendToWalkIn(Agent, Room),
                    intentionToWalkIn(Agent, Room),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1980
axiom(initiates(intendToWalkIn(Agent, Room), intentionToWalkIn(Agent, Room), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1982
%; Two trigger axioms state that
%; if an agent has the intention to walk into a room,
%; the agent acts on the intention to walk into the room,
%; the agent is at a location,
%; side one (two) of a door is the room,
%; side two (one) of the door is the location,
%; agent will walk through side two (one) of the door:
% [agent,room,location,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1990
% HoldsAt(IntentionToWalkIn(agent,room),time) &
% HoldsAt(ActOnIntentionToWalkIn(agent,room),time) &
% HoldsAt(At(agent,location),time) &
% Side1(door)=room &
% Side2(door)=location ->
% Happens(WalkThroughDoor21(agent,door),time).

 /*  allDifferent([Agent, Room, Time, Location, Door]) ->
       ( holds_at(intentionToWalkIn(Agent, Room), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), side1(Door)=Room, side2(Door)=Location->happens(walkThroughDoor21(Agent, Door), Time)
       ).
 */

 /*  happens(walkThroughDoor21(Agent, Door), Time) :-
       ( holds_at(intentionToWalkIn(Agent, Room), Time),
         holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
         holds_at(at(Agent, Location), Time),
         equals(side1(Door), Room),
         equals(side2(Door), Location)
       ),
       allDifferent([Agent, Room, Time, Location, Door]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Room).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [holds_at(intentionToWalkIn(Agent, Room), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), call(side1(Door)=Room), call(side2(Door)=Location), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          happens(walkThroughDoor21(Agent, Door), Time)).
 */

 /*  [holds_at(intentionToWalkIn(Agent, Room), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), holds_at(call(side1(Door)=Room), Time), holds_at(call(side2(Door)=Location), Time), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          happens(walkThroughDoor21(Agent, Door), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1995
axiom(happens(walkThroughDoor21(Agent, Door), Time),
   
    [ holds_at(intentionToWalkIn(Agent, Room), Time),
      holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(call(side1(Door)=Room), Time),
      holds_at(call(side2(Door)=Location), Time),
      allDifferent(
                   [ Agent,
                     Room,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(intentionToWalkIn(Agent, Room), Time)) :-
       ( holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
         holds_at(at(Agent, Location), Time),
         equals(side1(Door), Room),
         equals(side2(Door), Location)
       ),
       not(happens(walkThroughDoor21(Agent, Door), Time)),
       allDifferent([Agent, Room, Time, Location, Door]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Room).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), call(side1(Door)=Room), call(side2(Door)=Location), not(happens(walkThroughDoor21(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          holds_at(neg(intentionToWalkIn(Agent, Room)), Time)).
 */

 /*  [holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), holds_at(call(side1(Door)=Room), Time), holds_at(call(side2(Door)=Location), Time), not(happens(walkThroughDoor21(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          holds_at(neg(intentionToWalkIn(Agent, Room)), Time)).
 */
axiom(holds_at(neg(intentionToWalkIn(Agent, Room)), Time),
   
    [ holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(call(side1(Door)=Room), Time),
      holds_at(call(side2(Door)=Location), Time),
      not(happens(walkThroughDoor21(Agent, Door), Time)),
      allDifferent(
                   [ Agent,
                     Room,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(actOnIntentionToWalkIn(Agent, Room), Time)) :-
       ( holds_at(at(Agent, Location), Time),
         equals(side1(Door), Room),
         equals(side2(Door), Location)
       ),
       holds_at(intentionToWalkIn(Agent, Room), Time),
       not(happens(walkThroughDoor21(Agent, Door), Time)),
       allDifferent([Agent, Room, Time, Location, Door]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Room).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [holds_at(at(Agent, Location), Time), call(side1(Door)=Room), call(side2(Door)=Location), holds_at(intentionToWalkIn(Agent, Room), Time), not(happens(walkThroughDoor21(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          holds_at(neg(actOnIntentionToWalkIn(Agent, Room)),
                   Time)).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(call(side1(Door)=Room), Time), holds_at(call(side2(Door)=Location), Time), holds_at(intentionToWalkIn(Agent, Room), Time), not(happens(walkThroughDoor21(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          holds_at(neg(actOnIntentionToWalkIn(Agent, Room)),
                   Time)).
 */
axiom(holds_at(neg(actOnIntentionToWalkIn(Agent, Room)), Time),
   
    [ holds_at(at(Agent, Location), Time),
      holds_at(call(side1(Door)=Room), Time),
      holds_at(call(side2(Door)=Location), Time),
      holds_at(intentionToWalkIn(Agent, Room), Time),
      not(happens(walkThroughDoor21(Agent, Door), Time)),
      allDifferent(
                   [ Agent,
                     Room,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(at(Agent, Location), Time)) :-
       ( equals(side1(Door), Room),
         equals(side2(Door), Location)
       ),
       holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
       holds_at(intentionToWalkIn(Agent, Room), Time),
       not(happens(walkThroughDoor21(Agent, Door), Time)),
       allDifferent([Agent, Room, Time, Location, Door]).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Room).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [call(side1(Door)=Room), call(side2(Door)=Location), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(intentionToWalkIn(Agent, Room), Time), not(happens(walkThroughDoor21(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */

 /*  [holds_at(call(side1(Door)=Room), Time), holds_at(call(side2(Door)=Location), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(intentionToWalkIn(Agent, Room), Time), not(happens(walkThroughDoor21(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */
axiom(holds_at(neg(at(Agent, Location)), Time),
   
    [ holds_at(call(side1(Door)=Room), Time),
      holds_at(call(side2(Door)=Location), Time),
      holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
      holds_at(intentionToWalkIn(Agent, Room), Time),
      not(happens(walkThroughDoor21(Agent, Door), Time)),
      allDifferent(
                   [ Agent,
                     Room,
                     Time,
                     Location,
                     Door
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:1997
% [agent,room,location,door,time]
% HoldsAt(IntentionToWalkIn(agent,room),time) &
% HoldsAt(ActOnIntentionToWalkIn(agent,room),time) &
% HoldsAt(At(agent,location),time) &
% Side2(door)=room &
% Side1(door)=location ->
% Happens(WalkThroughDoor12(agent,door),time).

 /*  allDifferent([Agent, Room, Time, Location, Door]) ->
       ( holds_at(intentionToWalkIn(Agent, Room), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), side2(Door)=Room, side1(Door)=Location->happens(walkThroughDoor12(Agent, Door), Time)
       ).
 */

 /*  happens(walkThroughDoor12(Agent, Door), Time) :-
       ( holds_at(intentionToWalkIn(Agent, Room), Time),
         holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
         holds_at(at(Agent, Location), Time),
         equals(side2(Door), Room),
         equals(side1(Door), Location)
       ),
       allDifferent([Agent, Room, Time, Location, Door]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Room).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [holds_at(intentionToWalkIn(Agent, Room), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), call(side2(Door)=Room), call(side1(Door)=Location), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          happens(walkThroughDoor12(Agent, Door), Time)).
 */

 /*  [holds_at(intentionToWalkIn(Agent, Room), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), holds_at(call(side2(Door)=Room), Time), holds_at(call(side1(Door)=Location), Time), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          happens(walkThroughDoor12(Agent, Door), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2003
axiom(happens(walkThroughDoor12(Agent, Door), Time),
   
    [ holds_at(intentionToWalkIn(Agent, Room), Time),
      holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(call(side2(Door)=Room), Time),
      holds_at(call(side1(Door)=Location), Time),
      allDifferent(
                   [ Agent,
                     Room,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(intentionToWalkIn(Agent, Room), Time)) :-
       ( holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
         holds_at(at(Agent, Location), Time),
         equals(side2(Door), Room),
         equals(side1(Door), Location)
       ),
       not(happens(walkThroughDoor12(Agent, Door), Time)),
       allDifferent([Agent, Room, Time, Location, Door]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Room).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), call(side2(Door)=Room), call(side1(Door)=Location), not(happens(walkThroughDoor12(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          holds_at(neg(intentionToWalkIn(Agent, Room)), Time)).
 */

 /*  [holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at(Agent, Location), Time), holds_at(call(side2(Door)=Room), Time), holds_at(call(side1(Door)=Location), Time), not(happens(walkThroughDoor12(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          holds_at(neg(intentionToWalkIn(Agent, Room)), Time)).
 */
axiom(holds_at(neg(intentionToWalkIn(Agent, Room)), Time),
   
    [ holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
      holds_at(at(Agent, Location), Time),
      holds_at(call(side2(Door)=Room), Time),
      holds_at(call(side1(Door)=Location), Time),
      not(happens(walkThroughDoor12(Agent, Door), Time)),
      allDifferent(
                   [ Agent,
                     Room,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(actOnIntentionToWalkIn(Agent, Room), Time)) :-
       ( holds_at(at(Agent, Location), Time),
         equals(side2(Door), Room),
         equals(side1(Door), Location)
       ),
       holds_at(intentionToWalkIn(Agent, Room), Time),
       not(happens(walkThroughDoor12(Agent, Door), Time)),
       allDifferent([Agent, Room, Time, Location, Door]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Room).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [holds_at(at(Agent, Location), Time), call(side2(Door)=Room), call(side1(Door)=Location), holds_at(intentionToWalkIn(Agent, Room), Time), not(happens(walkThroughDoor12(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          holds_at(neg(actOnIntentionToWalkIn(Agent, Room)),
                   Time)).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(call(side2(Door)=Room), Time), holds_at(call(side1(Door)=Location), Time), holds_at(intentionToWalkIn(Agent, Room), Time), not(happens(walkThroughDoor12(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time,
          holds_at(neg(actOnIntentionToWalkIn(Agent, Room)),
                   Time)).
 */
axiom(holds_at(neg(actOnIntentionToWalkIn(Agent, Room)), Time),
   
    [ holds_at(at(Agent, Location), Time),
      holds_at(call(side2(Door)=Room), Time),
      holds_at(call(side1(Door)=Location), Time),
      holds_at(intentionToWalkIn(Agent, Room), Time),
      not(happens(walkThroughDoor12(Agent, Door), Time)),
      allDifferent(
                   [ Agent,
                     Room,
                     Time,
                     Location,
                     Door
                   ])
    ]).

 /*  not(holds_at(at(Agent, Location), Time)) :-
       ( equals(side2(Door), Room),
         equals(side1(Door), Location)
       ),
       holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
       holds_at(intentionToWalkIn(Agent, Room), Time),
       not(happens(walkThroughDoor12(Agent, Door), Time)),
       allDifferent([Agent, Room, Time, Location, Door]).
 */

 /*  axiom_head(Time) ->
       equals(side2(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Room).
 */

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [call(side2(Door)=Room), call(side1(Door)=Location), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(intentionToWalkIn(Agent, Room), Time), not(happens(walkThroughDoor12(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */

 /*  [holds_at(call(side2(Door)=Room), Time), holds_at(call(side1(Door)=Location), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(intentionToWalkIn(Agent, Room), Time), not(happens(walkThroughDoor12(Agent, Door), Time)), allDifferent([Agent, Room, Time, Location, Door])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */
axiom(holds_at(neg(at(Agent, Location)), Time),
   
    [ holds_at(call(side2(Door)=Room), Time),
      holds_at(call(side1(Door)=Location), Time),
      holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
      holds_at(intentionToWalkIn(Agent, Room), Time),
      not(happens(walkThroughDoor12(Agent, Door), Time)),
      allDifferent(
                   [ Agent,
                     Room,
                     Time,
                     Location,
                     Door
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2005
%; Two effect axioms state that
%; if side one (two) of a door is a room and
%; an agent walks through side two (one) of the door,
%; the agent will no longer have the intention to
%; walk into the room:
% [agent,room,door,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2011
% Side1(door)=room ->
% Terminates(WalkThroughDoor21(agent,door),
%            IntentionToWalkIn(agent,room),
%            time).

 /*  axiom_head(Time) ->
       equals(side1(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Room).
 */

 /*  [call(side1(Door)=Room)] ->
       ta(Time,
          terminates(walkThroughDoor21(Agent, Door),
                     intentionToWalkIn(Agent, Room),
                     Time)).
 */

 /*  [holds_at(call(side1(Door)=Room), Time)] ->
       ta(Time,
          terminates(walkThroughDoor21(Agent, Door),
                     intentionToWalkIn(Agent, Room),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2014
axiom(terminates(walkThroughDoor21(Agent, Door), intentionToWalkIn(Agent, Room), Time),
    [holds_at(call(side1(Door)=Room), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2016
% [agent,room,door,time]
% Side2(door)=room ->
% Terminates(WalkThroughDoor12(agent,door),
%            IntentionToWalkIn(agent,room),
%            time).

 /*  axiom_head(Time) ->
       equals(side2(Door), Room).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Room).
 */

 /*  [call(side2(Door)=Room)] ->
       ta(Time,
          terminates(walkThroughDoor12(Agent, Door),
                     intentionToWalkIn(Agent, Room),
                     Time)).
 */

 /*  [holds_at(call(side2(Door)=Room), Time)] ->
       ta(Time,
          terminates(walkThroughDoor12(Agent, Door),
                     intentionToWalkIn(Agent, Room),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2020
axiom(terminates(walkThroughDoor12(Agent, Door), intentionToWalkIn(Agent, Room), Time),
    [holds_at(call(side2(Door)=Room), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2022
%; agent greets object.

% event Greet(agent,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2024
event(greet(Greet_Param,Greet_Ret)).
==> mpred_prop(greet(agent,object),event).
==> meta_argtypes(greet(agent,object)).

% event SayPleasedToMeet(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2026
event(sayPleasedToMeet(SayPleasedToMeet_Param,
		       SayPleasedToMeet_Ret)).
==> mpred_prop(sayPleasedToMeet(agent,agent),event).
==> meta_argtypes(sayPleasedToMeet(agent,agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2027
%; agent says goodbye to object.

% event SayGoodbye(agent,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2029
event(sayGoodbye(SayGoodbye_Param,SayGoodbye_Ret)).
==> mpred_prop(sayGoodbye(agent,object),event).
==> meta_argtypes(sayGoodbye(agent,object)).

% event TalkAbout(agent,content)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2031
event(talkAbout(TalkAbout_Param,TalkAbout_Ret)).
==> mpred_prop(talkAbout(agent,content),event).
==> meta_argtypes(talkAbout(agent,content)).

% event Converse(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2033
event(converse(Converse_Param,Converse_Ret)).
==> mpred_prop(converse(agent,agent),event).
==> meta_argtypes(converse(agent,agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2034
% [agent1,agent2,time]
% Happens(Converse(agent1,agent2),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2036
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).

 /*  exists([Location],
    happens(converse(Agent1, Agent2), Time) ->
       holds_at(at(Agent1, Location), Time),
       holds_at(at(Agent2, Location), Time)).
 */

 /*  not(happens(converse(Agent1, Agent2), Time)) :-
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ),
       some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent1, Location)), Time)
       ;   holds_at(neg(at(Agent2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)), some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time))] ->
       ta(Time,
          not(happens(converse(Agent1, Agent2), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2038
axiom(not(happens(converse(Agent1, Agent2), Time)),
   
    [  (holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)),
      some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time))
    ]).

 /*  holds_at(at(Agent1, Location), Time) :-
       happens(converse(Agent1, Agent2), Time),
       some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time)).
 */

 /*  [happens(converse(Agent1, Agent2), Time), some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time))] ->
       ta(Time, holds_at(at(Agent1, Location), Time)).
 */
axiom(holds_at(at(Agent1, Location), Time),
   
    [ happens(converse(Agent1, Agent2), Time),
      some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time))
    ]).

 /*  holds_at(at(Agent2, Location), Time) :-
       happens(converse(Agent1, Agent2), Time),
       some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time)).
 */

 /*  [happens(converse(Agent1, Agent2), Time), some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time))] ->
       ta(Time, holds_at(at(Agent2, Location), Time)).
 */
axiom(holds_at(at(Agent2, Location), Time),
   
    [ happens(converse(Agent1, Agent2), Time),
      some(Location, '$kolem_Fn_216'(Agent1, Agent2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2040
%; A precondition axiom states that for
%; an agent to greet an object,
%; there must be a location such that
%; the agent is at the location and
%; the object is at the location:
% [agent,object,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2046
% Happens(Greet(agent,object),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2047
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time).

 /*  exists([Location],
    happens(greet(Agent, Object), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Object, Location), Time)).
 */

 /*  not(happens(greet(Agent, Object), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Object, Location), Time))
       ),
       some(Location, '$kolem_Fn_217'(Agent, Object, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Object, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Object, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Object, Location)), Time)), some(Location, '$kolem_Fn_217'(Agent, Object, Time))] ->
       ta(Time, not(happens(greet(Agent, Object), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2049
axiom(not(happens(greet(Agent, Object), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Object, Location)), Time)),
      some(Location, '$kolem_Fn_217'(Agent, Object, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(greet(Agent, Object), Time),
       some(Location, '$kolem_Fn_217'(Agent, Object, Time)).
 */

 /*  [happens(greet(Agent, Object), Time), some(Location, '$kolem_Fn_217'(Agent, Object, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(greet(Agent, Object), Time),
      some(Location, '$kolem_Fn_217'(Agent, Object, Time))
    ]).

 /*  holds_at(at(Object, Location), Time) :-
       happens(greet(Agent, Object), Time),
       some(Location, '$kolem_Fn_217'(Agent, Object, Time)).
 */

 /*  [happens(greet(Agent, Object), Time), some(Location, '$kolem_Fn_217'(Agent, Object, Time))] ->
       ta(Time, holds_at(at(Object, Location), Time)).
 */
axiom(holds_at(at(Object, Location), Time),
   
    [ happens(greet(Agent, Object), Time),
      some(Location, '$kolem_Fn_217'(Agent, Object, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2051
% [agent,object,time]
% Happens(SayGoodbye(agent,object),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2053
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time).

 /*  exists([Location],
    happens(sayGoodbye(Agent, Object), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Object, Location), Time)).
 */

 /*  not(happens(sayGoodbye(Agent, Object), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Object, Location), Time))
       ),
       some(Location, '$kolem_Fn_218'(Agent, Object, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Object, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Object, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Object, Location)), Time)), some(Location, '$kolem_Fn_218'(Agent, Object, Time))] ->
       ta(Time,
          not(happens(sayGoodbye(Agent, Object), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2055
axiom(not(happens(sayGoodbye(Agent, Object), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Object, Location)), Time)),
      some(Location, '$kolem_Fn_218'(Agent, Object, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(sayGoodbye(Agent, Object), Time),
       some(Location, '$kolem_Fn_218'(Agent, Object, Time)).
 */

 /*  [happens(sayGoodbye(Agent, Object), Time), some(Location, '$kolem_Fn_218'(Agent, Object, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(sayGoodbye(Agent, Object), Time),
      some(Location, '$kolem_Fn_218'(Agent, Object, Time))
    ]).

 /*  holds_at(at(Object, Location), Time) :-
       happens(sayGoodbye(Agent, Object), Time),
       some(Location, '$kolem_Fn_218'(Agent, Object, Time)).
 */

 /*  [happens(sayGoodbye(Agent, Object), Time), some(Location, '$kolem_Fn_218'(Agent, Object, Time))] ->
       ta(Time, holds_at(at(Object, Location), Time)).
 */
axiom(holds_at(at(Object, Location), Time),
   
    [ happens(sayGoodbye(Agent, Object), Time),
      some(Location, '$kolem_Fn_218'(Agent, Object, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2057
%; speech: expression of emotions
%; agent cries for joy.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2060
% event CryForJoy(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2061
event(cryForJoy(CryForJoy_Ret)).
==> mpred_prop(cryForJoy(agent),event).
==> meta_argtypes(cryForJoy(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2062
%; A precondition axiom states that for
%; an agent to cry for joy,
%; the agent must be happy:
% [agent,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2067
% Happens(CryForJoy(agent),time) ->
% HoldsAt(Happy(agent),time).

 /*  allDifferent([Agent, Time]) ->
       ( happens(cryForJoy(Agent), Time)->holds_at(happy(Agent), Time)
       ).
 */

 /*  holds_at(happy(Agent), Time) :-
       happens(cryForJoy(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [happens(cryForJoy(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(happy(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2068
axiom(holds_at(happy(Agent), Time),
   
    [ happens(cryForJoy(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(happens(cryForJoy(Agent), Time)) :-
       not(holds_at(happy(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(happy(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, not(happens(cryForJoy(Agent), Time))).
 */
axiom(not(happens(cryForJoy(Agent), Time)),
   
    [ holds_at(neg(happy(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2070
% event Threaten(agent,agent,weapon)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2071
event(threaten(Threaten_Param,_,Threaten_Ret)).
==> mpred_prop(threaten(agent,agent,weapon),event).
==> meta_argtypes(threaten(agent,agent,weapon)).

% event ReleaseFromThreat(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2073
event(releaseFromThreat(ReleaseFromThreat_Param,
			ReleaseFromThreat_Ret)).
==> mpred_prop(releaseFromThreat(agent,agent),event).
==> meta_argtypes(releaseFromThreat(agent,agent)).

% fluent ThreatenedBy(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2075
fluent(threatenedBy(ThreatenedBy_Param,ThreatenedBy_Ret)).
==> mpred_prop(threatenedBy(agent,agent),fluent).
==> meta_argtypes(threatenedBy(agent,agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2076
% [agent1,agent2,weapon,time]
% Happens(Threaten(agent1,agent2,weapon), time) ->
% HoldsAt(Holding(agent1,weapon),time) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2079
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).

 /*  exists([Location],
    happens(threaten(Agent1, Agent2, Weapon), Time) ->
       holds_at(holding(Agent1, Weapon), Time),
       holds_at(at(Agent1, Location), Time),
       holds_at(at(Agent2, Location), Time)).
 */

 /*  not(happens(threaten(Agent1, Agent2, Weapon), Time)) :-
       (   not(holds_at(holding(Agent1, Weapon), Time))
       ;   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(holding(Agent1, Weapon), Time))
       ;   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(holding(Agent1, Weapon)), Time)
       ;   holds_at(neg(at(Agent1, Location)), Time)
       ;   holds_at(neg(at(Agent2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(holding(Agent1, Weapon)), Time);holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)), some(Location, '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time))] ->
       ta(Time,
          not(happens(threaten(Agent1, Agent2, Weapon),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2081
axiom(not(happens(threaten(Agent1, Agent2, Weapon), Time)),
   
    [  (holds_at(neg(holding(Agent1, Weapon)), Time);holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)),
      some(Location,
           '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time))
    ]).

 /*  holds_at(holding(Agent1, Weapon), Time) :-
       happens(threaten(Agent1, Agent2, Weapon), Time),
       some(Location,
            '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time)).
 */

 /*  [happens(threaten(Agent1, Agent2, Weapon), Time), some(Location, '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time))] ->
       ta(Time, holds_at(holding(Agent1, Weapon), Time)).
 */
axiom(holds_at(holding(Agent1, Weapon), Time),
   
    [ happens(threaten(Agent1, Agent2, Weapon), Time),
      some(Location,
           '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time))
    ]).

 /*  holds_at(at(Agent1, Location), Time) :-
       happens(threaten(Agent1, Agent2, Weapon), Time),
       some(Location,
            '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time)).
 */

 /*  [happens(threaten(Agent1, Agent2, Weapon), Time), some(Location, '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time))] ->
       ta(Time, holds_at(at(Agent1, Location), Time)).
 */
axiom(holds_at(at(Agent1, Location), Time),
   
    [ happens(threaten(Agent1, Agent2, Weapon), Time),
      some(Location,
           '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time))
    ]).

 /*  holds_at(at(Agent2, Location), Time) :-
       happens(threaten(Agent1, Agent2, Weapon), Time),
       some(Location,
            '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time)).
 */

 /*  [happens(threaten(Agent1, Agent2, Weapon), Time), some(Location, '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time))] ->
       ta(Time, holds_at(at(Agent2, Location), Time)).
 */
axiom(holds_at(at(Agent2, Location), Time),
   
    [ happens(threaten(Agent1, Agent2, Weapon), Time),
      some(Location,
           '$kolem_Fn_219'(Agent1, Agent2, Weapon, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2083
% [agent1,agent2,weapon,time]
% Happens(Threaten(agent1,agent2,weapon), time) ->
% Happens(BecomeAngryAt(agent2,agent1),time).

 /*  allDifferent([Agent1, Agent2, Weapon, Time]) ->
       ( happens(threaten(Agent1, Agent2, Weapon), Time)->happens(becomeAngryAt(Agent2, Agent1), Time)
       ).
 */

 /*  happens(becomeAngryAt(Agent2, Agent1), Time) :-
       happens(threaten(Agent1, Agent2, Weapon), Time),
       allDifferent([Agent1, Agent2, Weapon, Time]).
 */

 /*  [happens(threaten(Agent1, Agent2, Weapon), Time), allDifferent([Agent1, Agent2, Weapon, Time])] ->
       ta(Time,
          happens(becomeAngryAt(Agent2, Agent1), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2085
axiom(happens(becomeAngryAt(Agent2, Agent1), Time),
   
    [ happens(threaten(Agent1, Agent2, Weapon), Time),
      allDifferent([Agent1, Agent2, Weapon, Time])
    ]).

 /*  not(happens(threaten(Agent1, Agent2, Weapon), Time)) :-
       not(happens(becomeAngryAt(Agent2, Agent1), Time)),
       allDifferent([Agent1, Agent2, Weapon, Time]).
 */

 /*  [not(happens(becomeAngryAt(Agent2, Agent1), Time)), allDifferent([Agent1, Agent2, Weapon, Time])] ->
       ta(Time,
          not(happens(threaten(Agent1, Agent2, Weapon),
                      Time))).
 */
axiom(not(happens(threaten(Agent1, Agent2, Weapon), Time)),
   
    [ not(happens(becomeAngryAt(Agent2, Agent1), Time)),
      allDifferent([Agent1, Agent2, Weapon, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2087
% [agent1,agent2,weapon,time]
% Initiates(Threaten(agent1,agent2,weapon),
%           ThreatenedBy(agent2,agent1),
%           time).

 /*  [] ->
       ta(Time,
          initiates(threaten(Agent1, Agent2, Weapon),
                    threatenedBy(Agent2, Agent1),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2090
axiom(initiates(threaten(Agent1, Agent2, Weapon), threatenedBy(Agent2, Agent1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2092
% [agent1,agent2,time]
% Terminates(ReleaseFromThreat(agent1,agent2),
%            ThreatenedBy(agent2,agent1),
%            time).

 /*  [] ->
       ta(Time,
          terminates(releaseFromThreat(Agent1, Agent2),
                     threatenedBy(Agent2, Agent1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2095
axiom(terminates(releaseFromThreat(Agent1, Agent2), threatenedBy(Agent2, Agent1), Time),
    []).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2097
% event Order(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2098
event(order(Order_Param,_,Order_Ret)).
==> mpred_prop(order(agent,agent,physobj),event).
==> meta_argtypes(order(agent,agent,physobj)).

% fluent KnowOrder(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2100
fluent(knowOrder(KnowOrder_Param,_,KnowOrder_Ret)).
==> mpred_prop(knowOrder(agent,agent,physobj),fluent).
==> meta_argtypes(knowOrder(agent,agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2101
% [agent1,agent2,physobj,time]
% Initiates(Order(agent1,agent2,physobj),
%           KnowOrder(agent2,agent1,physobj),
%           time).

 /*  [] ->
       ta(Time,
          initiates(order(Agent1, Agent2, Physobj),
                    knowOrder(Agent2, Agent1, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2104
axiom(initiates(order(Agent1, Agent2, Physobj), knowOrder(Agent2, Agent1, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2106
% [agent1,agent2,physobj,time]
% Happens(Order(agent1,agent2,physobj),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2108
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).

 /*  exists([Location],
    happens(order(Agent1, Agent2, Physobj), Time) ->
       holds_at(at(Agent1, Location), Time),
       holds_at(at(Agent2, Location), Time)).
 */

 /*  not(happens(order(Agent1, Agent2, Physobj), Time)) :-
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent1, Location)), Time)
       ;   holds_at(neg(at(Agent2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)), some(Location, '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time,
          not(happens(order(Agent1, Agent2, Physobj), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2110
axiom(not(happens(order(Agent1, Agent2, Physobj), Time)),
   
    [  (holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)),
      some(Location,
           '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time))
    ]).

 /*  holds_at(at(Agent1, Location), Time) :-
       happens(order(Agent1, Agent2, Physobj), Time),
       some(Location,
            '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time)).
 */

 /*  [happens(order(Agent1, Agent2, Physobj), Time), some(Location, '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent1, Location), Time)).
 */
axiom(holds_at(at(Agent1, Location), Time),
   
    [ happens(order(Agent1, Agent2, Physobj), Time),
      some(Location,
           '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time))
    ]).

 /*  holds_at(at(Agent2, Location), Time) :-
       happens(order(Agent1, Agent2, Physobj), Time),
       some(Location,
            '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time)).
 */

 /*  [happens(order(Agent1, Agent2, Physobj), Time), some(Location, '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent2, Location), Time)).
 */
axiom(holds_at(at(Agent2, Location), Time),
   
    [ happens(order(Agent1, Agent2, Physobj), Time),
      some(Location,
           '$kolem_Fn_220'(Agent1, Agent2, Physobj, Time))
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2112
% event Request(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2113
event(request(Request_Param,_,Request_Ret)).
==> mpred_prop(request(agent,agent,physobj),event).
==> meta_argtypes(request(agent,agent,physobj)).

% fluent KnowRequest(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2115
fluent(knowRequest(KnowRequest_Param,
		   _,
		   KnowRequest_Ret)).
==> mpred_prop(knowRequest(agent,agent,physobj),fluent).
==> meta_argtypes(knowRequest(agent,agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2116
% [agent1,agent2,physobj,time]
% Initiates(Request(agent1,agent2,physobj),
%           KnowRequest(agent2,agent1,physobj),
%           time).

 /*  [] ->
       ta(Time,
          initiates(request(Agent1, Agent2, Physobj),
                    knowRequest(Agent2, Agent1, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2119
axiom(initiates(request(Agent1, Agent2, Physobj), knowRequest(Agent2, Agent1, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2121
% [agent1,agent2,physobj,time]
% Happens(Request(agent1,agent2,physobj),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2123
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).

 /*  exists([Location],
    happens(request(Agent1, Agent2, Physobj), Time) ->
       holds_at(at(Agent1, Location), Time),
       holds_at(at(Agent2, Location), Time)).
 */

 /*  not(happens(request(Agent1, Agent2, Physobj), Time)) :-
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent1, Location)), Time)
       ;   holds_at(neg(at(Agent2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)), some(Location, '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time,
          not(happens(request(Agent1, Agent2, Physobj),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2125
axiom(not(happens(request(Agent1, Agent2, Physobj), Time)),
   
    [  (holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)),
      some(Location,
           '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time))
    ]).

 /*  holds_at(at(Agent1, Location), Time) :-
       happens(request(Agent1, Agent2, Physobj), Time),
       some(Location,
            '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time)).
 */

 /*  [happens(request(Agent1, Agent2, Physobj), Time), some(Location, '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent1, Location), Time)).
 */
axiom(holds_at(at(Agent1, Location), Time),
   
    [ happens(request(Agent1, Agent2, Physobj), Time),
      some(Location,
           '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time))
    ]).

 /*  holds_at(at(Agent2, Location), Time) :-
       happens(request(Agent1, Agent2, Physobj), Time),
       some(Location,
            '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time)).
 */

 /*  [happens(request(Agent1, Agent2, Physobj), Time), some(Location, '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent2, Location), Time)).
 */
axiom(holds_at(at(Agent2, Location), Time),
   
    [ happens(request(Agent1, Agent2, Physobj), Time),
      some(Location,
           '$kolem_Fn_221'(Agent1, Agent2, Physobj, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2127
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Sleep.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; The Sleep representation deals with the activity of sleeping and
%; body posture.
%; It is similar to the finite automaton representation of sleep
%; used in ThoughtTreasure \fullcite[chap. 7]{Mueller:1998}.
%;
%; @book{Mueller:1998,
%;   author = "Erik T. Mueller",
%;   year = "1998",
%;   title = "Natural Language Processing with \uppercase{T}hought\uppercase{T}reasure",
%;   address = "New York",
%;   publisher = "Signiform",
%; }
%;
%; sleep
%; agent wakes up.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2162
% event WakeUp(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2163
event(wakeUp(WakeUp_Ret)).
==> mpred_prop(wakeUp(agent),event).
==> meta_argtypes(wakeUp(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2164
%; agent gets tired.

% event GetTired(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2166
event(getTired(GetTired_Ret)).
==> mpred_prop(getTired(agent),event).
==> meta_argtypes(getTired(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2167
%; agent falls asleep.

% event FallAsleep(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2169
event(fallAsleep(FallAsleep_Ret)).
==> mpred_prop(fallAsleep(agent),event).
==> meta_argtypes(fallAsleep(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2170
%; agent is asleep.

% fluent Sleep0(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2172
fluent(sleep0(Sleep0_Ret)).
==> mpred_prop(sleep0(agent),fluent).
==> meta_argtypes(sleep0(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2172
%; agent is awake and in bed.

% fluent Sleep1(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2174
fluent(sleep1(Sleep1_Ret)).
==> mpred_prop(sleep1(agent),fluent).
==> meta_argtypes(sleep1(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2174
%; agent is awake, out of bed, and undressed.

% fluent Sleep2(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2176
fluent(sleep2(Sleep2_Ret)).
==> mpred_prop(sleep2(agent),fluent).
==> meta_argtypes(sleep2(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2176
%; agent is awake and dressed.

% fluent Sleep3(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2178
fluent(sleep3(Sleep3_Ret)).
==> mpred_prop(sleep3(agent),fluent).
==> meta_argtypes(sleep3(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2178
%; agent is tired and dressed.

% fluent Sleep4(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2180
fluent(sleep4(Sleep4_Ret)).
==> mpred_prop(sleep4(agent),fluent).
==> meta_argtypes(sleep4(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2180
%; agent is tired and undressed.

% fluent Sleep5(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2182
fluent(sleep5(Sleep5_Ret)).
==> mpred_prop(sleep5(agent),fluent).
==> meta_argtypes(sleep5(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2182
%; agent is in bed, waiting to fall asleep.

% fluent Sleep6(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2184
fluent(sleep6(Sleep6_Ret)).
==> mpred_prop(sleep6(agent),fluent).
==> meta_argtypes(sleep6(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2185
%; At any time, an agent is in one of seven sleep states:

% xor Sleep0, Sleep1, Sleep2, Sleep3, Sleep4, Sleep5, Sleep6
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2187
==> xor([sleep0,sleep1,sleep2,sleep3,sleep4,sleep5,sleep6]).
%; constraints
%; agent is asleep.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2191
% fluent Asleep(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2192
fluent(asleep(Asleep_Ret)).
==> mpred_prop(asleep(agent),fluent).
==> meta_argtypes(asleep(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2192
%; agent is awake.

% fluent Awake(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2194
fluent(awake(Awake_Ret)).
==> mpred_prop(awake(agent),fluent).
==> meta_argtypes(awake(agent)).

% noninertial Asleep
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2195
==> noninertial(asleep).

% noninertial Awake
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2196
==> noninertial(awake).
%; Sleep0 indicates that the agent is asleep:
% [agent,time]
 % HoldsAt(Asleep(agent),time) <-> HoldsAt(Sleep0(agent),time).

 /*  holds_at(asleep(Agent), Time) <->
       holds_at(sleep0(Agent), Time).
 */

 /*  [holds_at, asleep] <->
       [holds_at, sleep0].
 */

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(asleep(Agent), Time)->holds_at(sleep0(Agent), Time)
       ).
 */

 /*  holds_at(sleep0(Agent), Time) :-
       holds_at(asleep(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(asleep(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep0(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2198
axiom(holds_at(sleep0(Agent), Time),
   
    [ holds_at(asleep(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(asleep(Agent), Time)) :-
       not(holds_at(sleep0(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep0(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(asleep(Agent)), Time)).
 */
axiom(holds_at(neg(asleep(Agent)), Time),
   
    [ holds_at(neg(sleep0(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(sleep0(Agent), Time)->holds_at(asleep(Agent), Time)
       ).
 */

 /*  holds_at(asleep(Agent), Time) :-
       holds_at(sleep0(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(sleep0(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(asleep(Agent), Time)).
 */
axiom(holds_at(asleep(Agent), Time),
   
    [ holds_at(sleep0(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(sleep0(Agent), Time)) :-
       not(holds_at(asleep(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(asleep(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(sleep0(Agent)), Time)).
 */
axiom(holds_at(neg(sleep0(Agent)), Time),
   
    [ holds_at(neg(asleep(Agent)), Time),
      allDifferent([Agent, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2200
%; In all other sleep states, the agent is awake:
% [agent,time]
% HoldsAt(Awake(agent),time) <->
% HoldsAt(Sleep1(agent),time) |
% HoldsAt(Sleep2(agent),time) |
% HoldsAt(Sleep3(agent),time) |
% HoldsAt(Sleep4(agent),time) |
% HoldsAt(Sleep5(agent),time) |
% HoldsAt(Sleep6(agent),time).

 /*  holds_at(awake(Agent), Time) <->
       (   holds_at(sleep1(Agent), Time)
       ;   holds_at(sleep2(Agent), Time)
       ;   holds_at(sleep3(Agent), Time)
       ;   holds_at(sleep4(Agent), Time)
       ;   holds_at(sleep5(Agent), Time)
       ;   holds_at(sleep6(Agent), Time)
       ).
 */

 /*  [holds_at, awake] <->
       
       [  (;),
         holds_at,
         sleep1,
          (;),
         holds_at,
         sleep2,
          (;),
         holds_at,
         sleep3,
          (;),
         holds_at,
         sleep4,
          (;),
         holds_at,
         sleep5,
         holds_at,
         sleep6
       ].
 */

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(awake(Agent), Time)->holds_at(sleep1(Agent), Time);holds_at(sleep2(Agent), Time);holds_at(sleep3(Agent), Time);holds_at(sleep4(Agent), Time);holds_at(sleep5(Agent), Time);holds_at(sleep6(Agent), Time)
       ).
 */

 /*  holds_at(sleep1(Agent), Time) :-
       ( not(holds_at(sleep2(Agent), Time)),
         not(holds_at(sleep3(Agent), Time)),
         not(holds_at(sleep4(Agent), Time)),
         not(holds_at(sleep5(Agent), Time)),
         not(holds_at(sleep6(Agent), Time))
       ),
       holds_at(awake(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep2(Agent)), Time), holds_at(neg(sleep3(Agent)), Time), holds_at(neg(sleep4(Agent)), Time), holds_at(neg(sleep5(Agent)), Time), holds_at(neg(sleep6(Agent)), Time), holds_at(awake(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep1(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2208
axiom(holds_at(sleep1(Agent), Time),
   
    [ holds_at(neg(sleep2(Agent)), Time),
      holds_at(neg(sleep3(Agent)), Time),
      holds_at(neg(sleep4(Agent)), Time),
      holds_at(neg(sleep5(Agent)), Time),
      holds_at(neg(sleep6(Agent)), Time),
      holds_at(awake(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  holds_at(sleep2(Agent), Time) :-
       ( not(holds_at(sleep3(Agent), Time)),
         not(holds_at(sleep4(Agent), Time)),
         not(holds_at(sleep5(Agent), Time)),
         not(holds_at(sleep6(Agent), Time))
       ),
       not(holds_at(sleep1(Agent), Time)),
       holds_at(awake(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep3(Agent)), Time), holds_at(neg(sleep4(Agent)), Time), holds_at(neg(sleep5(Agent)), Time), holds_at(neg(sleep6(Agent)), Time), holds_at(neg(sleep1(Agent)), Time), holds_at(awake(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep2(Agent), Time)).
 */
axiom(holds_at(sleep2(Agent), Time),
   
    [ holds_at(neg(sleep3(Agent)), Time),
      holds_at(neg(sleep4(Agent)), Time),
      holds_at(neg(sleep5(Agent)), Time),
      holds_at(neg(sleep6(Agent)), Time),
      holds_at(neg(sleep1(Agent)), Time),
      holds_at(awake(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  holds_at(sleep3(Agent), Time) :-
       ( not(holds_at(sleep4(Agent), Time)),
         not(holds_at(sleep5(Agent), Time)),
         not(holds_at(sleep6(Agent), Time))
       ),
       not(holds_at(sleep2(Agent), Time)),
       not(holds_at(sleep1(Agent), Time)),
       holds_at(awake(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep4(Agent)), Time), holds_at(neg(sleep5(Agent)), Time), holds_at(neg(sleep6(Agent)), Time), holds_at(neg(sleep2(Agent)), Time), holds_at(neg(sleep1(Agent)), Time), holds_at(awake(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep3(Agent), Time)).
 */
axiom(holds_at(sleep3(Agent), Time),
   
    [ holds_at(neg(sleep4(Agent)), Time),
      holds_at(neg(sleep5(Agent)), Time),
      holds_at(neg(sleep6(Agent)), Time),
      holds_at(neg(sleep2(Agent)), Time),
      holds_at(neg(sleep1(Agent)), Time),
      holds_at(awake(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  holds_at(sleep4(Agent), Time) :-
       ( not(holds_at(sleep5(Agent), Time)),
         not(holds_at(sleep6(Agent), Time))
       ),
       not(holds_at(sleep3(Agent), Time)),
       not(holds_at(sleep2(Agent), Time)),
       not(holds_at(sleep1(Agent), Time)),
       holds_at(awake(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep5(Agent)), Time), holds_at(neg(sleep6(Agent)), Time), holds_at(neg(sleep3(Agent)), Time), holds_at(neg(sleep2(Agent)), Time), holds_at(neg(sleep1(Agent)), Time), holds_at(awake(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep4(Agent), Time)).
 */
axiom(holds_at(sleep4(Agent), Time),
   
    [ holds_at(neg(sleep5(Agent)), Time),
      holds_at(neg(sleep6(Agent)), Time),
      holds_at(neg(sleep3(Agent)), Time),
      holds_at(neg(sleep2(Agent)), Time),
      holds_at(neg(sleep1(Agent)), Time),
      holds_at(awake(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  holds_at(sleep5(Agent), Time) :-
       not(holds_at(sleep6(Agent), Time)),
       not(holds_at(sleep4(Agent), Time)),
       not(holds_at(sleep3(Agent), Time)),
       not(holds_at(sleep2(Agent), Time)),
       not(holds_at(sleep1(Agent), Time)),
       holds_at(awake(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep6(Agent)), Time), holds_at(neg(sleep4(Agent)), Time), holds_at(neg(sleep3(Agent)), Time), holds_at(neg(sleep2(Agent)), Time), holds_at(neg(sleep1(Agent)), Time), holds_at(awake(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep5(Agent), Time)).
 */
axiom(holds_at(sleep5(Agent), Time),
   
    [ holds_at(neg(sleep6(Agent)), Time),
      holds_at(neg(sleep4(Agent)), Time),
      holds_at(neg(sleep3(Agent)), Time),
      holds_at(neg(sleep2(Agent)), Time),
      holds_at(neg(sleep1(Agent)), Time),
      holds_at(awake(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  holds_at(sleep6(Agent), Time) :-
       not(holds_at(sleep5(Agent), Time)),
       not(holds_at(sleep4(Agent), Time)),
       not(holds_at(sleep3(Agent), Time)),
       not(holds_at(sleep2(Agent), Time)),
       not(holds_at(sleep1(Agent), Time)),
       holds_at(awake(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep5(Agent)), Time), holds_at(neg(sleep4(Agent)), Time), holds_at(neg(sleep3(Agent)), Time), holds_at(neg(sleep2(Agent)), Time), holds_at(neg(sleep1(Agent)), Time), holds_at(awake(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep6(Agent), Time)).
 */
axiom(holds_at(sleep6(Agent), Time),
   
    [ holds_at(neg(sleep5(Agent)), Time),
      holds_at(neg(sleep4(Agent)), Time),
      holds_at(neg(sleep3(Agent)), Time),
      holds_at(neg(sleep2(Agent)), Time),
      holds_at(neg(sleep1(Agent)), Time),
      holds_at(awake(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(awake(Agent), Time)) :-
       ( not(holds_at(sleep1(Agent), Time)),
         not(holds_at(sleep2(Agent), Time)),
         not(holds_at(sleep3(Agent), Time)),
         not(holds_at(sleep4(Agent), Time)),
         not(holds_at(sleep5(Agent), Time)),
         not(holds_at(sleep6(Agent), Time))
       ),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep1(Agent)), Time), holds_at(neg(sleep2(Agent)), Time), holds_at(neg(sleep3(Agent)), Time), holds_at(neg(sleep4(Agent)), Time), holds_at(neg(sleep5(Agent)), Time), holds_at(neg(sleep6(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(awake(Agent)), Time)).
 */
axiom(holds_at(neg(awake(Agent)), Time),
   
    [ holds_at(neg(sleep1(Agent)), Time),
      holds_at(neg(sleep2(Agent)), Time),
      holds_at(neg(sleep3(Agent)), Time),
      holds_at(neg(sleep4(Agent)), Time),
      holds_at(neg(sleep5(Agent)), Time),
      holds_at(neg(sleep6(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(sleep1(Agent), Time);holds_at(sleep2(Agent), Time);holds_at(sleep3(Agent), Time);holds_at(sleep4(Agent), Time);holds_at(sleep5(Agent), Time);holds_at(sleep6(Agent), Time)->holds_at(awake(Agent), Time)
       ).
 */

 /*  holds_at(awake(Agent), Time) :-
       (   holds_at(sleep1(Agent), Time)
       ;   holds_at(sleep2(Agent), Time)
       ;   holds_at(sleep3(Agent), Time)
       ;   holds_at(sleep4(Agent), Time)
       ;   holds_at(sleep5(Agent), Time)
       ;   holds_at(sleep6(Agent), Time)
       ),
       allDifferent([Agent, Time]).
 */

 /*  [(holds_at(sleep1(Agent), Time);holds_at(sleep2(Agent), Time);holds_at(sleep3(Agent), Time);holds_at(sleep4(Agent), Time);holds_at(sleep5(Agent), Time);holds_at(sleep6(Agent), Time)), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(awake(Agent), Time)).
 */
axiom(holds_at(awake(Agent), Time),
   
    [  (holds_at(sleep1(Agent), Time);holds_at(sleep2(Agent), Time);holds_at(sleep3(Agent), Time);holds_at(sleep4(Agent), Time);holds_at(sleep5(Agent), Time);holds_at(sleep6(Agent), Time)),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(sleep1(Agent), Time)) :-
       not(holds_at(awake(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(awake(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(sleep1(Agent)), Time)).
 */
axiom(holds_at(neg(sleep1(Agent)), Time),
   
    [ holds_at(neg(awake(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(sleep2(Agent), Time)) :-
       not(holds_at(awake(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(awake(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(sleep2(Agent)), Time)).
 */
axiom(holds_at(neg(sleep2(Agent)), Time),
   
    [ holds_at(neg(awake(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(sleep3(Agent), Time)) :-
       not(holds_at(awake(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(awake(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(sleep3(Agent)), Time)).
 */
axiom(holds_at(neg(sleep3(Agent)), Time),
   
    [ holds_at(neg(awake(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(sleep4(Agent), Time)) :-
       not(holds_at(awake(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(awake(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(sleep4(Agent)), Time)).
 */
axiom(holds_at(neg(sleep4(Agent)), Time),
   
    [ holds_at(neg(awake(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(sleep5(Agent), Time)) :-
       not(holds_at(awake(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(awake(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(sleep5(Agent)), Time)).
 */
axiom(holds_at(neg(sleep5(Agent)), Time),
   
    [ holds_at(neg(awake(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(sleep6(Agent), Time)) :-
       not(holds_at(awake(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(awake(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(sleep6(Agent)), Time)).
 */
axiom(holds_at(neg(sleep6(Agent)), Time),
   
    [ holds_at(neg(awake(Agent)), Time),
      allDifferent([Agent, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2210
%; A number of axioms are used to specify the transitions of
%; a finite automaton.
%;--
%; Waking up causes a transition from Sleep0
%; to Sleep1:
% [agent,time]
 
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2216
% Terminates(WakeUp(agent),Sleep0(agent),time).

 /*  [] ->
       ta(Time,
          terminates(wakeUp(Agent), sleep0(Agent), Time)).
 */
axiom(terminates(wakeUp(Agent), sleep0(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2218
% [agent,time]
 % Initiates(WakeUp(agent),Sleep1(agent),time).

 /*  [] ->
       ta(Time,
          initiates(wakeUp(Agent), sleep1(Agent), Time)).
 */
axiom(initiates(wakeUp(Agent), sleep1(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2220
% [agent,time]
 % Happens(WakeUp(agent),time) -> HoldsAt(Sleep0(agent),time).

 /*  allDifferent([Agent, Time]) ->
       ( happens(wakeUp(Agent), Time)->holds_at(sleep0(Agent), Time)
       ).
 */

 /*  holds_at(sleep0(Agent), Time) :-
       happens(wakeUp(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [happens(wakeUp(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep0(Agent), Time)).
 */
axiom(holds_at(sleep0(Agent), Time),
   
    [ happens(wakeUp(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(happens(wakeUp(Agent), Time)) :-
       not(holds_at(sleep0(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep0(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, not(happens(wakeUp(Agent), Time))).
 */
axiom(not(happens(wakeUp(Agent), Time)),
   
    [ holds_at(neg(sleep0(Agent)), Time),
      allDifferent([Agent, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2222
%;--
%; Getting out of bed causes a transition from Sleep1
%; to Sleep2:
% [agent,bed,time]
 
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2226
% Terminates(RiseFrom(agent,bed),Sleep1(agent),time).

 /*  [] ->
       ta(Time,
          terminates(riseFrom(Agent, Bed),
                     sleep1(Agent),
                     Time)).
 */
axiom(terminates(riseFrom(Agent, Bed), sleep1(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2228
% [agent,bed,time]
 % Initiates(RiseFrom(agent,bed),Sleep2(agent),time).

 /*  [] ->
       ta(Time,
          initiates(riseFrom(Agent, Bed),
                    sleep2(Agent),
                    Time)).
 */
axiom(initiates(riseFrom(Agent, Bed), sleep2(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2230
% [agent,bed,time]
% Happens(RiseFrom(agent,bed),time) -> HoldsAt(Sleep1(agent),time).

 /*  allDifferent([Agent, Bed, Time]) ->
       ( happens(riseFrom(Agent, Bed), Time)->holds_at(sleep1(Agent), Time)
       ).
 */

 /*  holds_at(sleep1(Agent), Time) :-
       happens(riseFrom(Agent, Bed), Time),
       allDifferent([Agent, Bed, Time]).
 */

 /*  [happens(riseFrom(Agent, Bed), Time), allDifferent([Agent, Bed, Time])] ->
       ta(Time, holds_at(sleep1(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2231
axiom(holds_at(sleep1(Agent), Time),
   
    [ happens(riseFrom(Agent, Bed), Time),
      allDifferent([Agent, Bed, Time])
    ]).

 /*  not(happens(riseFrom(Agent, Bed), Time)) :-
       not(holds_at(sleep1(Agent), Time)),
       allDifferent([Agent, Bed, Time]).
 */

 /*  [holds_at(neg(sleep1(Agent)), Time), allDifferent([Agent, Bed, Time])] ->
       ta(Time, not(happens(riseFrom(Agent, Bed), Time))).
 */
axiom(not(happens(riseFrom(Agent, Bed), Time)),
   
    [ holds_at(neg(sleep1(Agent)), Time),
      allDifferent([Agent, Bed, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2233
%;--
%; Getting dressed causes a transition from Sleep2
%; to Sleep3, the normal state of awakeness:
% [agent,time]
 
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2237
% Terminates(GetDressed(agent),Sleep2(agent),time).

 /*  [] ->
       ta(Time,
          terminates(getDressed(Agent), sleep2(Agent), Time)).
 */
axiom(terminates(getDressed(Agent), sleep2(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2239
% [agent,time]
 % Initiates(GetDressed(agent),Sleep3(agent),time).

 /*  [] ->
       ta(Time,
          initiates(getDressed(Agent), sleep3(Agent), Time)).
 */
axiom(initiates(getDressed(Agent), sleep3(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2241
% [agent,time]
 % Happens(GetDressed(agent),time) -> HoldsAt(Sleep2(agent),time).

 /*  allDifferent([Agent, Time]) ->
       ( happens(getDressed(Agent), Time)->holds_at(sleep2(Agent), Time)
       ).
 */

 /*  holds_at(sleep2(Agent), Time) :-
       happens(getDressed(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [happens(getDressed(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep2(Agent), Time)).
 */
axiom(holds_at(sleep2(Agent), Time),
   
    [ happens(getDressed(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(happens(getDressed(Agent), Time)) :-
       not(holds_at(sleep2(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep2(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, not(happens(getDressed(Agent), Time))).
 */
axiom(not(happens(getDressed(Agent), Time)),
   
    [ holds_at(neg(sleep2(Agent)), Time),
      allDifferent([Agent, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2243
%;--
%; Getting tired causes a transition from Sleep3
%; to Sleep4:
% [agent,time]
 
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2247
% Terminates(GetTired(agent),Sleep3(agent),time).

 /*  [] ->
       ta(Time,
          terminates(getTired(Agent), sleep3(Agent), Time)).
 */
axiom(terminates(getTired(Agent), sleep3(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2249
% [agent,time]
 % Initiates(GetTired(agent),Sleep4(agent),time).

 /*  [] ->
       ta(Time,
          initiates(getTired(Agent), sleep4(Agent), Time)).
 */
axiom(initiates(getTired(Agent), sleep4(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2251
% [agent,time]
 % Happens(GetTired(agent),time) -> HoldsAt(Sleep3(agent),time).

 /*  allDifferent([Agent, Time]) ->
       ( happens(getTired(Agent), Time)->holds_at(sleep3(Agent), Time)
       ).
 */

 /*  holds_at(sleep3(Agent), Time) :-
       happens(getTired(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [happens(getTired(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep3(Agent), Time)).
 */
axiom(holds_at(sleep3(Agent), Time),
   
    [ happens(getTired(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(happens(getTired(Agent), Time)) :-
       not(holds_at(sleep3(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep3(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, not(happens(getTired(Agent), Time))).
 */
axiom(not(happens(getTired(Agent), Time)),
   
    [ holds_at(neg(sleep3(Agent)), Time),
      allDifferent([Agent, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2253
%;--
%; Getting undressed causes a transition from Sleep4
%; to Sleep5:
% [agent,time]
 
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2257
% Terminates(GetUndressed(agent),Sleep4(agent),time).

 /*  [] ->
       ta(Time,
          terminates(getUndressed(Agent), sleep4(Agent), Time)).
 */
axiom(terminates(getUndressed(Agent), sleep4(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2259
% [agent,time]
 % Initiates(GetUndressed(agent),Sleep5(agent),time).

 /*  [] ->
       ta(Time,
          initiates(getUndressed(Agent), sleep5(Agent), Time)).
 */
axiom(initiates(getUndressed(Agent), sleep5(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2261
% [agent,time]
 % Happens(GetUndressed(agent),time) -> HoldsAt(Sleep4(agent),time).

 /*  allDifferent([Agent, Time]) ->
       ( happens(getUndressed(Agent), Time)->holds_at(sleep4(Agent), Time)
       ).
 */

 /*  holds_at(sleep4(Agent), Time) :-
       happens(getUndressed(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [happens(getUndressed(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep4(Agent), Time)).
 */
axiom(holds_at(sleep4(Agent), Time),
   
    [ happens(getUndressed(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(happens(getUndressed(Agent), Time)) :-
       not(holds_at(sleep4(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep4(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, not(happens(getUndressed(Agent), Time))).
 */
axiom(not(happens(getUndressed(Agent), Time)),
   
    [ holds_at(neg(sleep4(Agent)), Time),
      allDifferent([Agent, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2263
%;--
%; Lying on a bed causes a transition from Sleep5
%; to Sleep6:
% [agent,bed,time]
 
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2267
% Terminates(LieOn(agent,bed),Sleep5(agent),time).

 /*  [] ->
       ta(Time,
          terminates(lieOn(Agent, Bed), sleep5(Agent), Time)).
 */
axiom(terminates(lieOn(Agent, Bed), sleep5(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2269
% [agent,bed,time]
 % Initiates(LieOn(agent,bed),Sleep6(agent),time).

 /*  [] ->
       ta(Time,
          initiates(lieOn(Agent, Bed), sleep6(Agent), Time)).
 */
axiom(initiates(lieOn(Agent, Bed), sleep6(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2271
% [agent,bed,time]
 % Happens(LieOn(agent,bed),time) -> HoldsAt(Sleep5(agent),time).

 /*  allDifferent([Agent, Bed, Time]) ->
       ( happens(lieOn(Agent, Bed), Time)->holds_at(sleep5(Agent), Time)
       ).
 */

 /*  holds_at(sleep5(Agent), Time) :-
       happens(lieOn(Agent, Bed), Time),
       allDifferent([Agent, Bed, Time]).
 */

 /*  [happens(lieOn(Agent, Bed), Time), allDifferent([Agent, Bed, Time])] ->
       ta(Time, holds_at(sleep5(Agent), Time)).
 */
axiom(holds_at(sleep5(Agent), Time),
   
    [ happens(lieOn(Agent, Bed), Time),
      allDifferent([Agent, Bed, Time])
    ]).

 /*  not(happens(lieOn(Agent, Bed), Time)) :-
       not(holds_at(sleep5(Agent), Time)),
       allDifferent([Agent, Bed, Time]).
 */

 /*  [holds_at(neg(sleep5(Agent)), Time), allDifferent([Agent, Bed, Time])] ->
       ta(Time, not(happens(lieOn(Agent, Bed), Time))).
 */
axiom(not(happens(lieOn(Agent, Bed), Time)),
   
    [ holds_at(neg(sleep5(Agent)), Time),
      allDifferent([Agent, Bed, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2273
%;--
%; Falling asleep causes a transition from Sleep6
%; to Sleep0:
% [agent,time]
 
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2277
% Terminates(FallAsleep(agent),Sleep6(agent),time).

 /*  [] ->
       ta(Time,
          terminates(fallAsleep(Agent), sleep6(Agent), Time)).
 */
axiom(terminates(fallAsleep(Agent), sleep6(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2279
% [agent,time]
 % Initiates(FallAsleep(agent),Sleep0(agent),time).

 /*  [] ->
       ta(Time,
          initiates(fallAsleep(Agent), sleep0(Agent), Time)).
 */
axiom(initiates(fallAsleep(Agent), sleep0(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2281
% [agent,time]
 % Happens(FallAsleep(agent),time) -> HoldsAt(Sleep6(agent),time).

 /*  allDifferent([Agent, Time]) ->
       ( happens(fallAsleep(Agent), Time)->holds_at(sleep6(Agent), Time)
       ).
 */

 /*  holds_at(sleep6(Agent), Time) :-
       happens(fallAsleep(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [happens(fallAsleep(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(sleep6(Agent), Time)).
 */
axiom(holds_at(sleep6(Agent), Time),
   
    [ happens(fallAsleep(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(happens(fallAsleep(Agent), Time)) :-
       not(holds_at(sleep6(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep6(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, not(happens(fallAsleep(Agent), Time))).
 */
axiom(not(happens(fallAsleep(Agent), Time)),
   
    [ holds_at(neg(sleep6(Agent)), Time),
      allDifferent([Agent, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2283
%;--
%; agent acts on being in state Sleep5.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2286
% fluent ActOnSleep5(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2287
fluent(actOnSleep5(ActOnSleep5_Ret)).
==> mpred_prop(actOnSleep5(agent),fluent).
==> meta_argtypes(actOnSleep5(agent)).

% noninertial ActOnSleep5
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2288
==> noninertial(actOnSleep5).
%; We reduce the number of models by asserting that
%; an agent only acts on being in state Sleep5 while in
%; that state:
% [agent,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2293
% !HoldsAt(Sleep5(agent),time) ->
% !HoldsAt(ActOnSleep5(agent),time).

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(neg(sleep5(Agent)), Time)->holds_at(neg(actOnSleep5(Agent)), Time)
       ).
 */

 /*  holds_at(neg(actOnSleep5(Agent)), Time) :-
       holds_at(neg(sleep5(Agent)), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(sleep5(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(actOnSleep5(Agent)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2294
axiom(holds_at(neg(actOnSleep5(Agent)), Time),
   
    [ holds_at(neg(sleep5(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(neg(sleep5(Agent)), Time)) :-
       not(holds_at(neg(actOnSleep5(Agent)), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(neg(actOnSleep5(Agent))), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(neg(sleep5(Agent))), Time)).
 */
axiom(holds_at(neg(neg(sleep5(Agent))), Time),
   
    [ holds_at(neg(neg(actOnSleep5(Agent))), Time),
      allDifferent([Agent, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2296
%; Undressed is like IntentionToPlay
%; ActOnSleep5 is like ActOnIntentionToPlay
%; A trigger axiom states that if an agent is in state Sleep5,
%; the agent acts on this state, the agent is in a room, and
%; a bed is at the room, the agent lies on the bed:
% [agent,room,bed,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2303
% HoldsAt(Sleep5(agent),time) &
% HoldsAt(ActOnSleep5(agent),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(bed,room),time) ->
% Happens(LieOn(agent,bed),time).

 /*  allDifferent([Agent, Time, Room, Bed]) ->
       ( holds_at(sleep5(Agent), Time), holds_at(actOnSleep5(Agent), Time), holds_at(at(Agent, Room), Time), holds_at(at(Bed, Room), Time)->happens(lieOn(Agent, Bed), Time)
       ).
 */

 /*  happens(lieOn(Agent, Bed), Time) :-
       ( holds_at(sleep5(Agent), Time),
         holds_at(actOnSleep5(Agent), Time),
         holds_at(at(Agent, Room), Time),
         holds_at(at(Bed, Room), Time)
       ),
       allDifferent([Agent, Time, Room, Bed]).
 */

 /*  [holds_at(sleep5(Agent), Time), holds_at(actOnSleep5(Agent), Time), holds_at(at(Agent, Room), Time), holds_at(at(Bed, Room), Time), allDifferent([Agent, Time, Room, Bed])] ->
       ta(Time, happens(lieOn(Agent, Bed), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2307
axiom(happens(lieOn(Agent, Bed), Time),
   
    [ holds_at(sleep5(Agent), Time),
      holds_at(actOnSleep5(Agent), Time),
      holds_at(at(Agent, Room), Time),
      holds_at(at(Bed, Room), Time),
      allDifferent([Agent, Time, Room, Bed])
    ]).

 /*  not(holds_at(sleep5(Agent), Time)) :-
       ( holds_at(actOnSleep5(Agent), Time),
         holds_at(at(Agent, Room), Time),
         holds_at(at(Bed, Room), Time)
       ),
       not(happens(lieOn(Agent, Bed), Time)),
       allDifferent([Agent, Time, Room, Bed]).
 */

 /*  [holds_at(actOnSleep5(Agent), Time), holds_at(at(Agent, Room), Time), holds_at(at(Bed, Room), Time), not(happens(lieOn(Agent, Bed), Time)), allDifferent([Agent, Time, Room, Bed])] ->
       ta(Time, holds_at(neg(sleep5(Agent)), Time)).
 */
axiom(holds_at(neg(sleep5(Agent)), Time),
   
    [ holds_at(actOnSleep5(Agent), Time),
      holds_at(at(Agent, Room), Time),
      holds_at(at(Bed, Room), Time),
      not(happens(lieOn(Agent, Bed), Time)),
      allDifferent([Agent, Time, Room, Bed])
    ]).

 /*  not(holds_at(actOnSleep5(Agent), Time)) :-
       ( holds_at(at(Agent, Room), Time),
         holds_at(at(Bed, Room), Time)
       ),
       holds_at(sleep5(Agent), Time),
       not(happens(lieOn(Agent, Bed), Time)),
       allDifferent([Agent, Time, Room, Bed]).
 */

 /*  [holds_at(at(Agent, Room), Time), holds_at(at(Bed, Room), Time), holds_at(sleep5(Agent), Time), not(happens(lieOn(Agent, Bed), Time)), allDifferent([Agent, Time, Room, Bed])] ->
       ta(Time, holds_at(neg(actOnSleep5(Agent)), Time)).
 */
axiom(holds_at(neg(actOnSleep5(Agent)), Time),
   
    [ holds_at(at(Agent, Room), Time),
      holds_at(at(Bed, Room), Time),
      holds_at(sleep5(Agent), Time),
      not(happens(lieOn(Agent, Bed), Time)),
      allDifferent([Agent, Time, Room, Bed])
    ]).

 /*  not(holds_at(at(Agent, Room), Time)) :-
       holds_at(at(Bed, Room), Time),
       holds_at(actOnSleep5(Agent), Time),
       holds_at(sleep5(Agent), Time),
       not(happens(lieOn(Agent, Bed), Time)),
       allDifferent([Agent, Time, Room, Bed]).
 */

 /*  [holds_at(at(Bed, Room), Time), holds_at(actOnSleep5(Agent), Time), holds_at(sleep5(Agent), Time), not(happens(lieOn(Agent, Bed), Time)), allDifferent([Agent, Time, Room, Bed])] ->
       ta(Time, holds_at(neg(at(Agent, Room)), Time)).
 */
axiom(holds_at(neg(at(Agent, Room)), Time),
   
    [ holds_at(at(Bed, Room), Time),
      holds_at(actOnSleep5(Agent), Time),
      holds_at(sleep5(Agent), Time),
      not(happens(lieOn(Agent, Bed), Time)),
      allDifferent([Agent, Time, Room, Bed])
    ]).

 /*  not(holds_at(at(Bed, Room), Time)) :-
       holds_at(at(Agent, Room), Time),
       holds_at(actOnSleep5(Agent), Time),
       holds_at(sleep5(Agent), Time),
       not(happens(lieOn(Agent, Bed), Time)),
       allDifferent([Agent, Time, Room, Bed]).
 */

 /*  [holds_at(at(Agent, Room), Time), holds_at(actOnSleep5(Agent), Time), holds_at(sleep5(Agent), Time), not(happens(lieOn(Agent, Bed), Time)), allDifferent([Agent, Time, Room, Bed])] ->
       ta(Time, holds_at(neg(at(Bed, Room)), Time)).
 */
axiom(holds_at(neg(at(Bed, Room)), Time),
   
    [ holds_at(at(Agent, Room), Time),
      holds_at(actOnSleep5(Agent), Time),
      holds_at(sleep5(Agent), Time),
      not(happens(lieOn(Agent, Bed), Time)),
      allDifferent([Agent, Time, Room, Bed])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2309
%; A precondition axiom states that for
%; an agent to lie on a bed,
%; the agent must be in state Sleep5,
%; the agent must act on this state, and
%; there must be a room such that
%; the agent is in the room and the bed is in the room:
% [agent,bed,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2316
% Happens(LieOn(agent,bed),time) ->
% HoldsAt(Sleep5(agent),time) &
% HoldsAt(ActOnSleep5(agent),time) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2319
% {room}% 
%  HoldsAt(At(agent,room),time) &
%  HoldsAt(At(bed,room),time).

 /*  exists([Room],
    happens(lieOn(Agent, Bed), Time) ->
       holds_at(sleep5(Agent), Time),
       holds_at(actOnSleep5(Agent), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(at(Bed, Room), Time)).
 */

 /*  not(happens(lieOn(Agent, Bed), Time)) :-
       (   not(holds_at(sleep5(Agent), Time))
       ;   not(holds_at(actOnSleep5(Agent), Time))
       ;   not(holds_at(at(Agent, Room), Time))
       ;   not(holds_at(at(Bed, Room), Time))
       ),
       some(Room, '$kolem_Fn_222'(Agent, Bed, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(sleep5(Agent), Time))
       ;   not(holds_at(actOnSleep5(Agent), Time))
       ;   not(holds_at(at(Agent, Room), Time))
       ;   not(holds_at(at(Bed, Room), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(sleep5(Agent)), Time)
       ;   holds_at(neg(actOnSleep5(Agent)), Time)
       ;   holds_at(neg(at(Agent, Room)), Time)
       ;   holds_at(neg(at(Bed, Room)), Time)
       ).
 */

 /*  [(holds_at(neg(sleep5(Agent)), Time);holds_at(neg(actOnSleep5(Agent)), Time);holds_at(neg(at(Agent, Room)), Time);holds_at(neg(at(Bed, Room)), Time)), some(Room, '$kolem_Fn_222'(Agent, Bed, Time))] ->
       ta(Time, not(happens(lieOn(Agent, Bed), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2321
axiom(not(happens(lieOn(Agent, Bed), Time)),
   
    [  (holds_at(neg(sleep5(Agent)), Time);holds_at(neg(actOnSleep5(Agent)), Time);holds_at(neg(at(Agent, Room)), Time);holds_at(neg(at(Bed, Room)), Time)),
      some(Room, '$kolem_Fn_222'(Agent, Bed, Time))
    ]).

 /*  holds_at(sleep5(Agent), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Room, '$kolem_Fn_222'(Agent, Bed, Time)).
 */

 /*  [happens(lieOn(Agent, Bed), Time), some(Room, '$kolem_Fn_222'(Agent, Bed, Time))] ->
       ta(Time, holds_at(sleep5(Agent), Time)).
 */
axiom(holds_at(sleep5(Agent), Time),
   
    [ happens(lieOn(Agent, Bed), Time),
      some(Room, '$kolem_Fn_222'(Agent, Bed, Time))
    ]).

 /*  holds_at(actOnSleep5(Agent), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Room, '$kolem_Fn_222'(Agent, Bed, Time)).
 */

 /*  [happens(lieOn(Agent, Bed), Time), some(Room, '$kolem_Fn_222'(Agent, Bed, Time))] ->
       ta(Time, holds_at(actOnSleep5(Agent), Time)).
 */
axiom(holds_at(actOnSleep5(Agent), Time),
   
    [ happens(lieOn(Agent, Bed), Time),
      some(Room, '$kolem_Fn_222'(Agent, Bed, Time))
    ]).

 /*  holds_at(at(Agent, Room), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Room, '$kolem_Fn_222'(Agent, Bed, Time)).
 */

 /*  [happens(lieOn(Agent, Bed), Time), some(Room, '$kolem_Fn_222'(Agent, Bed, Time))] ->
       ta(Time, holds_at(at(Agent, Room), Time)).
 */
axiom(holds_at(at(Agent, Room), Time),
   
    [ happens(lieOn(Agent, Bed), Time),
      some(Room, '$kolem_Fn_222'(Agent, Bed, Time))
    ]).

 /*  holds_at(at(Bed, Room), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Room, '$kolem_Fn_222'(Agent, Bed, Time)).
 */

 /*  [happens(lieOn(Agent, Bed), Time), some(Room, '$kolem_Fn_222'(Agent, Bed, Time))] ->
       ta(Time, holds_at(at(Bed, Room), Time)).
 */
axiom(holds_at(at(Bed, Room), Time),
   
    [ happens(lieOn(Agent, Bed), Time),
      some(Room, '$kolem_Fn_222'(Agent, Bed, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2323
%; (body) posture
%; agent lies on physobj.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2326
% event LieOn(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2327
event(lieOn(LieOn_Param,LieOn_Ret)).
==> mpred_prop(lieOn(agent,physobj),event).
==> meta_argtypes(lieOn(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2328
%; agent sits on physobj.

% event SitOn(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2330
event(sitOn(SitOn_Param,SitOn_Ret)).
==> mpred_prop(sitOn(agent,physobj),event).
==> meta_argtypes(sitOn(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2331
% [agent,physobj,time]
% Happens(SitOn(agent,physobj),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2333
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj,location),time).

 /*  exists([Location],
    happens(sitOn(Agent, Physobj), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Physobj, Location), Time)).
 */

 /*  not(happens(sitOn(Agent, Physobj), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj, Location), Time))
       ),
       some(Location, '$kolem_Fn_223'(Agent, Physobj, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Physobj, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj, Location)), Time)), some(Location, '$kolem_Fn_223'(Agent, Physobj, Time))] ->
       ta(Time, not(happens(sitOn(Agent, Physobj), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2335
axiom(not(happens(sitOn(Agent, Physobj), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj, Location)), Time)),
      some(Location, '$kolem_Fn_223'(Agent, Physobj, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(sitOn(Agent, Physobj), Time),
       some(Location, '$kolem_Fn_223'(Agent, Physobj, Time)).
 */

 /*  [happens(sitOn(Agent, Physobj), Time), some(Location, '$kolem_Fn_223'(Agent, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(sitOn(Agent, Physobj), Time),
      some(Location, '$kolem_Fn_223'(Agent, Physobj, Time))
    ]).

 /*  holds_at(at(Physobj, Location), Time) :-
       happens(sitOn(Agent, Physobj), Time),
       some(Location, '$kolem_Fn_223'(Agent, Physobj, Time)).
 */

 /*  [happens(sitOn(Agent, Physobj), Time), some(Location, '$kolem_Fn_223'(Agent, Physobj, Time))] ->
       ta(Time, holds_at(at(Physobj, Location), Time)).
 */
axiom(holds_at(at(Physobj, Location), Time),
   
    [ happens(sitOn(Agent, Physobj), Time),
      some(Location, '$kolem_Fn_223'(Agent, Physobj, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2337
%; agent rises from physobj.

% event RiseFrom(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2339
event(riseFrom(RiseFrom_Param,RiseFrom_Ret)).
==> mpred_prop(riseFrom(agent,physobj),event).
==> meta_argtypes(riseFrom(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2340
%; agent is lying on physobj.

% fluent LyingOn(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2342
fluent(lyingOn(LyingOn_Param,LyingOn_Ret)).
==> mpred_prop(lyingOn(agent,physobj),fluent).
==> meta_argtypes(lyingOn(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2342
%; agent is sitting on physobj.

% fluent SittingOn(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2344
fluent(sittingOn(SittingOn_Param,SittingOn_Ret)).
==> mpred_prop(sittingOn(agent,physobj),fluent).
==> meta_argtypes(sittingOn(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2344
%; agent is standing.

% fluent Standing(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2346
fluent(standing(Standing_Ret)).
==> mpred_prop(standing(agent),fluent).
==> meta_argtypes(standing(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2347
%; agent is lying down.

% fluent Lying(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2349
fluent(lying(Lying_Ret)).
==> mpred_prop(lying(agent),fluent).
==> meta_argtypes(lying(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2349
%; agent is sitting.

% fluent Sitting(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2351
fluent(sitting(Sitting_Ret)).
==> mpred_prop(sitting(agent),fluent).
==> meta_argtypes(sitting(agent)).

% noninertial Lying
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2352
==> noninertial(lying).

% noninertial Sitting
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2353
==> noninertial(sitting).
%; At any time, an agent is either lying, sitting, or standing:

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2355
% xor Lying, Sitting, Standing
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2356
==> xor([lying,sitting,standing]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2357
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% HoldsAt(Lying(agent),time).

 /*  allDifferent([Agent, Physobj, Time]) ->
       ( holds_at(lyingOn(Agent, Physobj), Time)->holds_at(lying(Agent), Time)
       ).
 */

 /*  holds_at(lying(Agent), Time) :-
       holds_at(lyingOn(Agent, Physobj), Time),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(lyingOn(Agent, Physobj), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time, holds_at(lying(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2359
axiom(holds_at(lying(Agent), Time),
   
    [ holds_at(lyingOn(Agent, Physobj), Time),
      allDifferent([Agent, Physobj, Time])
    ]).

 /*  not(holds_at(lyingOn(Agent, Physobj), Time)) :-
       not(holds_at(lying(Agent), Time)),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(neg(lying(Agent)), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj)), Time)).
 */
axiom(holds_at(neg(lyingOn(Agent, Physobj)), Time),
   
    [ holds_at(neg(lying(Agent)), Time),
      allDifferent([Agent, Physobj, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2361
% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% HoldsAt(Sitting(agent),time).

 /*  allDifferent([Agent, Physobj, Time]) ->
       ( holds_at(sittingOn(Agent, Physobj), Time)->holds_at(sitting(Agent), Time)
       ).
 */

 /*  holds_at(sitting(Agent), Time) :-
       holds_at(sittingOn(Agent, Physobj), Time),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(sittingOn(Agent, Physobj), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time, holds_at(sitting(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2363
axiom(holds_at(sitting(Agent), Time),
   
    [ holds_at(sittingOn(Agent, Physobj), Time),
      allDifferent([Agent, Physobj, Time])
    ]).

 /*  not(holds_at(sittingOn(Agent, Physobj), Time)) :-
       not(holds_at(sitting(Agent), Time)),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(neg(sitting(Agent)), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj)), Time)).
 */
axiom(holds_at(neg(sittingOn(Agent, Physobj)), Time),
   
    [ holds_at(neg(sitting(Agent)), Time),
      allDifferent([Agent, Physobj, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2365
%; State constraints represent that an agent can lie or sit
%; on at most one object at a time:
% [agent,physobj1,physobj2,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2368
% HoldsAt(LyingOn(agent,physobj1),time) &
% HoldsAt(LyingOn(agent,physobj2),time) ->
% physobj1=physobj2.

 /*  allDifferent([Agent, Physobj1, Time, Physobj2]) ->
       ( holds_at(lyingOn(Agent, Physobj1), Time), holds_at(lyingOn(Agent, Physobj2), Time)->Physobj1=Physobj2
       ).
 */

 /*  not(holds_at(lyingOn(Agent, Physobj1), Time)) :-
       holds_at(lyingOn(Agent, Physobj2), Time),
       not(equals(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Time, Physobj2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Physobj1, Physobj2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Physobj1=Physobj2)).
 */

 /*  [holds_at(lyingOn(Agent, Physobj2), Time), not(call(Physobj1=Physobj2)), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj1)), Time)).
 */

 /*  [holds_at(lyingOn(Agent, Physobj2), Time), holds_at(neg(call(Physobj1=Physobj2)), Time), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2370
axiom(holds_at(neg(lyingOn(Agent, Physobj1)), Time),
   
    [ holds_at(lyingOn(Agent, Physobj2), Time),
      holds_at(neg(call(Physobj1=Physobj2)), Time),
      allDifferent([Agent, Physobj1, Time, Physobj2])
    ]).

 /*  not(holds_at(lyingOn(Agent, Physobj2), Time)) :-
       holds_at(lyingOn(Agent, Physobj1), Time),
       not(equals(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Time, Physobj2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Physobj1, Physobj2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Physobj1=Physobj2)).
 */

 /*  [holds_at(lyingOn(Agent, Physobj1), Time), not(call(Physobj1=Physobj2)), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj2)), Time)).
 */

 /*  [holds_at(lyingOn(Agent, Physobj1), Time), holds_at(neg(call(Physobj1=Physobj2)), Time), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj2)), Time)).
 */
axiom(holds_at(neg(lyingOn(Agent, Physobj2)), Time),
   
    [ holds_at(lyingOn(Agent, Physobj1), Time),
      holds_at(neg(call(Physobj1=Physobj2)), Time),
      allDifferent([Agent, Physobj1, Time, Physobj2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2372
% [agent,physobj1,physobj2,time]
% HoldsAt(SittingOn(agent,physobj1),time) &
% HoldsAt(SittingOn(agent,physobj2),time) ->
% physobj1=physobj2.

 /*  allDifferent([Agent, Physobj1, Time, Physobj2]) ->
       ( holds_at(sittingOn(Agent, Physobj1), Time), holds_at(sittingOn(Agent, Physobj2), Time)->Physobj1=Physobj2
       ).
 */

 /*  not(holds_at(sittingOn(Agent, Physobj1), Time)) :-
       holds_at(sittingOn(Agent, Physobj2), Time),
       not(equals(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Time, Physobj2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Physobj1, Physobj2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Physobj1=Physobj2)).
 */

 /*  [holds_at(sittingOn(Agent, Physobj2), Time), not(call(Physobj1=Physobj2)), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj1)), Time)).
 */

 /*  [holds_at(sittingOn(Agent, Physobj2), Time), holds_at(neg(call(Physobj1=Physobj2)), Time), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2375
axiom(holds_at(neg(sittingOn(Agent, Physobj1)), Time),
   
    [ holds_at(sittingOn(Agent, Physobj2), Time),
      holds_at(neg(call(Physobj1=Physobj2)), Time),
      allDifferent([Agent, Physobj1, Time, Physobj2])
    ]).

 /*  not(holds_at(sittingOn(Agent, Physobj2), Time)) :-
       holds_at(sittingOn(Agent, Physobj1), Time),
       not(equals(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Time, Physobj2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Physobj1, Physobj2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Physobj1=Physobj2)).
 */

 /*  [holds_at(sittingOn(Agent, Physobj1), Time), not(call(Physobj1=Physobj2)), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj2)), Time)).
 */

 /*  [holds_at(sittingOn(Agent, Physobj1), Time), holds_at(neg(call(Physobj1=Physobj2)), Time), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj2)), Time)).
 */
axiom(holds_at(neg(sittingOn(Agent, Physobj2)), Time),
   
    [ holds_at(sittingOn(Agent, Physobj1), Time),
      holds_at(neg(call(Physobj1=Physobj2)), Time),
      allDifferent([Agent, Physobj1, Time, Physobj2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2377
%; An effect axiom states that if an agent is standing and
%; lies on a physical object, the agent will be lying on
%; the physical object:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2381
% HoldsAt(Standing(agent),time) ->
% Initiates(LieOn(agent,physobj),
%           LyingOn(agent,physobj),
%           time).

 /*  [holds_at(standing(Agent), Time)] ->
       ta(Time,
          initiates(lieOn(Agent, Physobj),
                    lyingOn(Agent, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2384
axiom(initiates(lieOn(Agent, Physobj), lyingOn(Agent, Physobj), Time),
    [holds_at(standing(Agent), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2386
%; An effect axiom states that if an agent
%; lies on a physical object, the agent will no longer
%; be standing:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2390
% Terminates(LieOn(agent,physobj),
%            Standing(agent),
%            time).

 /*  [] ->
       ta(Time,
          terminates(lieOn(Agent, Physobj),
                     standing(Agent),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2392
axiom(terminates(lieOn(Agent, Physobj), standing(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2394
%; An effect axiom states that if an agent is standing and
%; sits on a physical object, the agent will be sitting on
%; the physical object:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2398
% HoldsAt(Standing(agent),time) ->
% Initiates(SitOn(agent,physobj),
%           SittingOn(agent,physobj),
%           time).

 /*  [holds_at(standing(Agent), Time)] ->
       ta(Time,
          initiates(sitOn(Agent, Physobj),
                    sittingOn(Agent, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2401
axiom(initiates(sitOn(Agent, Physobj), sittingOn(Agent, Physobj), Time),
    [holds_at(standing(Agent), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2403
%; An effect axiom states that if an agent
%; sits on a physical object, the agent will no longer
%; be standing:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2407
% Terminates(SitOn(agent,physobj),
%            Standing(agent),
%            time).

 /*  [] ->
       ta(Time,
          terminates(sitOn(Agent, Physobj),
                     standing(Agent),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2409
axiom(terminates(sitOn(Agent, Physobj), standing(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2411
%; An effect axiom states that if an agent
%; is sitting or lying on a physical object and
%; the agent rises from the physical object,
%; the agent will be standing:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2416
% (HoldsAt(SittingOn(agent,physobj),time) |
%  HoldsAt(LyingOn(agent,physobj),time)) ->
% Initiates(RiseFrom(agent,physobj),
%           Standing(agent),
%           time).

 /*  [(holds_at(sittingOn(Agent, Physobj), Time);holds_at(lyingOn(Agent, Physobj), Time))] ->
       ta(Time,
          initiates(riseFrom(Agent, Physobj),
                    standing(Agent),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2420
axiom(initiates(riseFrom(Agent, Physobj), standing(Agent), Time),
   
    [  (holds_at(sittingOn(Agent, Physobj), Time);holds_at(lyingOn(Agent, Physobj), Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2422
%; An effect axiom states that if an agent is sitting on
%; a physical object and the agent rises from the physical
%; object, the agent will no longer be sitting on the
%; physical object:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2427
% HoldsAt(SittingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            SittingOn(agent,physobj),
%            time).

 /*  [holds_at(sittingOn(Agent, Physobj), Time)] ->
       ta(Time,
          terminates(riseFrom(Agent, Physobj),
                     sittingOn(Agent, Physobj),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2430
axiom(terminates(riseFrom(Agent, Physobj), sittingOn(Agent, Physobj), Time),
    [holds_at(sittingOn(Agent, Physobj), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2432
%; An effect axiom states that if an agent is lying on
%; a physical object and the agent rises from the physical
%; object, the agent will no longer be lying on the
%; physical object:
% [agent,physobj,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2437
% HoldsAt(LyingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            LyingOn(agent,physobj),
%            time).

 /*  [holds_at(lyingOn(Agent, Physobj), Time)] ->
       ta(Time,
          terminates(riseFrom(Agent, Physobj),
                     lyingOn(Agent, Physobj),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2440
axiom(terminates(riseFrom(Agent, Physobj), lyingOn(Agent, Physobj), Time),
    [holds_at(lyingOn(Agent, Physobj), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2442
%; dressing
%; agent gets undressed.

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2445
% event GetDressed(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2446
event(getDressed(GetDressed_Ret)).
==> mpred_prop(getDressed(agent),event).
==> meta_argtypes(getDressed(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2446
%; agent gets dressed.

% event GetUndressed(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2448
event(getUndressed(GetUndressed_Ret)).
==> mpred_prop(getUndressed(agent),event).
==> meta_argtypes(getUndressed(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2448
%; agent is dressed.

% fluent Dressed(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2450
fluent(dressed(Dressed_Ret)).
==> mpred_prop(dressed(agent),fluent).
==> meta_argtypes(dressed(agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2451
%; Effect axioms deal with getting dressed and undressed:
% [agent,time]
 % Initiates(GetDressed(agent),Dressed(agent),time).

 /*  [] ->
       ta(Time,
          initiates(getDressed(Agent), dressed(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2452
axiom(initiates(getDressed(Agent), dressed(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2453
% [agent,time]
 % Terminates(GetUndressed(agent),Dressed(agent),time).

 /*  [] ->
       ta(Time,
          terminates(getUndressed(Agent), dressed(Agent), Time)).
 */
axiom(terminates(getUndressed(Agent), dressed(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2455
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Sleeping.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:2004c,
%;   author = "Erik T. Mueller",
%;   year = "2004",
%;   title = "Understanding script-based stories using commonsense reasoning",
%;   journal = "Cognitive Systems Research",
%;   volume = "5",
%;   number = "4",
%;   pages = "307--340",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2484
% option modeldiff on
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2485
:- set_ec_option(modeldiff, on).
:- if(false).
:- endif.

% ignore Love, ThreatenedBy
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2487
ignore(love).
ignore(threatenedBy).

% ignore LookOutOnto, Floor, BuildingOf, SkyOf, GroundOf
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2488
ignore(lookOutOnto).
ignore(floor).
ignore(buildingOf).
ignore(skyOf).
ignore(groundOf).

% ignore Inside, Near
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2489
ignore(inside).
ignore(near).

% ignore See
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2490
ignore(see).

% ignore ActOnSleep5
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2492
ignore(actOnSleep5).

% option renaming off
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2494
:- set_ec_option(renaming, off).
:- if(false).
:- endif.

% load foundations/Root.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2496
:- load_e('foundations/Root.e', changed).
:- if(false).
:- endif.

% load foundations/EC.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2497
:- load_e('foundations/EC.e', changed).
:- if(false).
:- endif.

% load answers/Mueller2003/Ontology.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2498
:- load_e('answers/Mueller2003/Ontology.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2003/Ontology.e').
:- endif.

% load answers/Mueller2004c/RTSpaceM.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2499
:- load_e('answers/Mueller2004c/RTSpaceM.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2004c/RTSpaceM.e').
:- endif.

% load answers/Mueller2004c/OTSpaceM.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2500
:- load_e('answers/Mueller2004c/OTSpaceM.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2004c/OTSpaceM.e').
:- endif.

% load answers/Mueller2004c/Cognition.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2501
:- load_e('answers/Mueller2004c/Cognition.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2004c/Cognition.e').
:- endif.

% load answers/Mueller2003/Sleep.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2502
:- load_e('answers/Mueller2003/Sleep.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2003/Sleep.e').
:- endif.

% door Door1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2504
==> t(door,door1).

% room Room0
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2506
==> t(room,room0).

% room Room1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2508
==> t(room,room1).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2509
% Side1(Door1)=Room0.
side1(door1,room0).

 /*  axiom_head(Axiom_head_Ret) ->
       side1(door1, room0).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side1(door1, room0), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2510
% Side2(Door1)=Room1.
side2(door1,room1).

 /*  axiom_head(Axiom_head_Ret) ->
       side2(door1, room1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side2(door1, room1), Axiom_head_Ret).
 */

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2512
% agent Sleeper1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2513
==> t(agent,sleeper1).

% bed Bed1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2515
==> t(bed,bed1).

% outside Outside1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2517
==> t(outside,outside1).
%; initial state
% [agent,object]
 % !HoldsAt(Holding(agent,object),0).
 %  not(initially(holding(Agent,Object))).

 /*  [] ->
       ta(Ta_Param, not(initially(holding(Agent, Object)))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2519
axiom(not(initially(holding(Agent, Object))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2520
% [agent,physobj]
 % !HoldsAt(SittingOn(agent,physobj),0).
 %  not(initially(sittingOn(Agent,Physobj))).

 /*  [] ->
       ta(Ta_Param, not(initially(sittingOn(Agent, Physobj)))).
 */
axiom(not(initially(sittingOn(Agent, Physobj))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2521
% [agent,physobj]
 % !HoldsAt(LyingOn(agent,physobj),0).
 %  not(initially(lyingOn(Agent,Physobj))).

 /*  [] ->
       ta(Ta_Param, not(initially(lyingOn(Agent, Physobj)))).
 */
axiom(not(initially(lyingOn(Agent, Physobj))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2522
% HoldsAt(Dressed(Sleeper1),0).

 /*  [] ->
       ta(Ta_Param, initially(dressed(sleeper1))).
 */
axiom(initially(dressed(sleeper1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2523
% HoldsAt(Awake(Sleeper1),0).

 /*  [] ->
       ta(Ta_Param, initially(awake(sleeper1))).
 */
axiom(initially(awake(sleeper1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2524
% HoldsAt(Sleep3(Sleeper1),0).

 /*  [] ->
       ta(Ta_Param, initially(sleep3(sleeper1))).
 */
axiom(initially(sleep3(sleeper1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2525
% HoldsAt(Standing(Sleeper1),0).

 /*  [] ->
       ta(Ta_Param, initially(standing(sleeper1))).
 */
axiom(initially(standing(sleeper1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2526
% HoldsAt(DoorUnlocked(Door1),0).

 /*  [] ->
       ta(Ta_Param, initially(doorUnlocked(door1))).
 */
axiom(initially(doorUnlocked(door1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2527
% HoldsAt(DoorIsOpen(Door1),0).

 /*  [] ->
       ta(Ta_Param, initially(doorIsOpen(door1))).
 */
axiom(initially(doorIsOpen(door1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2528
% HoldsAt(At(Sleeper1,Room0),0).

 /*  [] ->
       ta(Ta_Param, initially(at(sleeper1, room0))).
 */
axiom(initially(at(sleeper1, room0)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2529
% HoldsAt(At(Bed1,Room1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(bed1, room1))).
 */
axiom(initially(at(bed1, room1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2531
%; narrative


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2532
% Happens(GetTired(Sleeper1),0).

 /*  axiom_head(0) ->
       is_time(0).
 */

 /*  fix_axiom_head(0) ->
       holds_at(is_time(0), 0).
 */

 /*  [holds_at(is_time(0), t)] ->
       ta(0, happens(getTired(sleeper1), t)).
 */
axiom(happens(getTired(sleeper1), t),
    [holds_at(is_time(0), t)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2533
% Happens(WalkThroughDoor12(Sleeper1,Door1),1).

 /*  axiom_head(1) ->
       is_time(1).
 */

 /*  fix_axiom_head(1) ->
       holds_at(is_time(1), 1).
 */

 /*  [holds_at(is_time(1), start), b(t, start), ignore(t+1==start)] ->
       ta(1, happens(walkThroughDoor12(sleeper1, door1), start)).
 */
axiom(happens(walkThroughDoor12(sleeper1, door1), start),
    [holds_at(is_time(1), start), b(t, start)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2534
% Happens(GetUndressed(Sleeper1),2).

 /*  axiom_head(2) ->
       is_time(2).
 */

 /*  fix_axiom_head(2) ->
       holds_at(is_time(2), 2).
 */

 /*  [holds_at(is_time(2), t2), b(t, t2), ignore(t+2==t2)] ->
       ta(2, happens(getUndressed(sleeper1), t2)).
 */
axiom(happens(getUndressed(sleeper1), t2),
    [holds_at(is_time(2), t2), b(t, t2)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2535
% Happens(LieOn(Sleeper1,Bed1),3).

 /*  axiom_head(3) ->
       is_time(3).
 */

 /*  fix_axiom_head(3) ->
       holds_at(is_time(3), 3).
 */

 /*  [holds_at(is_time(3), t3), b(t, t3), ignore(t+3==t3)] ->
       ta(3, happens(lieOn(sleeper1, bed1), t3)).
 */
axiom(happens(lieOn(sleeper1, bed1), t3),
    [holds_at(is_time(3), t3), b(t, t3)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2536
% Happens(FallAsleep(Sleeper1),4).

 /*  axiom_head(4) ->
       is_time(4).
 */

 /*  fix_axiom_head(4) ->
       holds_at(is_time(4), 4).
 */

 /*  [holds_at(is_time(4), t4), b(t, t4), ignore(t+4==t4)] ->
       ta(4, happens(fallAsleep(sleeper1), t4)).
 */
axiom(happens(fallAsleep(sleeper1), t4),
    [holds_at(is_time(4), t4), b(t, t4)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2537
% Happens(Dream(Sleeper1),5).

 /*  axiom_head(5) ->
       is_time(5).
 */

 /*  fix_axiom_head(5) ->
       holds_at(is_time(5), 5).
 */

 /*  [holds_at(is_time(5), t5), b(t, t5), ignore(t+5==t5)] ->
       ta(5, happens(dream(sleeper1), t5)).
 */
axiom(happens(dream(sleeper1), t5),
    [holds_at(is_time(5), t5), b(t, t5)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2538
% Happens(WakeUp(Sleeper1),6).

 /*  axiom_head(6) ->
       is_time(6).
 */

 /*  fix_axiom_head(6) ->
       holds_at(is_time(6), 6).
 */

 /*  [holds_at(is_time(6), t6), b(t, t6), ignore(t+6==t6)] ->
       ta(6, happens(wakeUp(sleeper1), t6)).
 */
axiom(happens(wakeUp(sleeper1), t6),
    [holds_at(is_time(6), t6), b(t, t6)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2539
% Happens(RiseFrom(Sleeper1,Bed1),7).

 /*  axiom_head(7) ->
       is_time(7).
 */

 /*  fix_axiom_head(7) ->
       holds_at(is_time(7), 7).
 */

 /*  [holds_at(is_time(7), t7), b(t, t7), ignore(t+7==t7)] ->
       ta(7, happens(riseFrom(sleeper1, bed1), t7)).
 */
axiom(happens(riseFrom(sleeper1, bed1), t7),
    [holds_at(is_time(7), t7), b(t, t7)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2540
% Happens(GetDressed(Sleeper1),8).

 /*  axiom_head(8) ->
       is_time(8).
 */

 /*  fix_axiom_head(8) ->
       holds_at(is_time(8), 8).
 */

 /*  [holds_at(is_time(8), t8), b(t, t8), ignore(t+8==t8)] ->
       ta(8, happens(getDressed(sleeper1), t8)).
 */
axiom(happens(getDressed(sleeper1), t8),
    [holds_at(is_time(8), t8), b(t, t8)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2541
% Happens(WalkThroughDoor21(Sleeper1,Door1),9).

 /*  axiom_head(9) ->
       is_time(9).
 */

 /*  fix_axiom_head(9) ->
       holds_at(is_time(9), 9).
 */

 /*  [holds_at(is_time(9), t9), b(t, t9), ignore(t+9==t9)] ->
       ta(9, happens(walkThroughDoor21(sleeper1, door1), t9)).
 */
axiom(happens(walkThroughDoor21(sleeper1, door1), t9),
    [holds_at(is_time(9), t9), b(t, t9)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2543
% range time 0 10
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2544
==> range(time,0,10).

% range offset 0 0
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2545
==> range(offset,0,0).

% range diameter 0 0
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2546
==> range(diameter,0,0).

% completion Happens
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2548
==> completion(happens).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Rest.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:InPress,
%;   author = "Erik T. Mueller",
%;   year = "in press",
%;   title = "Modelling space and time in narratives about restaurants",
%;   journal = "Literary and Linguistic Computing",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2575
% option renaming off
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2576
:- set_ec_option(renaming, off).
:- if(false).
:- endif.

% option encoding 3
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2577
:- set_ec_option(encoding, 3).
:- if(false).
:- endif.

% load foundations/Root.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2579
:- load_e('foundations/Root.e', changed).
:- if(false).
:- endif.

% load foundations/EC.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2580
:- load_e('foundations/EC.e', changed).
:- if(false).
:- endif.

% load answers/Mueller2003/Ontology.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2581
:- load_e('answers/Mueller2003/Ontology.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2003/Ontology.e').
:- endif.

% load answers/MuellerInPress/RepRest.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2582
:- load_e('answers/MuellerInPress/RepRest.e', changed).
:- if(false).
 %  load(changed,'answers/MuellerInPress/RepRest.e').
:- endif.

% door MainEntrance1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2584
==> t(door,mainEntrance1).
%; room-scale topological space

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2586
% outside Street1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2587
==> t(outside,street1).

% room DiningRoom1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2588
==> t(room,diningRoom1).

% door KitchenDoor1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2589
==> t(door,kitchenDoor1).

% room Kitchen1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2590
==> t(room,kitchen1).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2590
% Side1(MainEntrance1)=Street1.
side1(mainEntrance1,street1).

 /*  axiom_head(Axiom_head_Ret) ->
       side1(mainEntrance1, street1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side1(mainEntrance1, street1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2591
% Side2(MainEntrance1)=DiningRoom1.
side2(mainEntrance1,diningRoom1).

 /*  axiom_head(Axiom_head_Ret) ->
       side2(mainEntrance1, diningRoom1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side2(mainEntrance1, diningRoom1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2592
% Side1(KitchenDoor1)=DiningRoom1.
side1(kitchenDoor1,diningRoom1).

 /*  axiom_head(Axiom_head_Ret) ->
       side1(kitchenDoor1, diningRoom1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side1(kitchenDoor1, diningRoom1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2593
% Side2(KitchenDoor1)=Kitchen1.
side2(kitchenDoor1,kitchen1).

 /*  axiom_head(Axiom_head_Ret) ->
       side2(kitchenDoor1, kitchen1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side2(kitchenDoor1, kitchen1), Axiom_head_Ret).
 */

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2595
% agent Customer1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2596
==> t(agent,customer1).

% menu Menu1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2597
==> t(menu,menu1).

% chair Chair1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2598
==> t(chair,chair1).

% food Food1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2599
==> t(food,food1).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2599
% HoldsAt(At(Customer1,Street1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(customer1, street1))).
 */
axiom(initially(at(customer1, street1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2600
% HoldsAt(Hungry(Customer1),0).

 /*  [] ->
       ta(Ta_Param, initially(hungry(customer1))).
 */
axiom(initially(hungry(customer1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2601
% HoldsAt(At(Chair1,DiningRoom1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(chair1, diningRoom1))).
 */
axiom(initially(at(chair1, diningRoom1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2602
% HoldsAt(At(Menu1,DiningRoom1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(menu1, diningRoom1))).
 */
axiom(initially(at(menu1, diningRoom1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2603
% HoldsAt(On(Menu1,Table1),0).

 /*  [] ->
       ta(Ta_Param, initially(on(menu1, table1))).
 */
axiom(initially(on(menu1, table1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2604
% HoldsAt(At(Food1,Kitchen1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(food1, kitchen1))).
 */
axiom(initially(at(food1, kitchen1)),
    []).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2606
% waiter Waiter1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2607
==> t(waiter,waiter1).

% cook Cook1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2608
==> t(cook,cook1).
%; props

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2610
% table Table1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2611
==> t(table,table1).

% bill Bill1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2612
==> t(bill,bill1).
%; restaurant

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2614
% restaurant Restaurant1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2615
==> t(restaurant,restaurant1).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2615
% CookOf(Restaurant1)=Cook1.
cookOf(restaurant1,cook1).

 /*  axiom_head(Axiom_head_Ret) ->
       cookOf(restaurant1, cook1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(cookOf(restaurant1, cook1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2616
% TableOf(Restaurant1)=Table1.
tableOf(restaurant1,table1).

 /*  axiom_head(Axiom_head_Ret) ->
       tableOf(restaurant1, table1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(tableOf(restaurant1, table1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2617
% WaiterOf(Restaurant1)=Waiter1.
waiterOf(restaurant1,waiter1).

 /*  axiom_head(Axiom_head_Ret) ->
       waiterOf(restaurant1, waiter1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(waiterOf(restaurant1, waiter1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2618
% KitchenDoorOf(Restaurant1)=KitchenDoor1.
kitchenDoorOf(restaurant1,kitchenDoor1).

 /*  axiom_head(Axiom_head_Ret) ->
       kitchenDoorOf(restaurant1, kitchenDoor1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(kitchenDoorOf(restaurant1, kitchenDoor1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2619
% BillOf(Restaurant1)=Bill1.
billOf(restaurant1,bill1).

 /*  axiom_head(Axiom_head_Ret) ->
       billOf(restaurant1, bill1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(billOf(restaurant1, bill1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2621
%; prune

% sort ona, onb
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2623
==> sort(ona).
==> sort(onb).

% fluent! On(ona,onb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2624
fluent(on(On_Param,On_Ret)).
==> mpred_prop(on(ona,onb),fluent).
==> meta_argtypes(on(ona,onb)).

% event! PlaceOn(agent,ona,onb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2625
event(placeOn(PlaceOn_Param,_,PlaceOn_Ret)).
==> mpred_prop(placeOn(agent,ona,onb),event).
==> meta_argtypes(placeOn(agent,ona,onb)).

% event! TakeOffOf(agent,ona,onb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2626
event(takeOffOf(TakeOffOf_Param,_,TakeOffOf_Ret)).
==> mpred_prop(takeOffOf(agent,ona,onb),event).
==> meta_argtypes(takeOffOf(agent,ona,onb)).

% sort ordera, orderb, orderc
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2628
==> sort(ordera).
==> sort(orderb).
==> sort(orderc).

% event! Order(ordera,orderb,orderc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2629
event(order(Order_Param,_,Order_Ret)).
==> mpred_prop(order(ordera,orderb,orderc),event).
==> meta_argtypes(order(ordera,orderb,orderc)).

% fluent! KnowOrder(orderb,ordera,orderc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2630
fluent(knowOrder(KnowOrder_Param,_,KnowOrder_Ret)).
==> mpred_prop(knowOrder(orderb,ordera,orderc),fluent).
==> meta_argtypes(knowOrder(orderb,ordera,orderc)).

% sort requesta, requestb, requestc
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2632
==> sort(requesta).
==> sort(requestb).
==> sort(requestc).

% event! Request(requesta,requestb,requestc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2633
event(request(Request_Param,_,Request_Ret)).
==> mpred_prop(request(requesta,requestb,requestc),event).
==> meta_argtypes(request(requesta,requestb,requestc)).

% fluent! KnowRequest(requestb,requesta,requestc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2634
fluent(knowRequest(KnowRequest_Param,
		   _,
		   KnowRequest_Ret)).
==> mpred_prop(knowRequest(requestb,requesta,requestc),fluent).
==> meta_argtypes(knowRequest(requestb,requesta,requestc)).

% sort holda, holdb, holdc
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2636
==> sort(holda).
==> sort(holdb).
==> sort(holdc).

% event! TakeOffOf(holda,holdb,holdc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2637
event(takeOffOf(TakeOffOf_Param,_,TakeOffOf_Ret)).
==> mpred_prop(takeOffOf(holda,holdb,holdc),event).
==> meta_argtypes(takeOffOf(holda,holdb,holdc)).

% event! PickUp(holda,holdb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2638
event(pickUp(PickUp_Param,PickUp_Ret)).
==> mpred_prop(pickUp(holda,holdb),event).
==> meta_argtypes(pickUp(holda,holdb)).

% event! LetGoOf(holda,holdb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2639
event(letGoOf(LetGoOf_Param,LetGoOf_Ret)).
==> mpred_prop(letGoOf(holda,holdb),event).
==> meta_argtypes(letGoOf(holda,holdb)).

% event! Hold(holda,holdb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2640
event(hold(Hold_Param,Hold_Ret)).
==> mpred_prop(hold(holda,holdb),event).
==> meta_argtypes(hold(holda,holdb)).

% fluent! Holding(holda,holdb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2641
fluent(holding(Holding_Param,Holding_Ret)).
==> mpred_prop(holding(holda,holdb),fluent).
==> meta_argtypes(holding(holda,holdb)).

% sort sita, sitb
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2643
==> sort(sita).
==> sort(sitb).

% event! LieOn(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2644
event(lieOn(LieOn_Param,LieOn_Ret)).
==> mpred_prop(lieOn(sita,sitb),event).
==> meta_argtypes(lieOn(sita,sitb)).

% event! SitOn(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2645
event(sitOn(SitOn_Param,SitOn_Ret)).
==> mpred_prop(sitOn(sita,sitb),event).
==> meta_argtypes(sitOn(sita,sitb)).

% event! RiseFrom(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2646
event(riseFrom(RiseFrom_Param,RiseFrom_Ret)).
==> mpred_prop(riseFrom(sita,sitb),event).
==> meta_argtypes(riseFrom(sita,sitb)).

% fluent! LyingOn(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2647
fluent(lyingOn(LyingOn_Param,LyingOn_Ret)).
==> mpred_prop(lyingOn(sita,sitb),fluent).
==> meta_argtypes(lyingOn(sita,sitb)).

% fluent! SittingOn(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2648
fluent(sittingOn(SittingOn_Param,SittingOn_Ret)).
==> mpred_prop(sittingOn(sita,sitb),fluent).
==> meta_argtypes(sittingOn(sita,sitb)).

% sort greeta, greetb
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2650
==> sort(greeta).
==> sort(greetb).

% event! Greet(greeta,greetb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2651
event(greet(Greet_Param,Greet_Ret)).
==> mpred_prop(greet(greeta,greetb),event).
==> meta_argtypes(greet(greeta,greetb)).

% ona! Menu1, Food1, Bill1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2653
==> t(ona,menu1).
==> t(ona,food1).
==> t(ona,bill1).

% onb! Table1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2654
==> t(onb,table1).

% ordera! Customer1, Waiter1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2655
==> t(ordera,customer1).
==> t(ordera,waiter1).

% orderb! Waiter1, Cook1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2656
==> t(orderb,waiter1).
==> t(orderb,cook1).

% orderc! Food1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2657
==> t(orderc,food1).

% requesta! Customer1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2658
==> t(requesta,customer1).

% requestb! Waiter1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2659
==> t(requestb,waiter1).

% requestc! Bill1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2660
==> t(requestc,bill1).

% holda! Customer1, Waiter1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2661
==> t(holda,customer1).
==> t(holda,waiter1).

% holdb! Menu1, Food1, Bill1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2662
==> t(holdb,menu1).
==> t(holdb,food1).
==> t(holdb,bill1).

% holdc! Table1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2663
==> t(holdc,table1).

% sita! Customer1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2664
==> t(sita,customer1).

% sitb! Chair1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2665
==> t(sitb,chair1).

% greeta! Customer1, Waiter1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2666
==> t(greeta,customer1).
==> t(greeta,waiter1).

% greetb! Customer1, Waiter1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2667
==> t(greetb,customer1).
==> t(greetb,waiter1).
%; initial situation


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2669
% HoldsAt(At(Waiter1,DiningRoom1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(waiter1, diningRoom1))).
 */
axiom(initially(at(waiter1, diningRoom1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2670
% HoldsAt(At(Cook1,Kitchen1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(cook1, kitchen1))).
 */
axiom(initially(at(cook1, kitchen1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2671
% HoldsAt(At(Table1,DiningRoom1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(table1, diningRoom1))).
 */
axiom(initially(at(table1, diningRoom1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2672
% !HoldsAt(On(Bill1,Table1),0).
 %  not(initially(on(bill1,table1))).

 /*  [] ->
       ta(Ta_Param, not(initially(on(bill1, table1)))).
 */
axiom(not(initially(on(bill1, table1))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2673
% HoldsAt(At(Bill1,DiningRoom1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(bill1, diningRoom1))).
 */
axiom(initially(at(bill1, diningRoom1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2674
% [agent]
 % HoldsAt(Standing(agent),0).

 /*  [] ->
       ta(Ta_Param, initially(standing(Agent))).
 */
axiom(initially(standing(Agent)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2675
% [agent,object]
 % !HoldsAt(Holding(agent,object),0).
 %  not(initially(holding(Agent,Object))).

 /*  [] ->
       ta(Ta_Param, not(initially(holding(Agent, Object)))).
 */
axiom(not(initially(holding(Agent, Object))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2676
% [agent1,agent2,physobj]
 % !HoldsAt(KnowOrder(agent1,agent2,physobj),0).
 %  not(initially(knowOrder(Agent1,Agent2,Physobj))).

 /*  [] ->
       ta(Ta_Param,
          not(initially(knowOrder(Agent1, Agent2, Physobj)))).
 */
axiom(not(initially(knowOrder(Agent1, Agent2, Physobj))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2677
% [agent1,agent2,physobj]
 % !HoldsAt(KnowRequest(agent1,agent2,physobj),0).
 %  not(initially(knowRequest(Agent1,Agent2,Physobj))).

 /*  [] ->
       ta(Ta_Param,
          not(initially(knowRequest(Agent1, Agent2, Physobj)))).
 */
axiom(not(initially(knowRequest(Agent1, Agent2, Physobj))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2678
% HoldsAt(BeWaiter0(Waiter1),0).

 /*  [] ->
       ta(Ta_Param, initially(beWaiter0(waiter1))).
 */
axiom(initially(beWaiter0(waiter1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2679
% HoldsAt(BeCook0(Cook1),0).

 /*  [] ->
       ta(Ta_Param, initially(beCook0(cook1))).
 */
axiom(initially(beCook0(cook1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2680
% [food]
 % !HoldsAt(FoodPrepared(food),0).
 %  not(initially(foodPrepared(Food))).

 /*  [] ->
       ta(Ta_Param, not(initially(foodPrepared(Food)))).
 */
axiom(not(initially(foodPrepared(Food))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2681
% !HoldsAt(Hungry(Cook1),0).
 %  not(initially(hungry(cook1))).

 /*  [] ->
       ta(Ta_Param, not(initially(hungry(cook1)))).
 */
axiom(not(initially(hungry(cook1))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2682
% !HoldsAt(Hungry(Waiter1),0).
 %  not(initially(hungry(waiter1))).

 /*  [] ->
       ta(Ta_Param, not(initially(hungry(waiter1)))).
 */
axiom(not(initially(hungry(waiter1))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2684
% Happens(WalkThroughDoor12(Customer1,MainEntrance1),0).

 /*  axiom_head(0) ->
       is_time(0).
 */

 /*  fix_axiom_head(0) ->
       holds_at(is_time(0), 0).
 */

 /*  [holds_at(is_time(0), t)] ->
       ta(0, happens(walkThroughDoor12(customer1, mainEntrance1), t)).
 */
axiom(happens(walkThroughDoor12(customer1, mainEntrance1), t),
    [holds_at(is_time(0), t)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2685
% Happens(Greet(Waiter1,Customer1),1).

 /*  axiom_head(1) ->
       is_time(1).
 */

 /*  fix_axiom_head(1) ->
       holds_at(is_time(1), 1).
 */

 /*  [holds_at(is_time(1), start), b(t, start), ignore(t+1==start)] ->
       ta(1, happens(greet(waiter1, customer1), start)).
 */
axiom(happens(greet(waiter1, customer1), start),
    [holds_at(is_time(1), start), b(t, start)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2686
% Happens(SitOn(Customer1,Chair1),2).

 /*  axiom_head(2) ->
       is_time(2).
 */

 /*  fix_axiom_head(2) ->
       holds_at(is_time(2), 2).
 */

 /*  [holds_at(is_time(2), t2), b(t, t2), ignore(t+2==t2)] ->
       ta(2, happens(sitOn(customer1, chair1), t2)).
 */
axiom(happens(sitOn(customer1, chair1), t2),
    [holds_at(is_time(2), t2), b(t, t2)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2687
% Happens(TakeOffOf(Customer1,Menu1,Table1),3).

 /*  axiom_head(3) ->
       is_time(3).
 */

 /*  fix_axiom_head(3) ->
       holds_at(is_time(3), 3).
 */

 /*  [holds_at(is_time(3), t3), b(t, t3), ignore(t+3==t3)] ->
       ta(3, happens(takeOffOf(customer1, menu1, table1), t3)).
 */
axiom(happens(takeOffOf(customer1, menu1, table1), t3),
    [holds_at(is_time(3), t3), b(t, t3)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2688
% Happens(Order(Customer1,Waiter1,Food1),4).

 /*  axiom_head(4) ->
       is_time(4).
 */

 /*  fix_axiom_head(4) ->
       holds_at(is_time(4), 4).
 */

 /*  [holds_at(is_time(4), t4), b(t, t4), ignore(t+4==t4)] ->
       ta(4, happens(order(customer1, waiter1, food1), t4)).
 */
axiom(happens(order(customer1, waiter1, food1), t4),
    [holds_at(is_time(4), t4), b(t, t4)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2689
% Happens(PlaceOn(Customer1,Menu1,Table1),5).

 /*  axiom_head(5) ->
       is_time(5).
 */

 /*  fix_axiom_head(5) ->
       holds_at(is_time(5), 5).
 */

 /*  [holds_at(is_time(5), t5), b(t, t5), ignore(t+5==t5)] ->
       ta(5, happens(placeOn(customer1, menu1, table1), t5)).
 */
axiom(happens(placeOn(customer1, menu1, table1), t5),
    [holds_at(is_time(5), t5), b(t, t5)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2690
% Happens(Eat(Customer1,Food1),11).

 /*  axiom_head(11) ->
       is_time(11).
 */

 /*  fix_axiom_head(11) ->
       holds_at(is_time(11), 11).
 */

 /*  [holds_at(is_time(11), t11), b(t, t11), ignore(t+11==t11)] ->
       ta(11, happens(eat(customer1, food1), t11)).
 */
axiom(happens(eat(customer1, food1), t11),
    [holds_at(is_time(11), t11), b(t, t11)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2691
% Happens(Request(Customer1,Waiter1,Bill1),12).

 /*  axiom_head(12) ->
       is_time(12).
 */

 /*  fix_axiom_head(12) ->
       holds_at(is_time(12), 12).
 */

 /*  [holds_at(is_time(12), t12), b(t, t12), ignore(t+12==t12)] ->
       ta(12, happens(request(customer1, waiter1, bill1), t12)).
 */
axiom(happens(request(customer1, waiter1, bill1), t12),
    [holds_at(is_time(12), t12), b(t, t12)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2692
% Happens(Pay(Customer1,Waiter1),15).

 /*  axiom_head(15) ->
       is_time(15).
 */

 /*  fix_axiom_head(15) ->
       holds_at(is_time(15), 15).
 */

 /*  [holds_at(is_time(15), t15), b(t, t15), ignore(t+15==t15)] ->
       ta(15, happens(pay(customer1, waiter1), t15)).
 */
axiom(happens(pay(customer1, waiter1), t15),
    [holds_at(is_time(15), t15), b(t, t15)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2693
% Happens(Tip(Customer1,Waiter1),15).

 /*  axiom_head(15) ->
       is_time(15).
 */

 /*  fix_axiom_head(15) ->
       holds_at(is_time(15), 15).
 */

 /*  [holds_at(is_time(15), t15), b(t, t15), ignore(t+15==t15)] ->
       ta(15, happens(tip(customer1, waiter1), t15)).
 */
axiom(happens(tip(customer1, waiter1), t15),
    [holds_at(is_time(15), t15), b(t, t15)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2694
% Happens(RiseFrom(Customer1,Chair1),16).

 /*  axiom_head(16) ->
       is_time(16).
 */

 /*  fix_axiom_head(16) ->
       holds_at(is_time(16), 16).
 */

 /*  [holds_at(is_time(16), t16), b(t, t16), ignore(t+16==t16)] ->
       ta(16, happens(riseFrom(customer1, chair1), t16)).
 */
axiom(happens(riseFrom(customer1, chair1), t16),
    [holds_at(is_time(16), t16), b(t, t16)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2695
% Happens(SayGoodbye(Customer1,Waiter1),17).

 /*  axiom_head(17) ->
       is_time(17).
 */

 /*  fix_axiom_head(17) ->
       holds_at(is_time(17), 17).
 */

 /*  [holds_at(is_time(17), t17), b(t, t17), ignore(t+17==t17)] ->
       ta(17, happens(sayGoodbye(customer1, waiter1), t17)).
 */
axiom(happens(sayGoodbye(customer1, waiter1), t17),
    [holds_at(is_time(17), t17), b(t, t17)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2696
% Happens(WalkThroughDoor21(Customer1,MainEntrance1),18).

 /*  axiom_head(18) ->
       is_time(18).
 */

 /*  fix_axiom_head(18) ->
       holds_at(is_time(18), 18).
 */

 /*  [holds_at(is_time(18), t18), b(t, t18), ignore(t+18==t18)] ->
       ta(18, happens(walkThroughDoor21(customer1, mainEntrance1), t18)).
 */
axiom(happens(walkThroughDoor21(customer1, mainEntrance1), t18),
    [holds_at(is_time(18), t18), b(t, t18)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2698
% range time 0 19
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2699
==> range(time,0,19).

% range offset 0 0
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2700
==> range(offset,0,0).

% range diameter 0 0
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2701
==> range(diameter,0,0).

% completion Happens
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2703
==> completion(happens).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/RepRest.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:InPress,
%;   author = "Erik T. Mueller",
%;   year = "in press",
%;   title = "Modelling space and time in narratives about restaurants",
%;   journal = "Literary and Linguistic Computing",
%; }
%;
%;sort boolean
%;sort integer
%;reified sort predicate
%;reified sort function
%;
%;sort time: integer
%;sort offset: integer
%;
%;reified sort fluent
%;reified sort event
%;
%;predicate Happens(event,time)
%;predicate HoldsAt(fluent,time)
%;predicate ReleasedAt(fluent,time)
%;predicate Initiates(event,fluent,time)
%;predicate Terminates(event,fluent,time)
%;predicate Releases(event,fluent,time)
%;
%;sort diameter: integer
%;
%;sort object
%;
%;sort agent: object
%;
%;sort physobj: object
%;sort bed: physobj
%;sort snowflake: physobj
%;sort sky: physobj
%;
%;sort stuff: physobj
%;
%;sort surface: physobj
%;sort ground: surface
%;
%;sort snow: stuff
%;sort ball
%;
%;sort food: physobj
%;sort fruit: food
%;sort orange: fruit
%;sort salad: food
%;
%;sort clothing: physobj
%;sort scarf: clothing
%;sort hat: clothing
%;
%;sort vegetablematter: physobj
%;sort coal: vegetablematter
%;
%;sort bodypart: physobj
%;sort hand: bodypart
%;
%;sort papertowels: physobj
%;sort device: physobj
%;sort electronicdevice: device
%;sort lamp: electronicdevice
%;
%;sort cat: physobj
%;
%;sort weapon: physobj
%;sort gun: weapon
%;sort bomb: weapon
%;sort bullet: weapon
%;
%;sort location
%;sort room: location, outside: location
%;
%;sort portal
%;sort door: portal, staircase: portal
%;sort street: portal
%;
%;sort building
%;
%;sort fire: object
%;
%;sort furniture: physobj
%;sort chair: furniture
%;sort table: furniture
%;
%;sort menu: physobj
%;sort bill: physobj
%;
%;sort script
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2814
% fluent Holding(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2815
fluent(holding(Holding_Param,Holding_Ret)).
==> mpred_prop(holding(agent,physobj),fluent).
==> meta_argtypes(holding(agent,physobj)).

% event PickUp(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2816
event(pickUp(PickUp_Param,PickUp_Ret)).
==> mpred_prop(pickUp(agent,physobj),event).
==> meta_argtypes(pickUp(agent,physobj)).

% event LetGoOf(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2817
event(letGoOf(LetGoOf_Param,LetGoOf_Ret)).
==> mpred_prop(letGoOf(agent,physobj),event).
==> meta_argtypes(letGoOf(agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2818
% [agent,physobj,time]
% Initiates(PickUp(agent,physobj),Holding(agent,physobj),time).

 /*  [] ->
       ta(Time,
          initiates(pickUp(Agent, Physobj),
                    holding(Agent, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2819
axiom(initiates(pickUp(Agent, Physobj), holding(Agent, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2821
% [agent,physobj,time]
% Happens(PickUp(agent,physobj),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2823
% {location}% 
%   HoldsAt(At(agent,location),time) &
%   HoldsAt(At(physobj,location),time).

 /*  exists([Location],
    happens(pickUp(Agent, Physobj), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Physobj, Location), Time)).
 */

 /*  not(happens(pickUp(Agent, Physobj), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj, Location), Time))
       ),
       some(Location, '$kolem_Fn_224'(Agent, Physobj, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Physobj, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj, Location)), Time)), some(Location, '$kolem_Fn_224'(Agent, Physobj, Time))] ->
       ta(Time, not(happens(pickUp(Agent, Physobj), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2825
axiom(not(happens(pickUp(Agent, Physobj), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj, Location)), Time)),
      some(Location, '$kolem_Fn_224'(Agent, Physobj, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(pickUp(Agent, Physobj), Time),
       some(Location, '$kolem_Fn_224'(Agent, Physobj, Time)).
 */

 /*  [happens(pickUp(Agent, Physobj), Time), some(Location, '$kolem_Fn_224'(Agent, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(pickUp(Agent, Physobj), Time),
      some(Location, '$kolem_Fn_224'(Agent, Physobj, Time))
    ]).

 /*  holds_at(at(Physobj, Location), Time) :-
       happens(pickUp(Agent, Physobj), Time),
       some(Location, '$kolem_Fn_224'(Agent, Physobj, Time)).
 */

 /*  [happens(pickUp(Agent, Physobj), Time), some(Location, '$kolem_Fn_224'(Agent, Physobj, Time))] ->
       ta(Time, holds_at(at(Physobj, Location), Time)).
 */
axiom(holds_at(at(Physobj, Location), Time),
   
    [ happens(pickUp(Agent, Physobj), Time),
      some(Location, '$kolem_Fn_224'(Agent, Physobj, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2827
% [agent,physobj,time]
% Terminates(LetGoOf(agent,physobj),Holding(agent,physobj),time).

 /*  [] ->
       ta(Time,
          terminates(letGoOf(Agent, Physobj),
                     holding(Agent, Physobj),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2828
axiom(terminates(letGoOf(Agent, Physobj), holding(Agent, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2830
% [agent,physobj,time]
% Happens(LetGoOf(agent,physobj),time) ->
% HoldsAt(Holding(agent,physobj),time).

 /*  allDifferent([Agent, Physobj, Time]) ->
       ( happens(letGoOf(Agent, Physobj), Time)->holds_at(holding(Agent, Physobj), Time)
       ).
 */

 /*  holds_at(holding(Agent, Physobj), Time) :-
       happens(letGoOf(Agent, Physobj), Time),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [happens(letGoOf(Agent, Physobj), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time, holds_at(holding(Agent, Physobj), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2832
axiom(holds_at(holding(Agent, Physobj), Time),
   
    [ happens(letGoOf(Agent, Physobj), Time),
      allDifferent([Agent, Physobj, Time])
    ]).

 /*  not(happens(letGoOf(Agent, Physobj), Time)) :-
       not(holds_at(holding(Agent, Physobj), Time)),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(neg(holding(Agent, Physobj)), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time, not(happens(letGoOf(Agent, Physobj), Time))).
 */
axiom(not(happens(letGoOf(Agent, Physobj), Time)),
   
    [ holds_at(neg(holding(Agent, Physobj)), Time),
      allDifferent([Agent, Physobj, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2834
% [agent,physobj,location,time]
% Releases(PickUp(agent,physobj),At(physobj,location),time).

 /*  [] ->
       ta(Time,
          releases(pickUp(Agent, Physobj),
                   at(Physobj, Location),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2835
axiom(releases(pickUp(Agent, Physobj), at(Physobj, Location), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2837
% [agent,physobj,location,time]
% HoldsAt(Holding(agent,physobj),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(physobj,location),time).

 /*  allDifferent([Agent, Physobj, Time, Location]) ->
       ( holds_at(holding(Agent, Physobj), Time), holds_at(at(Agent, Location), Time)->holds_at(at(Physobj, Location), Time)
       ).
 */

 /*  holds_at(at(Physobj, Location), Time) :-
       ( holds_at(holding(Agent, Physobj), Time),
         holds_at(at(Agent, Location), Time)
       ),
       allDifferent([Agent, Physobj, Time, Location]).
 */

 /*  [holds_at(holding(Agent, Physobj), Time), holds_at(at(Agent, Location), Time), allDifferent([Agent, Physobj, Time, Location])] ->
       ta(Time, holds_at(at(Physobj, Location), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2840
axiom(holds_at(at(Physobj, Location), Time),
   
    [ holds_at(holding(Agent, Physobj), Time),
      holds_at(at(Agent, Location), Time),
      allDifferent([Agent, Physobj, Time, Location])
    ]).

 /*  not(holds_at(holding(Agent, Physobj), Time)) :-
       holds_at(at(Agent, Location), Time),
       not(holds_at(at(Physobj, Location), Time)),
       allDifferent([Agent, Physobj, Time, Location]).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(neg(at(Physobj, Location)), Time), allDifferent([Agent, Physobj, Time, Location])] ->
       ta(Time,
          holds_at(neg(holding(Agent, Physobj)), Time)).
 */
axiom(holds_at(neg(holding(Agent, Physobj)), Time),
   
    [ holds_at(at(Agent, Location), Time),
      holds_at(neg(at(Physobj, Location)), Time),
      allDifferent([Agent, Physobj, Time, Location])
    ]).

 /*  not(holds_at(at(Agent, Location), Time)) :-
       holds_at(holding(Agent, Physobj), Time),
       not(holds_at(at(Physobj, Location), Time)),
       allDifferent([Agent, Physobj, Time, Location]).
 */

 /*  [holds_at(holding(Agent, Physobj), Time), holds_at(neg(at(Physobj, Location)), Time), allDifferent([Agent, Physobj, Time, Location])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */
axiom(holds_at(neg(at(Agent, Location)), Time),
   
    [ holds_at(holding(Agent, Physobj), Time),
      holds_at(neg(at(Physobj, Location)), Time),
      allDifferent([Agent, Physobj, Time, Location])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2842
%;[agent,physobj,location1,location2,time]
%;HoldsAt(At(agent,location1),time) &
%;location1!=location2 ->
%;Terminates(LetGoOf(agent,physobj),At(physobj,location2),time).
% [agent,physobj,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2848
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).

 /*  [holds_at(at(Agent, Location), Time)] ->
       ta(Time,
          initiates(letGoOf(Agent, Physobj),
                    at(Physobj, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2849
axiom(initiates(letGoOf(Agent, Physobj), at(Physobj, Location), Time),
    [holds_at(at(Agent, Location), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2851
% fluent On(physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2852
fluent(on(On_Param,On_Ret)).
==> mpred_prop(on(physobj,physobj),fluent).
==> meta_argtypes(on(physobj,physobj)).

% event PlaceOn(agent,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2854
event(placeOn(PlaceOn_Param,_,PlaceOn_Ret)).
==> mpred_prop(placeOn(agent,physobj,physobj),event).
==> meta_argtypes(placeOn(agent,physobj,physobj)).

% event TakeOffOf(agent,physobj,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2856
event(takeOffOf(TakeOffOf_Param,_,TakeOffOf_Ret)).
==> mpred_prop(takeOffOf(agent,physobj,physobj),event).
==> meta_argtypes(takeOffOf(agent,physobj,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2857
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% physobj1!=physobj2.

 /*  allDifferent([Physobj1, Physobj2, Time]) ->
       ( holds_at(on(Physobj1, Physobj2), Time)->diff(Physobj1, Physobj2)
       ).
 */

 /*  not(holds_at(on(Physobj1, Physobj2), Time)) :-
       not(diff(Physobj1, Physobj2)),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [not(diff(Physobj1, Physobj2)), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time, holds_at(neg(on(Physobj1, Physobj2)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2859
axiom(holds_at(neg(on(Physobj1, Physobj2)), Time),
   
    [ not(diff(Physobj1, Physobj2)),
      allDifferent([Physobj1, Physobj2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2861
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% !HoldsAt(On(physobj2,physobj1),time).

 /*  allDifferent([Physobj1, Physobj2, Time]) ->
       ( holds_at(on(Physobj1, Physobj2), Time)->holds_at(neg(on(Physobj2, Physobj1)), Time)
       ).
 */

 /*  holds_at(neg(on(Physobj2, Physobj1)), Time) :-
       holds_at(on(Physobj1, Physobj2), Time),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [holds_at(on(Physobj1, Physobj2), Time), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time, holds_at(neg(on(Physobj2, Physobj1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2863
axiom(holds_at(neg(on(Physobj2, Physobj1)), Time),
   
    [ holds_at(on(Physobj1, Physobj2), Time),
      allDifferent([Physobj1, Physobj2, Time])
    ]).

 /*  not(holds_at(on(Physobj1, Physobj2), Time)) :-
       not(holds_at(neg(on(Physobj2, Physobj1)), Time)),
       allDifferent([Physobj1, Physobj2, Time]).
 */

 /*  [holds_at(neg(neg(on(Physobj2, Physobj1))), Time), allDifferent([Physobj1, Physobj2, Time])] ->
       ta(Time, holds_at(neg(on(Physobj1, Physobj2)), Time)).
 */
axiom(holds_at(neg(on(Physobj1, Physobj2)), Time),
   
    [ holds_at(neg(neg(on(Physobj2, Physobj1))), Time),
      allDifferent([Physobj1, Physobj2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2865
% [agent,physobj1,physobj2,time]
% Initiates(PlaceOn(agent,physobj1,physobj2),
%           On(physobj1,physobj2),time).

 /*  [] ->
       ta(Time,
          initiates(placeOn(Agent, Physobj1, Physobj2),
                    on(Physobj1, Physobj2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2867
axiom(initiates(placeOn(Agent, Physobj1, Physobj2), on(Physobj1, Physobj2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2869
% [agent,physobj1,physobj2,time]
% Terminates(PlaceOn(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).

 /*  [] ->
       ta(Time,
          terminates(placeOn(Agent, Physobj1, Physobj2),
                     holding(Agent, Physobj1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2871
axiom(terminates(placeOn(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2873
% [agent,physobj1,physobj2,time]
% Happens(PlaceOn(agent,physobj1,physobj2),time) ->
% HoldsAt(Holding(agent,physobj1),time) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2876
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj2,location),time).

 /*  exists([Location],
    happens(placeOn(Agent, Physobj1, Physobj2), Time) ->
       holds_at(holding(Agent, Physobj1), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Physobj2, Location), Time)).
 */

 /*  not(happens(placeOn(Agent, Physobj1, Physobj2), Time)) :-
       (   not(holds_at(holding(Agent, Physobj1), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(holding(Agent, Physobj1), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(holding(Agent, Physobj1)), Time)
       ;   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Physobj2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(holding(Agent, Physobj1)), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj2, Location)), Time)), some(Location, '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time,
          not(happens(placeOn(Agent, Physobj1, Physobj2),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2878
axiom(not(happens(placeOn(Agent, Physobj1, Physobj2), Time)),
   
    [  (holds_at(neg(holding(Agent, Physobj1)), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj2, Location)), Time)),
      some(Location,
           '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(holding(Agent, Physobj1), Time) :-
       happens(placeOn(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(placeOn(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(holding(Agent, Physobj1), Time)).
 */
axiom(holds_at(holding(Agent, Physobj1), Time),
   
    [ happens(placeOn(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(placeOn(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(placeOn(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(placeOn(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Physobj2, Location), Time) :-
       happens(placeOn(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(placeOn(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Physobj2, Location), Time)).
 */
axiom(holds_at(at(Physobj2, Location), Time),
   
    [ happens(placeOn(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_225'(Agent, Physobj1, Physobj2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2880
% [agent,physobj1,physobj2,time]
% Terminates(TakeOffOf(agent,physobj1,physobj2),
%            On(physobj1,physobj2),time).

 /*  [] ->
       ta(Time,
          terminates(takeOffOf(Agent, Physobj1, Physobj2),
                     on(Physobj1, Physobj2),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2882
axiom(terminates(takeOffOf(Agent, Physobj1, Physobj2), on(Physobj1, Physobj2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2884
% [agent,physobj1,physobj2,time]
% Initiates(TakeOffOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),time).

 /*  [] ->
       ta(Time,
          initiates(takeOffOf(Agent, Physobj1, Physobj2),
                    holding(Agent, Physobj1),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2886
axiom(initiates(takeOffOf(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2888
% [agent,physobj1,physobj2,location,time]
% Releases(TakeOffOf(agent,physobj1,physobj2),
%          At(physobj1,location),
%          time).

 /*  [] ->
       ta(Time,
          releases(takeOffOf(Agent, Physobj1, Physobj2),
                   at(Physobj1, Location),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2891
axiom(releases(takeOffOf(Agent, Physobj1, Physobj2), at(Physobj1, Location), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2893
% [agent,physobj1,physobj2,time]
% Happens(TakeOffOf(agent,physobj1,physobj2),time) ->
% HoldsAt(On(physobj1,physobj2),time) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2896
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).

 /*  exists([Location],
    happens(takeOffOf(Agent, Physobj1, Physobj2), Time) ->
       holds_at(on(Physobj1, Physobj2), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Physobj1, Location), Time),
       holds_at(at(Physobj2, Location), Time)).
 */

 /*  not(happens(takeOffOf(Agent, Physobj1, Physobj2), Time)) :-
       (   not(holds_at(on(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj1, Location), Time))
       ;   not(holds_at(at(Physobj2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(on(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Physobj1, Location), Time))
       ;   not(holds_at(at(Physobj2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(on(Physobj1, Physobj2)), Time)
       ;   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Physobj1, Location)), Time)
       ;   holds_at(neg(at(Physobj2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(on(Physobj1, Physobj2)), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj1, Location)), Time);holds_at(neg(at(Physobj2, Location)), Time)), some(Location, '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time,
          not(happens(takeOffOf(Agent, Physobj1, Physobj2),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2899
axiom(not(happens(takeOffOf(Agent, Physobj1, Physobj2), Time)),
   
    [  (holds_at(neg(on(Physobj1, Physobj2)), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Physobj1, Location)), Time);holds_at(neg(at(Physobj2, Location)), Time)),
      some(Location,
           '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(on(Physobj1, Physobj2), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOffOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(on(Physobj1, Physobj2), Time)).
 */
axiom(holds_at(on(Physobj1, Physobj2), Time),
   
    [ happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOffOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Physobj1, Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOffOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Physobj1, Location), Time)).
 */
axiom(holds_at(at(Physobj1, Location), Time),
   
    [ happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))
    ]).

 /*  holds_at(at(Physobj2, Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Location,
            '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time)).
 */

 /*  [happens(takeOffOf(Agent, Physobj1, Physobj2), Time), some(Location, '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))] ->
       ta(Time, holds_at(at(Physobj2, Location), Time)).
 */
axiom(holds_at(at(Physobj2, Location), Time),
   
    [ happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
      some(Location,
           '$kolem_Fn_226'(Agent, Physobj1, Physobj2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2901
% [agent,physobj1,physobj2,location,time]
% Releases(PlaceOn(agent,physobj1,physobj2),
%          At(physobj1,location),
%          time).

 /*  [] ->
       ta(Time,
          releases(placeOn(Agent, Physobj1, Physobj2),
                   at(Physobj1, Location),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2904
axiom(releases(placeOn(Agent, Physobj1, Physobj2), at(Physobj1, Location), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2906
% [physobj1,physobj2,location,time]
% HoldsAt(On(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).

 /*  allDifferent([Physobj1, Physobj2, Time, Location]) ->
       ( holds_at(on(Physobj1, Physobj2), Time), holds_at(at(Physobj2, Location), Time)->holds_at(at(Physobj1, Location), Time)
       ).
 */

 /*  holds_at(at(Physobj1, Location), Time) :-
       ( holds_at(on(Physobj1, Physobj2), Time),
         holds_at(at(Physobj2, Location), Time)
       ),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(on(Physobj1, Physobj2), Time), holds_at(at(Physobj2, Location), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time, holds_at(at(Physobj1, Location), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2909
axiom(holds_at(at(Physobj1, Location), Time),
   
    [ holds_at(on(Physobj1, Physobj2), Time),
      holds_at(at(Physobj2, Location), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).

 /*  not(holds_at(on(Physobj1, Physobj2), Time)) :-
       holds_at(at(Physobj2, Location), Time),
       not(holds_at(at(Physobj1, Location), Time)),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(at(Physobj2, Location), Time), holds_at(neg(at(Physobj1, Location)), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time, holds_at(neg(on(Physobj1, Physobj2)), Time)).
 */
axiom(holds_at(neg(on(Physobj1, Physobj2)), Time),
   
    [ holds_at(at(Physobj2, Location), Time),
      holds_at(neg(at(Physobj1, Location)), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).

 /*  not(holds_at(at(Physobj2, Location), Time)) :-
       holds_at(on(Physobj1, Physobj2), Time),
       not(holds_at(at(Physobj1, Location), Time)),
       allDifferent([Physobj1, Physobj2, Time, Location]).
 */

 /*  [holds_at(on(Physobj1, Physobj2), Time), holds_at(neg(at(Physobj1, Location)), Time), allDifferent([Physobj1, Physobj2, Time, Location])] ->
       ta(Time, holds_at(neg(at(Physobj2, Location)), Time)).
 */
axiom(holds_at(neg(at(Physobj2, Location)), Time),
   
    [ holds_at(on(Physobj1, Physobj2), Time),
      holds_at(neg(at(Physobj1, Location)), Time),
      allDifferent([Physobj1, Physobj2, Time, Location])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2911
% fluent At(object,location)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2912
fluent(at(At_Param,Location)).
==> mpred_prop(at(object,location),fluent).
==> meta_argtypes(at(object,location)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2913
% [object,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2914
% {location} % HoldsAt(At(object,location),time).

 /*  exists([Location],
    holds_at(at(Object,Location),Time)).
 */

 /*  holds_at(at(Object, Location), Time) :-
       some(Location, '$kolem_Fn_227'(Object, Time)).
 */

 /*  [some(Location, '$kolem_Fn_227'(Object, Time))] ->
       ta(Time, holds_at(at(Object, Location), Time)).
 */
axiom(holds_at(at(Object, Location), Time),
    [some(Location, '$kolem_Fn_227'(Object, Time))]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2916
% [object,location1,location2,time]
% HoldsAt(At(object,location1),time) &
% HoldsAt(At(object,location2),time) ->
% location1=location2.

 /*  allDifferent([Object, Location1, Time, Location2]) ->
       ( holds_at(at(Object, Location1), Time), holds_at(at(Object, Location2), Time)->Location1=Location2
       ).
 */

 /*  not(holds_at(at(Object, Location1), Time)) :-
       holds_at(at(Object, Location2), Time),
       not(equals(Location1, Location2)),
       allDifferent([Object, Location1, Time, Location2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Location1, Location2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Location1=Location2)).
 */

 /*  [holds_at(at(Object, Location2), Time), not(call(Location1=Location2)), allDifferent([Object, Location1, Time, Location2])] ->
       ta(Time, holds_at(neg(at(Object, Location1)), Time)).
 */

 /*  [holds_at(at(Object, Location2), Time), holds_at(neg(call(Location1=Location2)), Time), allDifferent([Object, Location1, Time, Location2])] ->
       ta(Time, holds_at(neg(at(Object, Location1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2919
axiom(holds_at(neg(at(Object, Location1)), Time),
   
    [ holds_at(at(Object, Location2), Time),
      holds_at(neg(call(Location1=Location2)), Time),
      allDifferent([Object, Location1, Time, Location2])
    ]).

 /*  not(holds_at(at(Object, Location2), Time)) :-
       holds_at(at(Object, Location1), Time),
       not(equals(Location1, Location2)),
       allDifferent([Object, Location1, Time, Location2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Location1, Location2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Location1=Location2)).
 */

 /*  [holds_at(at(Object, Location1), Time), not(call(Location1=Location2)), allDifferent([Object, Location1, Time, Location2])] ->
       ta(Time, holds_at(neg(at(Object, Location2)), Time)).
 */

 /*  [holds_at(at(Object, Location1), Time), holds_at(neg(call(Location1=Location2)), Time), allDifferent([Object, Location1, Time, Location2])] ->
       ta(Time, holds_at(neg(at(Object, Location2)), Time)).
 */
axiom(holds_at(neg(at(Object, Location2)), Time),
   
    [ holds_at(at(Object, Location1), Time),
      holds_at(neg(call(Location1=Location2)), Time),
      allDifferent([Object, Location1, Time, Location2])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2921
% function Side1(portal): location
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2922
functional_predicate(side1(Side1_Param,Side1_Ret)).
==> mpred_prop(side1(portal,location),functional_predicate).
==> meta_argtypes(side1(portal,location)).
==> resultIsa(side1,location).

% function Side2(portal): location
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2923
functional_predicate(side2(Side2_Param,Side2_Ret)).
==> mpred_prop(side2(portal,location),functional_predicate).
==> meta_argtypes(side2(portal,location)).
==> resultIsa(side2,location).

% fluent NearPortal(object,portal)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2925
fluent(nearPortal(NearPortal_Param,NearPortal_Ret)).
==> mpred_prop(nearPortal(object,portal),fluent).
==> meta_argtypes(nearPortal(object,portal)).

% noninertial NearPortal
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2926
==> noninertial(nearPortal).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2927
% [object,portal,time]
% HoldsAt(NearPortal(object,portal),time) <->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2929
% {location}% 
%  (Side1(portal)=location|
%   Side2(portal)=location) &
%  HoldsAt(At(object,location),time).

 /*  exists([Location],
    holds_at(nearPortal(Object, Portal), Time) <->
       (   side1(Portal)=Location
       ;   side2(Portal)=Location
       ),
       holds_at(at(Object, Location), Time)).
 */

 /*  not(holds_at(nearPortal(Object, Portal), Time)) :-
       (   not(equals(side1(Portal), Location)),
           not(equals(side2(Portal), Location))
       ;   not(holds_at(at(Object, Location), Time))
       ),
       some(Location, '$kolem_Fn_228'(Object, Portal, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(equals(side1(Portal), Location)),
           not(equals(side2(Portal), Location))
       ;   not(holds_at(at(Object, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   not(call(side1(Portal)=Location)),
           not(call(side2(Portal)=Location))
       ;   holds_at(neg(at(Object, Location)), Time)
       ).
 */

 /*  [(not(call(side1(Portal)=Location)), not(call(side2(Portal)=Location));holds_at(neg(at(Object, Location)), Time)), some(Location, '$kolem_Fn_228'(Object, Portal, Time))] ->
       ta(Time,
          holds_at(neg(nearPortal(Object, Portal)), Time)).
 */

 /*  [(holds_at(neg(call(side1(Portal)=Location)), Time), holds_at(neg(call(side2(Portal)=Location)), Time);holds_at(neg(at(Object, Location)), Time)), some(Location, '$kolem_Fn_228'(Object, Portal, Time))] ->
       ta(Time,
          holds_at(neg(nearPortal(Object, Portal)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2932
axiom(holds_at(neg(nearPortal(Object, Portal)), Time),
   
    [  (holds_at(neg(call(side1(Portal)=Location)), Time), holds_at(neg(call(side2(Portal)=Location)), Time);holds_at(neg(at(Object, Location)), Time)),
      some(Location, '$kolem_Fn_228'(Object, Portal, Time))
    ]).

 /*  holds_at(at(Object, Location), Time) :-
       holds_at(nearPortal(Object, Portal), Time),
       some(Location, '$kolem_Fn_228'(Object, Portal, Time)).
 */

 /*  [holds_at(nearPortal(Object, Portal), Time), some(Location, '$kolem_Fn_228'(Object, Portal, Time))] ->
       ta(Time, holds_at(at(Object, Location), Time)).
 */
axiom(holds_at(at(Object, Location), Time),
   
    [ holds_at(nearPortal(Object, Portal), Time),
      some(Location, '$kolem_Fn_228'(Object, Portal, Time))
    ]).

 /*  holds_at(nearPortal(Object, Portal), Time) :-
       ( holds_at(at(Object, Location), Time),
         (   equals(side1(Portal), Location)
         ;   equals(side2(Portal), Location)
         )
       ),
       some(Location, '$kolem_Fn_228'(Object, Portal, Time)).
 */

 /*  axiom_head(Time) ->
       (   equals(side1(Portal), Location)
       ;   equals(side2(Portal), Location)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   call(side1(Portal)=Location)
       ;   call(side2(Portal)=Location)
       ).
 */

 /*  [holds_at(at(Object, Location), Time),  (call(side1(Portal)=Location);call(side2(Portal)=Location)), some(Location, '$kolem_Fn_228'(Object, Portal, Time))] ->
       ta(Time, holds_at(nearPortal(Object, Portal), Time)).
 */

 /*  [holds_at(at(Object, Location), Time),  (holds_at(call(side1(Portal)=Location), Time);holds_at(call(side2(Portal)=Location), Time)), some(Location, '$kolem_Fn_228'(Object, Portal, Time))] ->
       ta(Time, holds_at(nearPortal(Object, Portal), Time)).
 */
axiom(holds_at(nearPortal(Object, Portal), Time),
   
    [ holds_at(at(Object, Location), Time),
       (holds_at(call(side1(Portal)=Location), Time);holds_at(call(side2(Portal)=Location), Time)),
      some(Location, '$kolem_Fn_228'(Object, Portal, Time))
    ]).

 /*  not(holds_at(at(Object, Location), Time)) :-
       (   equals(side1(Portal), Location)
       ;   equals(side2(Portal), Location)
       ),
       not(holds_at(nearPortal(Object, Portal), Time)),
       some(Location, '$kolem_Fn_228'(Object, Portal, Time)).
 */

 /*  axiom_head(Time) ->
       (   equals(side1(Portal), Location)
       ;   equals(side2(Portal), Location)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   call(side1(Portal)=Location)
       ;   call(side2(Portal)=Location)
       ).
 */

 /*  [(call(side1(Portal)=Location);call(side2(Portal)=Location)), holds_at(neg(nearPortal(Object, Portal)), Time), some(Location, '$kolem_Fn_228'(Object, Portal, Time))] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */

 /*  [(holds_at(call(side1(Portal)=Location), Time);holds_at(call(side2(Portal)=Location), Time)), holds_at(neg(nearPortal(Object, Portal)), Time), some(Location, '$kolem_Fn_228'(Object, Portal, Time))] ->
       ta(Time, holds_at(neg(at(Object, Location)), Time)).
 */
axiom(holds_at(neg(at(Object, Location)), Time),
   
    [  (holds_at(call(side1(Portal)=Location), Time);holds_at(call(side2(Portal)=Location), Time)),
      holds_at(neg(nearPortal(Object, Portal)), Time),
      some(Location, '$kolem_Fn_228'(Object, Portal, Time))
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2934
% event WalkThroughDoor12(agent,door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2935
event(walkThroughDoor12(WalkThroughDoor12_Param,
			WalkThroughDoor12_Ret)).
==> mpred_prop(walkThroughDoor12(agent,door),event).
==> meta_argtypes(walkThroughDoor12(agent,door)).

% event WalkThroughDoor21(agent,door)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2936
event(walkThroughDoor21(WalkThroughDoor21_Param,
			WalkThroughDoor21_Ret)).
==> mpred_prop(walkThroughDoor21(agent,door),event).
==> meta_argtypes(walkThroughDoor21(agent,door)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2937
% [agent,door,time]
% Happens(WalkThroughDoor12(agent,door),time) ->
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(door)),time).

 /*  allDifferent([Agent, Door, Time]) ->
       ( happens(walkThroughDoor12(Agent, Door), Time)->holds_at(standing(Agent), Time), holds_at(at(Agent, side1(Door)), Time)
       ).
 */

 /*  not(happens(walkThroughDoor12(Agent, Door), Time)) :-
       (   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side1(Door)), Time))
       ),
       allDifferent([Agent, Door, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side1(Door)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(standing(Agent)), Time)
       ;   holds_at(neg(at(Agent, side1(Door))), Time)
       ).
 */

 /*  [(holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side1(Door))), Time)), allDifferent([Agent, Door, Time])] ->
       ta(Time,
          not(happens(walkThroughDoor12(Agent, Door), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2940
axiom(not(happens(walkThroughDoor12(Agent, Door), Time)),
   
    [  (holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side1(Door))), Time)),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(standing(Agent), Time) :-
       happens(walkThroughDoor12(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor12(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(standing(Agent), Time)).
 */
axiom(holds_at(standing(Agent), Time),
   
    [ happens(walkThroughDoor12(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(at(Agent, side1(Door)), Time) :-
       happens(walkThroughDoor12(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor12(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(at(Agent, side1(Door)), Time)).
 */
axiom(holds_at(at(Agent, side1(Door)), Time),
   
    [ happens(walkThroughDoor12(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2942
% [agent,door,time]
% Happens(WalkThroughDoor21(agent,door),time) ->
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(door)),time).

 /*  allDifferent([Agent, Door, Time]) ->
       ( happens(walkThroughDoor21(Agent, Door), Time)->holds_at(standing(Agent), Time), holds_at(at(Agent, side2(Door)), Time)
       ).
 */

 /*  not(happens(walkThroughDoor21(Agent, Door), Time)) :-
       (   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side2(Door)), Time))
       ),
       allDifferent([Agent, Door, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(standing(Agent), Time))
       ;   not(holds_at(at(Agent, side2(Door)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(standing(Agent)), Time)
       ;   holds_at(neg(at(Agent, side2(Door))), Time)
       ).
 */

 /*  [(holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side2(Door))), Time)), allDifferent([Agent, Door, Time])] ->
       ta(Time,
          not(happens(walkThroughDoor21(Agent, Door), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2945
axiom(not(happens(walkThroughDoor21(Agent, Door), Time)),
   
    [  (holds_at(neg(standing(Agent)), Time);holds_at(neg(at(Agent, side2(Door))), Time)),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(standing(Agent), Time) :-
       happens(walkThroughDoor21(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor21(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(standing(Agent), Time)).
 */
axiom(holds_at(standing(Agent), Time),
   
    [ happens(walkThroughDoor21(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).

 /*  holds_at(at(Agent, side2(Door)), Time) :-
       happens(walkThroughDoor21(Agent, Door), Time),
       allDifferent([Agent, Door, Time]).
 */

 /*  [happens(walkThroughDoor21(Agent, Door), Time), allDifferent([Agent, Door, Time])] ->
       ta(Time, holds_at(at(Agent, side2(Door)), Time)).
 */
axiom(holds_at(at(Agent, side2(Door)), Time),
   
    [ happens(walkThroughDoor21(Agent, Door), Time),
      allDifferent([Agent, Door, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2947
% [agent,door,location,time]
% Side2(door)=location ->
% Initiates(WalkThroughDoor12(agent,door),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [call(side2(Door)=Location)] ->
       ta(Time,
          initiates(walkThroughDoor12(Agent, Door),
                    at(Agent, Location),
                    Time)).
 */

 /*  [holds_at(call(side2(Door)=Location), Time)] ->
       ta(Time,
          initiates(walkThroughDoor12(Agent, Door),
                    at(Agent, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2949
axiom(initiates(walkThroughDoor12(Agent, Door), at(Agent, Location), Time),
    [holds_at(call(side2(Door)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2951
% [agent,door,location,time]
% Side1(door)=location ->
% Initiates(WalkThroughDoor21(agent,door),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [call(side1(Door)=Location)] ->
       ta(Time,
          initiates(walkThroughDoor21(Agent, Door),
                    at(Agent, Location),
                    Time)).
 */

 /*  [holds_at(call(side1(Door)=Location), Time)] ->
       ta(Time,
          initiates(walkThroughDoor21(Agent, Door),
                    at(Agent, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2953
axiom(initiates(walkThroughDoor21(Agent, Door), at(Agent, Location), Time),
    [holds_at(call(side1(Door)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2955
% [agent,door,location,time]
% Side1(door)=location ->
% Terminates(WalkThroughDoor12(agent,door),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side1(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side1(Door)=Location).
 */

 /*  [call(side1(Door)=Location)] ->
       ta(Time,
          terminates(walkThroughDoor12(Agent, Door),
                     at(Agent, Location),
                     Time)).
 */

 /*  [holds_at(call(side1(Door)=Location), Time)] ->
       ta(Time,
          terminates(walkThroughDoor12(Agent, Door),
                     at(Agent, Location),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2957
axiom(terminates(walkThroughDoor12(Agent, Door), at(Agent, Location), Time),
    [holds_at(call(side1(Door)=Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2959
% [agent,door,location,time]
% Side2(door)=location ->
% Terminates(WalkThroughDoor21(agent,door),At(agent,location),time).

 /*  axiom_head(Time) ->
       equals(side2(Door), Location).
 */

 /*  fix_axiom_head(Time) ->
       call(side2(Door)=Location).
 */

 /*  [call(side2(Door)=Location)] ->
       ta(Time,
          terminates(walkThroughDoor21(Agent, Door),
                     at(Agent, Location),
                     Time)).
 */

 /*  [holds_at(call(side2(Door)=Location), Time)] ->
       ta(Time,
          terminates(walkThroughDoor21(Agent, Door),
                     at(Agent, Location),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2961
axiom(terminates(walkThroughDoor21(Agent, Door), at(Agent, Location), Time),
    [holds_at(call(side2(Door)=Location), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2963
% fluent Hungry(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2964
fluent(hungry(Hungry_Ret)).
==> mpred_prop(hungry(agent),fluent).
==> meta_argtypes(hungry(agent)).

% fluent Satiated(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2966
fluent(satiated(Satiated_Ret)).
==> mpred_prop(satiated(agent),fluent).
==> meta_argtypes(satiated(agent)).

% noninertial Satiated
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2967
==> noninertial(satiated).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2968
% [agent,time]
 % HoldsAt(Hungry(agent),time) <-> !HoldsAt(Satiated(agent),time).

 /*  holds_at(hungry(Agent), Time) <->
       holds_at(neg(satiated(Agent)), Time).
 */

 /*  [holds_at, hungry] <->
       [holds_at, neg, satiated].
 */

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(hungry(Agent), Time)->holds_at(neg(satiated(Agent)), Time)
       ).
 */

 /*  holds_at(neg(satiated(Agent)), Time) :-
       holds_at(hungry(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(hungry(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(satiated(Agent)), Time)).
 */
axiom(holds_at(neg(satiated(Agent)), Time),
   
    [ holds_at(hungry(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(hungry(Agent), Time)) :-
       not(holds_at(neg(satiated(Agent)), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(neg(satiated(Agent))), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(hungry(Agent)), Time)).
 */
axiom(holds_at(neg(hungry(Agent)), Time),
   
    [ holds_at(neg(neg(satiated(Agent))), Time),
      allDifferent([Agent, Time])
    ]).

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(neg(satiated(Agent)), Time)->holds_at(hungry(Agent), Time)
       ).
 */

 /*  holds_at(hungry(Agent), Time) :-
       holds_at(neg(satiated(Agent)), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(satiated(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(hungry(Agent), Time)).
 */
axiom(holds_at(hungry(Agent), Time),
   
    [ holds_at(neg(satiated(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(neg(satiated(Agent)), Time)) :-
       not(holds_at(hungry(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(hungry(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(neg(satiated(Agent))), Time)).
 */
axiom(holds_at(neg(neg(satiated(Agent))), Time),
   
    [ holds_at(neg(hungry(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2970
% event Eat(agent,food)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2971
event(eat(Eat_Param,Eat_Ret)).
==> mpred_prop(eat(agent,food),event).
==> meta_argtypes(eat(agent,food)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2972
% [agent,food,time]
% Happens(Eat(agent,food),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2974
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).

 /*  exists([Location],
    happens(eat(Agent, Food), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Food, Location), Time)).
 */

 /*  not(happens(eat(Agent, Food), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Food, Location), Time))
       ),
       some(Location, '$kolem_Fn_229'(Agent, Food, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Food, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Food, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Food, Location)), Time)), some(Location, '$kolem_Fn_229'(Agent, Food, Time))] ->
       ta(Time, not(happens(eat(Agent, Food), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2976
axiom(not(happens(eat(Agent, Food), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Food, Location)), Time)),
      some(Location, '$kolem_Fn_229'(Agent, Food, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(eat(Agent, Food), Time),
       some(Location, '$kolem_Fn_229'(Agent, Food, Time)).
 */

 /*  [happens(eat(Agent, Food), Time), some(Location, '$kolem_Fn_229'(Agent, Food, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(eat(Agent, Food), Time),
      some(Location, '$kolem_Fn_229'(Agent, Food, Time))
    ]).

 /*  holds_at(at(Food, Location), Time) :-
       happens(eat(Agent, Food), Time),
       some(Location, '$kolem_Fn_229'(Agent, Food, Time)).
 */

 /*  [happens(eat(Agent, Food), Time), some(Location, '$kolem_Fn_229'(Agent, Food, Time))] ->
       ta(Time, holds_at(at(Food, Location), Time)).
 */
axiom(holds_at(at(Food, Location), Time),
   
    [ happens(eat(Agent, Food), Time),
      some(Location, '$kolem_Fn_229'(Agent, Food, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2978
% [agent,food,time]
% Terminates(Eat(agent,food),Hungry(agent),time).

 /*  [] ->
       ta(Time,
          terminates(eat(Agent, Food), hungry(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2979
axiom(terminates(eat(Agent, Food), hungry(Agent), Time),
    []).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2981
% sort restaurant: script
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2982
==> subsort(restaurant,script).

% sort waiter: agent
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2983
==> subsort(waiter,agent).

% sort cook: agent
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2984
==> subsort(cook,agent).

% function BillOf(restaurant): bill
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2986
functional_predicate(billOf(BillOf_Param,BillOf_Ret)).
==> mpred_prop(billOf(restaurant,bill),functional_predicate).
==> meta_argtypes(billOf(restaurant,bill)).
==> resultIsa(billOf,bill).

% function CookOf(restaurant): cook
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2987
functional_predicate(cookOf(CookOf_Param,CookOf_Ret)).
==> mpred_prop(cookOf(restaurant,cook),functional_predicate).
==> meta_argtypes(cookOf(restaurant,cook)).
==> resultIsa(cookOf,cook).

% function TableOf(restaurant): table
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2988
functional_predicate(tableOf(TableOf_Param,TableOf_Ret)).
==> mpred_prop(tableOf(restaurant,table),functional_predicate).
==> meta_argtypes(tableOf(restaurant,table)).
==> resultIsa(tableOf,table).

% function WaiterOf(restaurant): waiter
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2989
functional_predicate(waiterOf(WaiterOf_Param,WaiterOf_Ret)).
==> mpred_prop(waiterOf(restaurant,waiter),functional_predicate).
==> meta_argtypes(waiterOf(restaurant,waiter)).
==> resultIsa(waiterOf,waiter).

% function KitchenDoorOf(restaurant): door
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2990
functional_predicate(kitchenDoorOf(KitchenDoorOf_Param,
				   KitchenDoorOf_Ret)).
==> mpred_prop(kitchenDoorOf(restaurant,door),functional_predicate).
==> meta_argtypes(kitchenDoorOf(restaurant,door)).
==> resultIsa(kitchenDoorOf,door).

% fluent BeWaiter0(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2992
fluent(beWaiter0(BeWaiter0_Ret)).
==> mpred_prop(beWaiter0(waiter),fluent).
==> meta_argtypes(beWaiter0(waiter)).

% fluent BeWaiter1(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2994
fluent(beWaiter1(BeWaiter1_Ret)).
==> mpred_prop(beWaiter1(waiter),fluent).
==> meta_argtypes(beWaiter1(waiter)).

% fluent BeWaiter2(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2996
fluent(beWaiter2(BeWaiter2_Ret)).
==> mpred_prop(beWaiter2(waiter),fluent).
==> meta_argtypes(beWaiter2(waiter)).

% fluent BeWaiter3(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:2998
fluent(beWaiter3(BeWaiter3_Ret)).
==> mpred_prop(beWaiter3(waiter),fluent).
==> meta_argtypes(beWaiter3(waiter)).

% fluent BeWaiter4(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3000
fluent(beWaiter4(BeWaiter4_Ret)).
==> mpred_prop(beWaiter4(waiter),fluent).
==> meta_argtypes(beWaiter4(waiter)).

% fluent BeWaiter5(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3002
fluent(beWaiter5(BeWaiter5_Ret)).
==> mpred_prop(beWaiter5(waiter),fluent).
==> meta_argtypes(beWaiter5(waiter)).

% fluent BeWaiter6(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3004
fluent(beWaiter6(BeWaiter6_Ret)).
==> mpred_prop(beWaiter6(waiter),fluent).
==> meta_argtypes(beWaiter6(waiter)).

% fluent BeWaiter7(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3006
fluent(beWaiter7(BeWaiter7_Ret)).
==> mpred_prop(beWaiter7(waiter),fluent).
==> meta_argtypes(beWaiter7(waiter)).

% fluent BeWaiter8(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3008
fluent(beWaiter8(BeWaiter8_Ret)).
==> mpred_prop(beWaiter8(waiter),fluent).
==> meta_argtypes(beWaiter8(waiter)).

% fluent BeWaiter9(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3010
fluent(beWaiter9(BeWaiter9_Ret)).
==> mpred_prop(beWaiter9(waiter),fluent).
==> meta_argtypes(beWaiter9(waiter)).

% xor BeWaiter0, BeWaiter1, BeWaiter2, BeWaiter3, BeWaiter4, BeWaiter5, BeWaiter6, BeWaiter7, BeWaiter8, BeWaiter9
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3012
==> xor([ beWaiter0,
	  beWaiter1,
	  beWaiter2,
	  beWaiter3,
	  beWaiter4,
	  beWaiter5,
	  beWaiter6,
	  beWaiter7,
	  beWaiter8,
	  beWaiter9
	]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3013
% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Terminates(Greet(waiter,agent),
%            BeWaiter0(waiter),
%            time).

 /*  [holds_at(beWaiter0(Waiter), Time)] ->
       ta(Time,
          terminates(greet(Waiter, Agent),
                     beWaiter0(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3017
axiom(terminates(greet(Waiter, Agent), beWaiter0(Waiter), Time),
    [holds_at(beWaiter0(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3019
% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Initiates(Greet(waiter,agent),
%           BeWaiter1(waiter),
%           time).

 /*  [holds_at(beWaiter0(Waiter), Time)] ->
       ta(Time,
          initiates(greet(Waiter, Agent),
                    beWaiter1(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3023
axiom(initiates(greet(Waiter, Agent), beWaiter1(Waiter), Time),
    [holds_at(beWaiter0(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3025
% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Terminates(Order(agent,waiter,food),
%            BeWaiter1(waiter),
%            time).

 /*  [holds_at(beWaiter1(Waiter), Time)] ->
       ta(Time,
          terminates(order(Agent, Waiter, Food),
                     beWaiter1(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3029
axiom(terminates(order(Agent, Waiter, Food), beWaiter1(Waiter), Time),
    [holds_at(beWaiter1(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3031
% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Initiates(Order(agent,waiter,food),
%           BeWaiter2(waiter),
%           time).

 /*  [holds_at(beWaiter1(Waiter), Time)] ->
       ta(Time,
          initiates(order(Agent, Waiter, Food),
                    beWaiter2(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3035
axiom(initiates(order(Agent, Waiter, Food), beWaiter2(Waiter), Time),
    [holds_at(beWaiter1(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3037
% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter2(waiter),time) ->
% Happens(WalkThroughDoor12(waiter,KitchenDoorOf(restaurant)),time).

 /*  allDifferent([Restaurant, Waiter, Time]) ->
       ( waiterOf(Restaurant)=Waiter, holds_at(beWaiter2(Waiter), Time)->happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time)
       ).
 */

 /*  happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         holds_at(beWaiter2(Waiter), Time)
       ),
       allDifferent([Restaurant, Waiter, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), holds_at(beWaiter2(Waiter), Time), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time,
          happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)),
                  Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(beWaiter2(Waiter), Time), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time,
          happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)),
                  Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3040
axiom(happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(beWaiter2(Waiter), Time),
      allDifferent([Restaurant, Waiter, Time])
    ]).

 /*  not(holds_at(beWaiter2(Waiter), Time)) :-
       equals(waiterOf(Restaurant), Waiter),
       not(happens(walkThroughDoor12(Waiter,
                                     kitchenDoorOf(Restaurant)),
                   Time)),
       allDifferent([Restaurant, Waiter, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), not(happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time)), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time, holds_at(neg(beWaiter2(Waiter)), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time)), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time, holds_at(neg(beWaiter2(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter2(Waiter)), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(walkThroughDoor12(Waiter,
                                    kitchenDoorOf(Restaurant)),
                  Time)),
      allDifferent([Restaurant, Waiter, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3042
% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor12(waiter,door),
%            BeWaiter2(waiter),
%            time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(kitchenDoorOf(Restaurant), Door).
 */

 /*  fix_axiom_head(Time) ->
       call(kitchenDoorOf(Restaurant)=Door).
 */

 /*  [holds_at(beWaiter2(Waiter), Time), call(waiterOf(Restaurant)=Waiter), call(kitchenDoorOf(Restaurant)=Door)] ->
       ta(Time,
          terminates(walkThroughDoor12(Waiter, Door),
                     beWaiter2(Waiter),
                     Time)).
 */

 /*  [holds_at(beWaiter2(Waiter), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)] ->
       ta(Time,
          terminates(walkThroughDoor12(Waiter, Door),
                     beWaiter2(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3048
axiom(terminates(walkThroughDoor12(Waiter, Door), beWaiter2(Waiter), Time),
   
    [ holds_at(beWaiter2(Waiter), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3050
% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor12(waiter,door),
%           BeWaiter3(waiter),
%           time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(kitchenDoorOf(Restaurant), Door).
 */

 /*  fix_axiom_head(Time) ->
       call(kitchenDoorOf(Restaurant)=Door).
 */

 /*  [holds_at(beWaiter2(Waiter), Time), call(waiterOf(Restaurant)=Waiter), call(kitchenDoorOf(Restaurant)=Door)] ->
       ta(Time,
          initiates(walkThroughDoor12(Waiter, Door),
                    beWaiter3(Waiter),
                    Time)).
 */

 /*  [holds_at(beWaiter2(Waiter), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)] ->
       ta(Time,
          initiates(walkThroughDoor12(Waiter, Door),
                    beWaiter3(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3056
axiom(initiates(walkThroughDoor12(Waiter, Door), beWaiter3(Waiter), Time),
   
    [ holds_at(beWaiter2(Waiter), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3058
% [restaurant,food,time]
% HoldsAt(BeWaiter3(WaiterOf(restaurant)),time) &
% ({agent} HoldsAt(KnowOrder(WaiterOf(restaurant),agent,food),time)) ->
% Happens(Order(WaiterOf(restaurant),CookOf(restaurant),food),time).

 /*  allDifferent([Restaurant, Time, Agent, Food]) ->
       ( holds_at(beWaiter3(waiterOf(Restaurant)), Time), exists([Agent], holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time))->happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time)
       ).
 */

 /*  happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time) :-
       ( holds_at(beWaiter3(waiterOf(Restaurant)), Time),
         holds_at(knowOrder(waiterOf(Restaurant), Agent, Food),
                  Time)
       ),
       allDifferent([Restaurant, Time, Agent, Food]).
 */

 /*  [holds_at(beWaiter3(waiterOf(Restaurant)), Time), holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time), allDifferent([Restaurant, Time, Agent, Food])] ->
       ta(Time,
          happens(order(waiterOf(Restaurant),
                        cookOf(Restaurant),
                        Food),
                  Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3061
axiom(happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time),
   
    [ holds_at(beWaiter3(waiterOf(Restaurant)), Time),
      holds_at(knowOrder(waiterOf(Restaurant), Agent, Food),
               Time),
      allDifferent([Restaurant, Time, Agent, Food])
    ]).

 /*  not(holds_at(beWaiter3(waiterOf(Restaurant)), Time)) :-
       holds_at(knowOrder(waiterOf(Restaurant), Agent, Food),
                Time),
       not(happens(order(waiterOf(Restaurant),
                         cookOf(Restaurant),
                         Food),
                   Time)),
       allDifferent([Restaurant, Time, Agent, Food]).
 */

 /*  [holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time), not(happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time)), allDifferent([Restaurant, Time, Agent, Food])] ->
       ta(Time,
          holds_at(neg(beWaiter3(waiterOf(Restaurant))), Time)).
 */
axiom(holds_at(neg(beWaiter3(waiterOf(Restaurant))), Time),
   
    [ holds_at(knowOrder(waiterOf(Restaurant), Agent, Food),
               Time),
      not(happens(order(waiterOf(Restaurant),
                        cookOf(Restaurant),
                        Food),
                  Time)),
      allDifferent([Restaurant, Time, Agent, Food])
    ]).

 /*  not(holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time)) :-
       holds_at(beWaiter3(waiterOf(Restaurant)), Time),
       not(happens(order(waiterOf(Restaurant),
                         cookOf(Restaurant),
                         Food),
                   Time)),
       allDifferent([Restaurant, Time, Agent, Food]).
 */

 /*  [holds_at(beWaiter3(waiterOf(Restaurant)), Time), not(happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time)), allDifferent([Restaurant, Time, Agent, Food])] ->
       ta(Time,
          holds_at(neg(knowOrder(waiterOf(Restaurant),
                                 Agent,
                                 Food)),
                   Time)).
 */
axiom(holds_at(neg(knowOrder(waiterOf(Restaurant), Agent, Food)), Time),
   
    [ holds_at(beWaiter3(waiterOf(Restaurant)), Time),
      not(happens(order(waiterOf(Restaurant),
                        cookOf(Restaurant),
                        Food),
                  Time)),
      allDifferent([Restaurant, Time, Agent, Food])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3063
% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Terminates(Order(waiter,cook,food),
%            BeWaiter3(waiter),
%            time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(cookOf(Restaurant), Cook).
 */

 /*  fix_axiom_head(Time) ->
       call(cookOf(Restaurant)=Cook).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(cookOf(Restaurant)=Cook), holds_at(beWaiter3(Waiter), Time)] ->
       ta(Time,
          terminates(order(Waiter, Cook, Food),
                     beWaiter3(Waiter),
                     Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(cookOf(Restaurant)=Cook), Time), holds_at(beWaiter3(Waiter), Time)] ->
       ta(Time,
          terminates(order(Waiter, Cook, Food),
                     beWaiter3(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3069
axiom(terminates(order(Waiter, Cook, Food), beWaiter3(Waiter), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(cookOf(Restaurant)=Cook), Time),
      holds_at(beWaiter3(Waiter), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3071
% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Initiates(Order(waiter,cook,food),
%           BeWaiter4(waiter),
%           time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(cookOf(Restaurant), Cook).
 */

 /*  fix_axiom_head(Time) ->
       call(cookOf(Restaurant)=Cook).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(cookOf(Restaurant)=Cook), holds_at(beWaiter3(Waiter), Time)] ->
       ta(Time,
          initiates(order(Waiter, Cook, Food),
                    beWaiter4(Waiter),
                    Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(cookOf(Restaurant)=Cook), Time), holds_at(beWaiter3(Waiter), Time)] ->
       ta(Time,
          initiates(order(Waiter, Cook, Food),
                    beWaiter4(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3077
axiom(initiates(order(Waiter, Cook, Food), beWaiter4(Waiter), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(cookOf(Restaurant)=Cook), Time),
      holds_at(beWaiter3(Waiter), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3079
% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) &
% HoldsAt(FoodPrepared(food),time) ->
% Happens(PickUp(waiter,food),time).

 /*  allDifferent([Waiter, Time, Agent, Food]) ->
       ( holds_at(beWaiter4(Waiter), Time), exists([Agent], holds_at(knowOrder(Waiter, Agent, Food), Time)), holds_at(foodPrepared(Food), Time)->happens(pickUp(Waiter, Food), Time)
       ).
 */

 /*  happens(pickUp(Waiter, Food), Time) :-
       ( holds_at(beWaiter4(Waiter), Time),
         holds_at(knowOrder(Waiter, Agent, Food), Time),
         holds_at(foodPrepared(Food), Time)
       ),
       allDifferent([Waiter, Time, Agent, Food]).
 */

 /*  [holds_at(beWaiter4(Waiter), Time), holds_at(knowOrder(Waiter, Agent, Food), Time), holds_at(foodPrepared(Food), Time), allDifferent([Waiter, Time, Agent, Food])] ->
       ta(Time, happens(pickUp(Waiter, Food), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3083
axiom(happens(pickUp(Waiter, Food), Time),
   
    [ holds_at(beWaiter4(Waiter), Time),
      holds_at(knowOrder(Waiter, Agent, Food), Time),
      holds_at(foodPrepared(Food), Time),
      allDifferent([Waiter, Time, Agent, Food])
    ]).

 /*  not(holds_at(beWaiter4(Waiter), Time)) :-
       ( holds_at(knowOrder(Waiter, Agent, Food), Time),
         holds_at(foodPrepared(Food), Time)
       ),
       not(happens(pickUp(Waiter, Food), Time)),
       allDifferent([Waiter, Time, Agent, Food]).
 */

 /*  [holds_at(knowOrder(Waiter, Agent, Food), Time), holds_at(foodPrepared(Food), Time), not(happens(pickUp(Waiter, Food), Time)), allDifferent([Waiter, Time, Agent, Food])] ->
       ta(Time, holds_at(neg(beWaiter4(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter4(Waiter)), Time),
   
    [ holds_at(knowOrder(Waiter, Agent, Food), Time),
      holds_at(foodPrepared(Food), Time),
      not(happens(pickUp(Waiter, Food), Time)),
      allDifferent([Waiter, Time, Agent, Food])
    ]).

 /*  not(holds_at(knowOrder(Waiter, Agent, Food), Time)) :-
       holds_at(foodPrepared(Food), Time),
       holds_at(beWaiter4(Waiter), Time),
       not(happens(pickUp(Waiter, Food), Time)),
       allDifferent([Waiter, Time, Agent, Food]).
 */

 /*  [holds_at(foodPrepared(Food), Time), holds_at(beWaiter4(Waiter), Time), not(happens(pickUp(Waiter, Food), Time)), allDifferent([Waiter, Time, Agent, Food])] ->
       ta(Time,
          holds_at(neg(knowOrder(Waiter, Agent, Food)),
                   Time)).
 */
axiom(holds_at(neg(knowOrder(Waiter, Agent, Food)), Time),
   
    [ holds_at(foodPrepared(Food), Time),
      holds_at(beWaiter4(Waiter), Time),
      not(happens(pickUp(Waiter, Food), Time)),
      allDifferent([Waiter, Time, Agent, Food])
    ]).

 /*  not(holds_at(foodPrepared(Food), Time)) :-
       holds_at(knowOrder(Waiter, Agent, Food), Time),
       holds_at(beWaiter4(Waiter), Time),
       not(happens(pickUp(Waiter, Food), Time)),
       allDifferent([Waiter, Time, Agent, Food]).
 */

 /*  [holds_at(knowOrder(Waiter, Agent, Food), Time), holds_at(beWaiter4(Waiter), Time), not(happens(pickUp(Waiter, Food), Time)), allDifferent([Waiter, Time, Agent, Food])] ->
       ta(Time, holds_at(neg(foodPrepared(Food)), Time)).
 */
axiom(holds_at(neg(foodPrepared(Food)), Time),
   
    [ holds_at(knowOrder(Waiter, Agent, Food), Time),
      holds_at(beWaiter4(Waiter), Time),
      not(happens(pickUp(Waiter, Food), Time)),
      allDifferent([Waiter, Time, Agent, Food])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3085
% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Terminates(PickUp(waiter,food),
%            BeWaiter4(waiter),
%            time).

 /*  [holds_at(beWaiter4(Waiter), Time), holds_at(knowOrder(Waiter, Agent, Food), Time)] ->
       ta(Time,
          terminates(pickUp(Waiter, Food),
                     beWaiter4(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3090
axiom(terminates(pickUp(Waiter, Food), beWaiter4(Waiter), Time),
   
    [ holds_at(beWaiter4(Waiter), Time),
      holds_at(knowOrder(Waiter, Agent, Food), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3092
% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Initiates(PickUp(waiter,food),
%           BeWaiter5(waiter),
%           time).

 /*  [holds_at(beWaiter4(Waiter), Time), holds_at(knowOrder(Waiter, Agent, Food), Time)] ->
       ta(Time,
          initiates(pickUp(Waiter, Food),
                    beWaiter5(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3097
axiom(initiates(pickUp(Waiter, Food), beWaiter5(Waiter), Time),
   
    [ holds_at(beWaiter4(Waiter), Time),
      holds_at(knowOrder(Waiter, Agent, Food), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3099
% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter5(waiter),time) ->
% Happens(WalkThroughDoor21(waiter,KitchenDoorOf(restaurant)),time).

 /*  allDifferent([Restaurant, Waiter, Time]) ->
       ( waiterOf(Restaurant)=Waiter, holds_at(beWaiter5(Waiter), Time)->happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time)
       ).
 */

 /*  happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         holds_at(beWaiter5(Waiter), Time)
       ),
       allDifferent([Restaurant, Waiter, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), holds_at(beWaiter5(Waiter), Time), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time,
          happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)),
                  Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(beWaiter5(Waiter), Time), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time,
          happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)),
                  Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3102
axiom(happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(beWaiter5(Waiter), Time),
      allDifferent([Restaurant, Waiter, Time])
    ]).

 /*  not(holds_at(beWaiter5(Waiter), Time)) :-
       equals(waiterOf(Restaurant), Waiter),
       not(happens(walkThroughDoor21(Waiter,
                                     kitchenDoorOf(Restaurant)),
                   Time)),
       allDifferent([Restaurant, Waiter, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), not(happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time)), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time, holds_at(neg(beWaiter5(Waiter)), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time)), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time, holds_at(neg(beWaiter5(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter5(Waiter)), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(walkThroughDoor21(Waiter,
                                    kitchenDoorOf(Restaurant)),
                  Time)),
      allDifferent([Restaurant, Waiter, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3104
% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor21(waiter,door),
%            BeWaiter5(waiter),
%            time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(kitchenDoorOf(Restaurant), Door).
 */

 /*  fix_axiom_head(Time) ->
       call(kitchenDoorOf(Restaurant)=Door).
 */

 /*  [holds_at(beWaiter5(Waiter), Time), call(waiterOf(Restaurant)=Waiter), call(kitchenDoorOf(Restaurant)=Door)] ->
       ta(Time,
          terminates(walkThroughDoor21(Waiter, Door),
                     beWaiter5(Waiter),
                     Time)).
 */

 /*  [holds_at(beWaiter5(Waiter), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)] ->
       ta(Time,
          terminates(walkThroughDoor21(Waiter, Door),
                     beWaiter5(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3110
axiom(terminates(walkThroughDoor21(Waiter, Door), beWaiter5(Waiter), Time),
   
    [ holds_at(beWaiter5(Waiter), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3112
% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor21(waiter,door),
%           BeWaiter6(waiter),
%           time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(kitchenDoorOf(Restaurant), Door).
 */

 /*  fix_axiom_head(Time) ->
       call(kitchenDoorOf(Restaurant)=Door).
 */

 /*  [holds_at(beWaiter5(Waiter), Time), call(waiterOf(Restaurant)=Waiter), call(kitchenDoorOf(Restaurant)=Door)] ->
       ta(Time,
          initiates(walkThroughDoor21(Waiter, Door),
                    beWaiter6(Waiter),
                    Time)).
 */

 /*  [holds_at(beWaiter5(Waiter), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)] ->
       ta(Time,
          initiates(walkThroughDoor21(Waiter, Door),
                    beWaiter6(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3118
axiom(initiates(walkThroughDoor21(Waiter, Door), beWaiter6(Waiter), Time),
   
    [ holds_at(beWaiter5(Waiter), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3120
% [restaurant,waiter,table,food,time]
% WaiterOf(restaurant)=waiter &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter6(waiter),time) &
% HoldsAt(Holding(waiter,food),time) ->
% Happens(PlaceOn(waiter,food,table),time).

 /*  allDifferent([Restaurant, Waiter, Table, Time, Food]) ->
       ( waiterOf(Restaurant)=Waiter, tableOf(Restaurant)=Table, holds_at(beWaiter6(Waiter), Time), holds_at(holding(Waiter, Food), Time)->happens(placeOn(Waiter, Food, Table), Time)
       ).
 */

 /*  happens(placeOn(Waiter, Food, Table), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         equals(tableOf(Restaurant), Table),
         holds_at(beWaiter6(Waiter), Time),
         holds_at(holding(Waiter, Food), Time)
       ),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Table,
                      Time,
                      Food
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(tableOf(Restaurant)=Table), holds_at(beWaiter6(Waiter), Time), holds_at(holding(Waiter, Food), Time), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time,
          happens(placeOn(Waiter, Food, Table), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(beWaiter6(Waiter), Time), holds_at(holding(Waiter, Food), Time), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time,
          happens(placeOn(Waiter, Food, Table), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3125
axiom(happens(placeOn(Waiter, Food, Table), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(beWaiter6(Waiter), Time),
      holds_at(holding(Waiter, Food), Time),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Table,
                     Time,
                     Food
                   ])
    ]).

 /*  not(holds_at(beWaiter6(Waiter), Time)) :-
       holds_at(holding(Waiter, Food), Time),
       equals(tableOf(Restaurant), Table),
       equals(waiterOf(Restaurant), Waiter),
       not(happens(placeOn(Waiter, Food, Table), Time)),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Table,
                      Time,
                      Food
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [holds_at(holding(Waiter, Food), Time), call(tableOf(Restaurant)=Table), call(waiterOf(Restaurant)=Waiter), not(happens(placeOn(Waiter, Food, Table), Time)), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time, holds_at(neg(beWaiter6(Waiter)), Time)).
 */

 /*  [holds_at(holding(Waiter, Food), Time), holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(placeOn(Waiter, Food, Table), Time)), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time, holds_at(neg(beWaiter6(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter6(Waiter)), Time),
   
    [ holds_at(holding(Waiter, Food), Time),
      holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(placeOn(Waiter, Food, Table), Time)),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Table,
                     Time,
                     Food
                   ])
    ]).

 /*  not(holds_at(holding(Waiter, Food), Time)) :-
       holds_at(beWaiter6(Waiter), Time),
       equals(tableOf(Restaurant), Table),
       equals(waiterOf(Restaurant), Waiter),
       not(happens(placeOn(Waiter, Food, Table), Time)),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Table,
                      Time,
                      Food
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [holds_at(beWaiter6(Waiter), Time), call(tableOf(Restaurant)=Table), call(waiterOf(Restaurant)=Waiter), not(happens(placeOn(Waiter, Food, Table), Time)), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time, holds_at(neg(holding(Waiter, Food)), Time)).
 */

 /*  [holds_at(beWaiter6(Waiter), Time), holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(placeOn(Waiter, Food, Table), Time)), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time, holds_at(neg(holding(Waiter, Food)), Time)).
 */
axiom(holds_at(neg(holding(Waiter, Food)), Time),
   
    [ holds_at(beWaiter6(Waiter), Time),
      holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(placeOn(Waiter, Food, Table), Time)),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Table,
                     Time,
                     Food
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3127
% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Terminates(PlaceOn(waiter,food,table),
%            BeWaiter6(waiter),
%            time).

 /*  [holds_at(beWaiter6(Waiter), Time)] ->
       ta(Time,
          terminates(placeOn(Waiter, Food, Table),
                     beWaiter6(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3131
axiom(terminates(placeOn(Waiter, Food, Table), beWaiter6(Waiter), Time),
    [holds_at(beWaiter6(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3133
% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Initiates(PlaceOn(waiter,food,table),
%           BeWaiter7(waiter),
%           time).

 /*  [holds_at(beWaiter6(Waiter), Time)] ->
       ta(Time,
          initiates(placeOn(Waiter, Food, Table),
                    beWaiter7(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3137
axiom(initiates(placeOn(Waiter, Food, Table), beWaiter7(Waiter), Time),
    [holds_at(beWaiter6(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3139
% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Terminates(Request(agent,waiter,bill),
%            BeWaiter7(waiter),
%            time).

 /*  [holds_at(beWaiter7(Waiter), Time)] ->
       ta(Time,
          terminates(request(Agent, Waiter, Bill),
                     beWaiter7(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3143
axiom(terminates(request(Agent, Waiter, Bill), beWaiter7(Waiter), Time),
    [holds_at(beWaiter7(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3145
% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Initiates(Request(agent,waiter,bill),
%           BeWaiter8(waiter),
%           time).

 /*  [holds_at(beWaiter7(Waiter), Time)] ->
       ta(Time,
          initiates(request(Agent, Waiter, Bill),
                    beWaiter8(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3149
axiom(initiates(request(Agent, Waiter, Bill), beWaiter8(Waiter), Time),
    [holds_at(beWaiter7(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3151
% [restaurant,waiter,bill,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% HoldsAt(BeWaiter8(waiter),time) ->
% Happens(PickUp(waiter,bill),time).

 /*  allDifferent([Restaurant, Waiter, Bill, Time]) ->
       ( waiterOf(Restaurant)=Waiter, billOf(Restaurant)=Bill, holds_at(beWaiter8(Waiter), Time)->happens(pickUp(Waiter, Bill), Time)
       ).
 */

 /*  happens(pickUp(Waiter, Bill), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         equals(billOf(Restaurant), Bill),
         holds_at(beWaiter8(Waiter), Time)
       ),
       allDifferent([Restaurant, Waiter, Bill, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(billOf(Restaurant), Bill).
 */

 /*  fix_axiom_head(Time) ->
       call(billOf(Restaurant)=Bill).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(billOf(Restaurant)=Bill), holds_at(beWaiter8(Waiter), Time), allDifferent([Restaurant, Waiter, Bill, Time])] ->
       ta(Time, happens(pickUp(Waiter, Bill), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(billOf(Restaurant)=Bill), Time), holds_at(beWaiter8(Waiter), Time), allDifferent([Restaurant, Waiter, Bill, Time])] ->
       ta(Time, happens(pickUp(Waiter, Bill), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3155
axiom(happens(pickUp(Waiter, Bill), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(billOf(Restaurant)=Bill), Time),
      holds_at(beWaiter8(Waiter), Time),
      allDifferent([Restaurant, Waiter, Bill, Time])
    ]).

 /*  not(holds_at(beWaiter8(Waiter), Time)) :-
       equals(billOf(Restaurant), Bill),
       equals(waiterOf(Restaurant), Waiter),
       not(happens(pickUp(Waiter, Bill), Time)),
       allDifferent([Restaurant, Waiter, Bill, Time]).
 */

 /*  axiom_head(Time) ->
       equals(billOf(Restaurant), Bill).
 */

 /*  fix_axiom_head(Time) ->
       call(billOf(Restaurant)=Bill).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(billOf(Restaurant)=Bill), call(waiterOf(Restaurant)=Waiter), not(happens(pickUp(Waiter, Bill), Time)), allDifferent([Restaurant, Waiter, Bill, Time])] ->
       ta(Time, holds_at(neg(beWaiter8(Waiter)), Time)).
 */

 /*  [holds_at(call(billOf(Restaurant)=Bill), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(pickUp(Waiter, Bill), Time)), allDifferent([Restaurant, Waiter, Bill, Time])] ->
       ta(Time, holds_at(neg(beWaiter8(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter8(Waiter)), Time),
   
    [ holds_at(call(billOf(Restaurant)=Bill), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(pickUp(Waiter, Bill), Time)),
      allDifferent([Restaurant, Waiter, Bill, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3157
% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Terminates(PickUp(waiter,bill),
%            BeWaiter8(waiter),
%            time).

 /*  [holds_at(beWaiter8(Waiter), Time)] ->
       ta(Time,
          terminates(pickUp(Waiter, Bill),
                     beWaiter8(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3161
axiom(terminates(pickUp(Waiter, Bill), beWaiter8(Waiter), Time),
    [holds_at(beWaiter8(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3163
% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Initiates(PickUp(waiter,bill),
%           BeWaiter9(waiter),
%           time).

 /*  [holds_at(beWaiter8(Waiter), Time)] ->
       ta(Time,
          initiates(pickUp(Waiter, Bill),
                    beWaiter9(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3167
axiom(initiates(pickUp(Waiter, Bill), beWaiter9(Waiter), Time),
    [holds_at(beWaiter8(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3169
% [restaurant,waiter,bill,table,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter9(waiter),time) ->
% Happens(PlaceOn(waiter,bill,table),time).

 /*  allDifferent([Restaurant, Waiter, Bill, Table, Time]) ->
       ( waiterOf(Restaurant)=Waiter, billOf(Restaurant)=Bill, tableOf(Restaurant)=Table, holds_at(beWaiter9(Waiter), Time)->happens(placeOn(Waiter, Bill, Table), Time)
       ).
 */

 /*  happens(placeOn(Waiter, Bill, Table), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         equals(billOf(Restaurant), Bill),
         equals(tableOf(Restaurant), Table),
         holds_at(beWaiter9(Waiter), Time)
       ),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Bill,
                      Table,
                      Time
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(billOf(Restaurant), Bill).
 */

 /*  fix_axiom_head(Time) ->
       call(billOf(Restaurant)=Bill).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(billOf(Restaurant)=Bill), call(tableOf(Restaurant)=Table), holds_at(beWaiter9(Waiter), Time), allDifferent([Restaurant, Waiter, Bill, Table, Time])] ->
       ta(Time,
          happens(placeOn(Waiter, Bill, Table), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(billOf(Restaurant)=Bill), Time), holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(beWaiter9(Waiter), Time), allDifferent([Restaurant, Waiter, Bill, Table, Time])] ->
       ta(Time,
          happens(placeOn(Waiter, Bill, Table), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3174
axiom(happens(placeOn(Waiter, Bill, Table), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(billOf(Restaurant)=Bill), Time),
      holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(beWaiter9(Waiter), Time),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Bill,
                     Table,
                     Time
                   ])
    ]).

 /*  not(holds_at(beWaiter9(Waiter), Time)) :-
       equals(tableOf(Restaurant), Table),
       equals(billOf(Restaurant), Bill),
       equals(waiterOf(Restaurant), Waiter),
       not(happens(placeOn(Waiter, Bill, Table), Time)),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Bill,
                      Table,
                      Time
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  axiom_head(Time) ->
       equals(billOf(Restaurant), Bill).
 */

 /*  fix_axiom_head(Time) ->
       call(billOf(Restaurant)=Bill).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(tableOf(Restaurant)=Table), call(billOf(Restaurant)=Bill), call(waiterOf(Restaurant)=Waiter), not(happens(placeOn(Waiter, Bill, Table), Time)), allDifferent([Restaurant, Waiter, Bill, Table, Time])] ->
       ta(Time, holds_at(neg(beWaiter9(Waiter)), Time)).
 */

 /*  [holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(call(billOf(Restaurant)=Bill), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(placeOn(Waiter, Bill, Table), Time)), allDifferent([Restaurant, Waiter, Bill, Table, Time])] ->
       ta(Time, holds_at(neg(beWaiter9(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter9(Waiter)), Time),
   
    [ holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(call(billOf(Restaurant)=Bill), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(placeOn(Waiter, Bill, Table), Time)),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Bill,
                     Table,
                     Time
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3176
% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Terminates(PlaceOn(waiter,bill,table),
%            BeWaiter9(waiter),
%            time).

 /*  [holds_at(beWaiter9(Waiter), Time)] ->
       ta(Time,
          terminates(placeOn(Waiter, Bill, Table),
                     beWaiter9(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3180
axiom(terminates(placeOn(Waiter, Bill, Table), beWaiter9(Waiter), Time),
    [holds_at(beWaiter9(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3182
% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Initiates(PlaceOn(waiter,bill,table),
%           BeWaiter0(waiter),
%           time).

 /*  [holds_at(beWaiter9(Waiter), Time)] ->
       ta(Time,
          initiates(placeOn(Waiter, Bill, Table),
                    beWaiter0(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3186
axiom(initiates(placeOn(Waiter, Bill, Table), beWaiter0(Waiter), Time),
    [holds_at(beWaiter9(Waiter), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3188
% fluent BeCook0(cook)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3189
fluent(beCook0(BeCook0_Ret)).
==> mpred_prop(beCook0(cook),fluent).
==> meta_argtypes(beCook0(cook)).

% fluent BeCook1(cook)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3191
fluent(beCook1(BeCook1_Ret)).
==> mpred_prop(beCook1(cook),fluent).
==> meta_argtypes(beCook1(cook)).

% xor BeCook0, BeCook1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3193
==> xor([beCook0,beCook1]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3194
% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Terminates(Order(agent,cook,food),
%            BeCook0(cook),
%            time).

 /*  [holds_at(beCook0(Cook), Time)] ->
       ta(Time,
          terminates(order(Agent, Cook, Food),
                     beCook0(Cook),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3198
axiom(terminates(order(Agent, Cook, Food), beCook0(Cook), Time),
    [holds_at(beCook0(Cook), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3200
% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Initiates(Order(agent,cook,food),
%           BeCook1(cook),
%           time).

 /*  [holds_at(beCook0(Cook), Time)] ->
       ta(Time,
          initiates(order(Agent, Cook, Food),
                    beCook1(Cook),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3204
axiom(initiates(order(Agent, Cook, Food), beCook1(Cook), Time),
    [holds_at(beCook0(Cook), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3206
% event FoodPrepare(agent,food)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3207
event(foodPrepare(FoodPrepare_Param,FoodPrepare_Ret)).
==> mpred_prop(foodPrepare(agent,food),event).
==> meta_argtypes(foodPrepare(agent,food)).

% fluent FoodPrepared(food)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3209
fluent(foodPrepared(FoodPrepared_Ret)).
==> mpred_prop(foodPrepared(food),fluent).
==> meta_argtypes(foodPrepared(food)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3210
% [agent,food,time]
% Initiates(FoodPrepare(agent,food),
%           FoodPrepared(food),
%           time).

 /*  [] ->
       ta(Time,
          initiates(foodPrepare(Agent, Food),
                    foodPrepared(Food),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3213
axiom(initiates(foodPrepare(Agent, Food), foodPrepared(Food), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3215
% [agent,food,time]
% Happens(FoodPrepare(agent,food),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3217
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).

 /*  exists([Location],
    happens(foodPrepare(Agent, Food), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Food, Location), Time)).
 */

 /*  not(happens(foodPrepare(Agent, Food), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Food, Location), Time))
       ),
       some(Location, '$kolem_Fn_234'(Agent, Food, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Food, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Food, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Food, Location)), Time)), some(Location, '$kolem_Fn_234'(Agent, Food, Time))] ->
       ta(Time,
          not(happens(foodPrepare(Agent, Food), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3219
axiom(not(happens(foodPrepare(Agent, Food), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Food, Location)), Time)),
      some(Location, '$kolem_Fn_234'(Agent, Food, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(foodPrepare(Agent, Food), Time),
       some(Location, '$kolem_Fn_234'(Agent, Food, Time)).
 */

 /*  [happens(foodPrepare(Agent, Food), Time), some(Location, '$kolem_Fn_234'(Agent, Food, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(foodPrepare(Agent, Food), Time),
      some(Location, '$kolem_Fn_234'(Agent, Food, Time))
    ]).

 /*  holds_at(at(Food, Location), Time) :-
       happens(foodPrepare(Agent, Food), Time),
       some(Location, '$kolem_Fn_234'(Agent, Food, Time)).
 */

 /*  [happens(foodPrepare(Agent, Food), Time), some(Location, '$kolem_Fn_234'(Agent, Food, Time))] ->
       ta(Time, holds_at(at(Food, Location), Time)).
 */
axiom(holds_at(at(Food, Location), Time),
   
    [ happens(foodPrepare(Agent, Food), Time),
      some(Location, '$kolem_Fn_234'(Agent, Food, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3221
% [cook,agent,food,time]
% HoldsAt(BeCook1(cook),time) &
% HoldsAt(KnowOrder(cook,agent,food),time) ->
% Happens(FoodPrepare(cook,food),time).

 /*  allDifferent([Cook, Time, Agent, Food]) ->
       ( holds_at(beCook1(Cook), Time), holds_at(knowOrder(Cook, Agent, Food), Time)->happens(foodPrepare(Cook, Food), Time)
       ).
 */

 /*  happens(foodPrepare(Cook, Food), Time) :-
       ( holds_at(beCook1(Cook), Time),
         holds_at(knowOrder(Cook, Agent, Food), Time)
       ),
       allDifferent([Cook, Time, Agent, Food]).
 */

 /*  [holds_at(beCook1(Cook), Time), holds_at(knowOrder(Cook, Agent, Food), Time), allDifferent([Cook, Time, Agent, Food])] ->
       ta(Time, happens(foodPrepare(Cook, Food), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3224
axiom(happens(foodPrepare(Cook, Food), Time),
   
    [ holds_at(beCook1(Cook), Time),
      holds_at(knowOrder(Cook, Agent, Food), Time),
      allDifferent([Cook, Time, Agent, Food])
    ]).

 /*  not(holds_at(beCook1(Cook), Time)) :-
       holds_at(knowOrder(Cook, Agent, Food), Time),
       not(happens(foodPrepare(Cook, Food), Time)),
       allDifferent([Cook, Time, Agent, Food]).
 */

 /*  [holds_at(knowOrder(Cook, Agent, Food), Time), not(happens(foodPrepare(Cook, Food), Time)), allDifferent([Cook, Time, Agent, Food])] ->
       ta(Time, holds_at(neg(beCook1(Cook)), Time)).
 */
axiom(holds_at(neg(beCook1(Cook)), Time),
   
    [ holds_at(knowOrder(Cook, Agent, Food), Time),
      not(happens(foodPrepare(Cook, Food), Time)),
      allDifferent([Cook, Time, Agent, Food])
    ]).

 /*  not(holds_at(knowOrder(Cook, Agent, Food), Time)) :-
       holds_at(beCook1(Cook), Time),
       not(happens(foodPrepare(Cook, Food), Time)),
       allDifferent([Cook, Time, Agent, Food]).
 */

 /*  [holds_at(beCook1(Cook), Time), not(happens(foodPrepare(Cook, Food), Time)), allDifferent([Cook, Time, Agent, Food])] ->
       ta(Time,
          holds_at(neg(knowOrder(Cook, Agent, Food)), Time)).
 */
axiom(holds_at(neg(knowOrder(Cook, Agent, Food)), Time),
   
    [ holds_at(beCook1(Cook), Time),
      not(happens(foodPrepare(Cook, Food), Time)),
      allDifferent([Cook, Time, Agent, Food])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3226
% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Terminates(FoodPrepare(cook,food),
%            BeCook1(cook),
%            time).

 /*  [holds_at(beCook1(Cook), Time)] ->
       ta(Time,
          terminates(foodPrepare(Cook, Food),
                     beCook1(Cook),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3230
axiom(terminates(foodPrepare(Cook, Food), beCook1(Cook), Time),
    [holds_at(beCook1(Cook), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3232
% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Initiates(FoodPrepare(cook,food),
%           BeCook0(cook),
%           time).

 /*  [holds_at(beCook1(Cook), Time)] ->
       ta(Time,
          initiates(foodPrepare(Cook, Food),
                    beCook0(Cook),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3236
axiom(initiates(foodPrepare(Cook, Food), beCook0(Cook), Time),
    [holds_at(beCook1(Cook), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3238
% event Pay(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3239
event(pay(Pay_Param,Pay_Ret)).
==> mpred_prop(pay(agent,agent),event).
==> meta_argtypes(pay(agent,agent)).

% event Tip(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3241
event(tip(Tip_Param,Tip_Ret)).
==> mpred_prop(tip(agent,agent),event).
==> meta_argtypes(tip(agent,agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3242
% [agent,physobj,time]
% Happens(LieOn(agent,physobj),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3244
% {room}% 
%  HoldsAt(At(agent,room),time) &
%  HoldsAt(At(physobj,room),time).

 /*  exists([Room],
    happens(lieOn(Agent, Physobj), Time) ->
       holds_at(at(Agent, Room), Time),
       holds_at(at(Physobj, Room), Time)).
 */

 /*  not(happens(lieOn(Agent, Physobj), Time)) :-
       (   not(holds_at(at(Agent, Room), Time))
       ;   not(holds_at(at(Physobj, Room), Time))
       ),
       some(Room, '$kolem_Fn_235'(Agent, Physobj, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Room), Time))
       ;   not(holds_at(at(Physobj, Room), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Room)), Time)
       ;   holds_at(neg(at(Physobj, Room)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Room)), Time);holds_at(neg(at(Physobj, Room)), Time)), some(Room, '$kolem_Fn_235'(Agent, Physobj, Time))] ->
       ta(Time, not(happens(lieOn(Agent, Physobj), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3246
axiom(not(happens(lieOn(Agent, Physobj), Time)),
   
    [  (holds_at(neg(at(Agent, Room)), Time);holds_at(neg(at(Physobj, Room)), Time)),
      some(Room, '$kolem_Fn_235'(Agent, Physobj, Time))
    ]).

 /*  holds_at(at(Agent, Room), Time) :-
       happens(lieOn(Agent, Physobj), Time),
       some(Room, '$kolem_Fn_235'(Agent, Physobj, Time)).
 */

 /*  [happens(lieOn(Agent, Physobj), Time), some(Room, '$kolem_Fn_235'(Agent, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent, Room), Time)).
 */
axiom(holds_at(at(Agent, Room), Time),
   
    [ happens(lieOn(Agent, Physobj), Time),
      some(Room, '$kolem_Fn_235'(Agent, Physobj, Time))
    ]).

 /*  holds_at(at(Physobj, Room), Time) :-
       happens(lieOn(Agent, Physobj), Time),
       some(Room, '$kolem_Fn_235'(Agent, Physobj, Time)).
 */

 /*  [happens(lieOn(Agent, Physobj), Time), some(Room, '$kolem_Fn_235'(Agent, Physobj, Time))] ->
       ta(Time, holds_at(at(Physobj, Room), Time)).
 */
axiom(holds_at(at(Physobj, Room), Time),
   
    [ happens(lieOn(Agent, Physobj), Time),
      some(Room, '$kolem_Fn_235'(Agent, Physobj, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3248
% [agent,physobj,time]
% Happens(SitOn(agent,physobj),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3250
% {room}% 
%  HoldsAt(At(agent,room),time) &
%  HoldsAt(At(physobj,room),time).

 /*  exists([Room],
    happens(sitOn(Agent, Physobj), Time) ->
       holds_at(at(Agent, Room), Time),
       holds_at(at(Physobj, Room), Time)).
 */

 /*  not(happens(sitOn(Agent, Physobj), Time)) :-
       (   not(holds_at(at(Agent, Room), Time))
       ;   not(holds_at(at(Physobj, Room), Time))
       ),
       some(Room, '$kolem_Fn_236'(Agent, Physobj, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Room), Time))
       ;   not(holds_at(at(Physobj, Room), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Room)), Time)
       ;   holds_at(neg(at(Physobj, Room)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Room)), Time);holds_at(neg(at(Physobj, Room)), Time)), some(Room, '$kolem_Fn_236'(Agent, Physobj, Time))] ->
       ta(Time, not(happens(sitOn(Agent, Physobj), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3252
axiom(not(happens(sitOn(Agent, Physobj), Time)),
   
    [  (holds_at(neg(at(Agent, Room)), Time);holds_at(neg(at(Physobj, Room)), Time)),
      some(Room, '$kolem_Fn_236'(Agent, Physobj, Time))
    ]).

 /*  holds_at(at(Agent, Room), Time) :-
       happens(sitOn(Agent, Physobj), Time),
       some(Room, '$kolem_Fn_236'(Agent, Physobj, Time)).
 */

 /*  [happens(sitOn(Agent, Physobj), Time), some(Room, '$kolem_Fn_236'(Agent, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent, Room), Time)).
 */
axiom(holds_at(at(Agent, Room), Time),
   
    [ happens(sitOn(Agent, Physobj), Time),
      some(Room, '$kolem_Fn_236'(Agent, Physobj, Time))
    ]).

 /*  holds_at(at(Physobj, Room), Time) :-
       happens(sitOn(Agent, Physobj), Time),
       some(Room, '$kolem_Fn_236'(Agent, Physobj, Time)).
 */

 /*  [happens(sitOn(Agent, Physobj), Time), some(Room, '$kolem_Fn_236'(Agent, Physobj, Time))] ->
       ta(Time, holds_at(at(Physobj, Room), Time)).
 */
axiom(holds_at(at(Physobj, Room), Time),
   
    [ happens(sitOn(Agent, Physobj), Time),
      some(Room, '$kolem_Fn_236'(Agent, Physobj, Time))
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3254
% event LieOn(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3255
event(lieOn(LieOn_Param,LieOn_Ret)).
==> mpred_prop(lieOn(agent,physobj),event).
==> meta_argtypes(lieOn(agent,physobj)).

% event SitOn(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3257
event(sitOn(SitOn_Param,SitOn_Ret)).
==> mpred_prop(sitOn(agent,physobj),event).
==> meta_argtypes(sitOn(agent,physobj)).

% event RiseFrom(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3259
event(riseFrom(RiseFrom_Param,RiseFrom_Ret)).
==> mpred_prop(riseFrom(agent,physobj),event).
==> meta_argtypes(riseFrom(agent,physobj)).

% fluent LyingOn(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3261
fluent(lyingOn(LyingOn_Param,LyingOn_Ret)).
==> mpred_prop(lyingOn(agent,physobj),fluent).
==> meta_argtypes(lyingOn(agent,physobj)).

% fluent SittingOn(agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3262
fluent(sittingOn(SittingOn_Param,SittingOn_Ret)).
==> mpred_prop(sittingOn(agent,physobj),fluent).
==> meta_argtypes(sittingOn(agent,physobj)).

% fluent Standing(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3263
fluent(standing(Standing_Ret)).
==> mpred_prop(standing(agent),fluent).
==> meta_argtypes(standing(agent)).

% fluent Lying(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3265
fluent(lying(Lying_Ret)).
==> mpred_prop(lying(agent),fluent).
==> meta_argtypes(lying(agent)).

% fluent Sitting(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3266
fluent(sitting(Sitting_Ret)).
==> mpred_prop(sitting(agent),fluent).
==> meta_argtypes(sitting(agent)).

% noninertial Lying
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3267
==> noninertial(lying).

% noninertial Sitting
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3268
==> noninertial(sitting).

% xor Lying, Sitting, Standing
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3270
==> xor([lying,sitting,standing]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3271
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% HoldsAt(Lying(agent),time).

 /*  allDifferent([Agent, Physobj, Time]) ->
       ( holds_at(lyingOn(Agent, Physobj), Time)->holds_at(lying(Agent), Time)
       ).
 */

 /*  holds_at(lying(Agent), Time) :-
       holds_at(lyingOn(Agent, Physobj), Time),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(lyingOn(Agent, Physobj), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time, holds_at(lying(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3273
axiom(holds_at(lying(Agent), Time),
   
    [ holds_at(lyingOn(Agent, Physobj), Time),
      allDifferent([Agent, Physobj, Time])
    ]).

 /*  not(holds_at(lyingOn(Agent, Physobj), Time)) :-
       not(holds_at(lying(Agent), Time)),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(neg(lying(Agent)), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj)), Time)).
 */
axiom(holds_at(neg(lyingOn(Agent, Physobj)), Time),
   
    [ holds_at(neg(lying(Agent)), Time),
      allDifferent([Agent, Physobj, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3275
% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% HoldsAt(Sitting(agent),time).

 /*  allDifferent([Agent, Physobj, Time]) ->
       ( holds_at(sittingOn(Agent, Physobj), Time)->holds_at(sitting(Agent), Time)
       ).
 */

 /*  holds_at(sitting(Agent), Time) :-
       holds_at(sittingOn(Agent, Physobj), Time),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(sittingOn(Agent, Physobj), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time, holds_at(sitting(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3277
axiom(holds_at(sitting(Agent), Time),
   
    [ holds_at(sittingOn(Agent, Physobj), Time),
      allDifferent([Agent, Physobj, Time])
    ]).

 /*  not(holds_at(sittingOn(Agent, Physobj), Time)) :-
       not(holds_at(sitting(Agent), Time)),
       allDifferent([Agent, Physobj, Time]).
 */

 /*  [holds_at(neg(sitting(Agent)), Time), allDifferent([Agent, Physobj, Time])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj)), Time)).
 */
axiom(holds_at(neg(sittingOn(Agent, Physobj)), Time),
   
    [ holds_at(neg(sitting(Agent)), Time),
      allDifferent([Agent, Physobj, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3279
% [agent,physobj1,physobj2,time]
% HoldsAt(LyingOn(agent,physobj1),time) &
% HoldsAt(LyingOn(agent,physobj2),time) ->
% physobj1=physobj2.

 /*  allDifferent([Agent, Physobj1, Time, Physobj2]) ->
       ( holds_at(lyingOn(Agent, Physobj1), Time), holds_at(lyingOn(Agent, Physobj2), Time)->Physobj1=Physobj2
       ).
 */

 /*  not(holds_at(lyingOn(Agent, Physobj1), Time)) :-
       holds_at(lyingOn(Agent, Physobj2), Time),
       not(equals(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Time, Physobj2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Physobj1, Physobj2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Physobj1=Physobj2)).
 */

 /*  [holds_at(lyingOn(Agent, Physobj2), Time), not(call(Physobj1=Physobj2)), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj1)), Time)).
 */

 /*  [holds_at(lyingOn(Agent, Physobj2), Time), holds_at(neg(call(Physobj1=Physobj2)), Time), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3282
axiom(holds_at(neg(lyingOn(Agent, Physobj1)), Time),
   
    [ holds_at(lyingOn(Agent, Physobj2), Time),
      holds_at(neg(call(Physobj1=Physobj2)), Time),
      allDifferent([Agent, Physobj1, Time, Physobj2])
    ]).

 /*  not(holds_at(lyingOn(Agent, Physobj2), Time)) :-
       holds_at(lyingOn(Agent, Physobj1), Time),
       not(equals(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Time, Physobj2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Physobj1, Physobj2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Physobj1=Physobj2)).
 */

 /*  [holds_at(lyingOn(Agent, Physobj1), Time), not(call(Physobj1=Physobj2)), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj2)), Time)).
 */

 /*  [holds_at(lyingOn(Agent, Physobj1), Time), holds_at(neg(call(Physobj1=Physobj2)), Time), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(lyingOn(Agent, Physobj2)), Time)).
 */
axiom(holds_at(neg(lyingOn(Agent, Physobj2)), Time),
   
    [ holds_at(lyingOn(Agent, Physobj1), Time),
      holds_at(neg(call(Physobj1=Physobj2)), Time),
      allDifferent([Agent, Physobj1, Time, Physobj2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3284
% [agent,physobj1,physobj2,time]
% HoldsAt(SittingOn(agent,physobj1),time) &
% HoldsAt(SittingOn(agent,physobj2),time) ->
% physobj1=physobj2.

 /*  allDifferent([Agent, Physobj1, Time, Physobj2]) ->
       ( holds_at(sittingOn(Agent, Physobj1), Time), holds_at(sittingOn(Agent, Physobj2), Time)->Physobj1=Physobj2
       ).
 */

 /*  not(holds_at(sittingOn(Agent, Physobj1), Time)) :-
       holds_at(sittingOn(Agent, Physobj2), Time),
       not(equals(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Time, Physobj2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Physobj1, Physobj2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Physobj1=Physobj2)).
 */

 /*  [holds_at(sittingOn(Agent, Physobj2), Time), not(call(Physobj1=Physobj2)), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj1)), Time)).
 */

 /*  [holds_at(sittingOn(Agent, Physobj2), Time), holds_at(neg(call(Physobj1=Physobj2)), Time), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3287
axiom(holds_at(neg(sittingOn(Agent, Physobj1)), Time),
   
    [ holds_at(sittingOn(Agent, Physobj2), Time),
      holds_at(neg(call(Physobj1=Physobj2)), Time),
      allDifferent([Agent, Physobj1, Time, Physobj2])
    ]).

 /*  not(holds_at(sittingOn(Agent, Physobj2), Time)) :-
       holds_at(sittingOn(Agent, Physobj1), Time),
       not(equals(Physobj1, Physobj2)),
       allDifferent([Agent, Physobj1, Time, Physobj2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Physobj1, Physobj2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Physobj1=Physobj2)).
 */

 /*  [holds_at(sittingOn(Agent, Physobj1), Time), not(call(Physobj1=Physobj2)), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj2)), Time)).
 */

 /*  [holds_at(sittingOn(Agent, Physobj1), Time), holds_at(neg(call(Physobj1=Physobj2)), Time), allDifferent([Agent, Physobj1, Time, Physobj2])] ->
       ta(Time,
          holds_at(neg(sittingOn(Agent, Physobj2)), Time)).
 */
axiom(holds_at(neg(sittingOn(Agent, Physobj2)), Time),
   
    [ holds_at(sittingOn(Agent, Physobj1), Time),
      holds_at(neg(call(Physobj1=Physobj2)), Time),
      allDifferent([Agent, Physobj1, Time, Physobj2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3289
% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(LieOn(agent,physobj),
%           LyingOn(agent,physobj),
%           time).

 /*  [holds_at(standing(Agent), Time)] ->
       ta(Time,
          initiates(lieOn(Agent, Physobj),
                    lyingOn(Agent, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3293
axiom(initiates(lieOn(Agent, Physobj), lyingOn(Agent, Physobj), Time),
    [holds_at(standing(Agent), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3295
% [agent,physobj,time]
% Terminates(LieOn(agent,physobj),
%            Standing(agent),
%            time).

 /*  [] ->
       ta(Time,
          terminates(lieOn(Agent, Physobj),
                     standing(Agent),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3298
axiom(terminates(lieOn(Agent, Physobj), standing(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3300
% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(SitOn(agent,physobj),
%           SittingOn(agent,physobj),
%           time).

 /*  [holds_at(standing(Agent), Time)] ->
       ta(Time,
          initiates(sitOn(Agent, Physobj),
                    sittingOn(Agent, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3304
axiom(initiates(sitOn(Agent, Physobj), sittingOn(Agent, Physobj), Time),
    [holds_at(standing(Agent), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3306
% [agent,physobj,time]
% Terminates(SitOn(agent,physobj),
%            Standing(agent),
%            time).

 /*  [] ->
       ta(Time,
          terminates(sitOn(Agent, Physobj),
                     standing(Agent),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3309
axiom(terminates(sitOn(Agent, Physobj), standing(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3311
% [agent,physobj,time]
% (HoldsAt(SittingOn(agent,physobj),time) |
%  HoldsAt(LyingOn(agent,physobj),time)) ->
% Initiates(RiseFrom(agent,physobj),
%           Standing(agent),
%           time).

 /*  [(holds_at(sittingOn(Agent, Physobj), Time);holds_at(lyingOn(Agent, Physobj), Time))] ->
       ta(Time,
          initiates(riseFrom(Agent, Physobj),
                    standing(Agent),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3316
axiom(initiates(riseFrom(Agent, Physobj), standing(Agent), Time),
   
    [  (holds_at(sittingOn(Agent, Physobj), Time);holds_at(lyingOn(Agent, Physobj), Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3318
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            LyingOn(agent,physobj),
%            time).

 /*  [holds_at(lyingOn(Agent, Physobj), Time)] ->
       ta(Time,
          terminates(riseFrom(Agent, Physobj),
                     lyingOn(Agent, Physobj),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3322
axiom(terminates(riseFrom(Agent, Physobj), lyingOn(Agent, Physobj), Time),
    [holds_at(lyingOn(Agent, Physobj), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3324
% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            SittingOn(agent,physobj),
%            time).

 /*  [holds_at(sittingOn(Agent, Physobj), Time)] ->
       ta(Time,
          terminates(riseFrom(Agent, Physobj),
                     sittingOn(Agent, Physobj),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3328
axiom(terminates(riseFrom(Agent, Physobj), sittingOn(Agent, Physobj), Time),
    [holds_at(sittingOn(Agent, Physobj), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3330
% event Greet(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3331
event(greet(Greet_Param,Greet_Ret)).
==> mpred_prop(greet(agent,agent),event).
==> meta_argtypes(greet(agent,agent)).

% event SayGoodbye(agent,agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3333
event(sayGoodbye(SayGoodbye_Param,SayGoodbye_Ret)).
==> mpred_prop(sayGoodbye(agent,agent),event).
==> meta_argtypes(sayGoodbye(agent,agent)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3334
% [agent1,agent2,time]
% Happens(Greet(agent1,agent2),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3336
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).

 /*  exists([Location],
    happens(greet(Agent1, Agent2), Time) ->
       holds_at(at(Agent1, Location), Time),
       holds_at(at(Agent2, Location), Time)).
 */

 /*  not(happens(greet(Agent1, Agent2), Time)) :-
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ),
       some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent1, Location)), Time)
       ;   holds_at(neg(at(Agent2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)), some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time))] ->
       ta(Time, not(happens(greet(Agent1, Agent2), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3338
axiom(not(happens(greet(Agent1, Agent2), Time)),
   
    [  (holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)),
      some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time))
    ]).

 /*  holds_at(at(Agent1, Location), Time) :-
       happens(greet(Agent1, Agent2), Time),
       some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time)).
 */

 /*  [happens(greet(Agent1, Agent2), Time), some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time))] ->
       ta(Time, holds_at(at(Agent1, Location), Time)).
 */
axiom(holds_at(at(Agent1, Location), Time),
   
    [ happens(greet(Agent1, Agent2), Time),
      some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time))
    ]).

 /*  holds_at(at(Agent2, Location), Time) :-
       happens(greet(Agent1, Agent2), Time),
       some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time)).
 */

 /*  [happens(greet(Agent1, Agent2), Time), some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time))] ->
       ta(Time, holds_at(at(Agent2, Location), Time)).
 */
axiom(holds_at(at(Agent2, Location), Time),
   
    [ happens(greet(Agent1, Agent2), Time),
      some(Location, '$kolem_Fn_237'(Agent1, Agent2, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3340
% [agent1,agent2,time]
% Happens(SayGoodbye(agent1,agent2),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3342
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).

 /*  exists([Location],
    happens(sayGoodbye(Agent1, Agent2), Time) ->
       holds_at(at(Agent1, Location), Time),
       holds_at(at(Agent2, Location), Time)).
 */

 /*  not(happens(sayGoodbye(Agent1, Agent2), Time)) :-
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ),
       some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent1, Location)), Time)
       ;   holds_at(neg(at(Agent2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)), some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time))] ->
       ta(Time,
          not(happens(sayGoodbye(Agent1, Agent2), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3344
axiom(not(happens(sayGoodbye(Agent1, Agent2), Time)),
   
    [  (holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)),
      some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time))
    ]).

 /*  holds_at(at(Agent1, Location), Time) :-
       happens(sayGoodbye(Agent1, Agent2), Time),
       some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time)).
 */

 /*  [happens(sayGoodbye(Agent1, Agent2), Time), some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time))] ->
       ta(Time, holds_at(at(Agent1, Location), Time)).
 */
axiom(holds_at(at(Agent1, Location), Time),
   
    [ happens(sayGoodbye(Agent1, Agent2), Time),
      some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time))
    ]).

 /*  holds_at(at(Agent2, Location), Time) :-
       happens(sayGoodbye(Agent1, Agent2), Time),
       some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time)).
 */

 /*  [happens(sayGoodbye(Agent1, Agent2), Time), some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time))] ->
       ta(Time, holds_at(at(Agent2, Location), Time)).
 */
axiom(holds_at(at(Agent2, Location), Time),
   
    [ happens(sayGoodbye(Agent1, Agent2), Time),
      some(Location, '$kolem_Fn_238'(Agent1, Agent2, Time))
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3346
% event Order(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3347
event(order(Order_Param,_,Order_Ret)).
==> mpred_prop(order(agent,agent,physobj),event).
==> meta_argtypes(order(agent,agent,physobj)).

% fluent KnowOrder(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3349
fluent(knowOrder(KnowOrder_Param,_,KnowOrder_Ret)).
==> mpred_prop(knowOrder(agent,agent,physobj),fluent).
==> meta_argtypes(knowOrder(agent,agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3350
% [agent1,agent2,physobj,time]
% Initiates(Order(agent1,agent2,physobj),
%           KnowOrder(agent2,agent1,physobj),
%           time).

 /*  [] ->
       ta(Time,
          initiates(order(Agent1, Agent2, Physobj),
                    knowOrder(Agent2, Agent1, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3353
axiom(initiates(order(Agent1, Agent2, Physobj), knowOrder(Agent2, Agent1, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3355
% [agent1,agent2,physobj,time]
% Happens(Order(agent1,agent2,physobj),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3357
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).

 /*  exists([Location],
    happens(order(Agent1, Agent2, Physobj), Time) ->
       holds_at(at(Agent1, Location), Time),
       holds_at(at(Agent2, Location), Time)).
 */

 /*  not(happens(order(Agent1, Agent2, Physobj), Time)) :-
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent1, Location)), Time)
       ;   holds_at(neg(at(Agent2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)), some(Location, '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time,
          not(happens(order(Agent1, Agent2, Physobj), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3359
axiom(not(happens(order(Agent1, Agent2, Physobj), Time)),
   
    [  (holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)),
      some(Location,
           '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time))
    ]).

 /*  holds_at(at(Agent1, Location), Time) :-
       happens(order(Agent1, Agent2, Physobj), Time),
       some(Location,
            '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time)).
 */

 /*  [happens(order(Agent1, Agent2, Physobj), Time), some(Location, '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent1, Location), Time)).
 */
axiom(holds_at(at(Agent1, Location), Time),
   
    [ happens(order(Agent1, Agent2, Physobj), Time),
      some(Location,
           '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time))
    ]).

 /*  holds_at(at(Agent2, Location), Time) :-
       happens(order(Agent1, Agent2, Physobj), Time),
       some(Location,
            '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time)).
 */

 /*  [happens(order(Agent1, Agent2, Physobj), Time), some(Location, '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent2, Location), Time)).
 */
axiom(holds_at(at(Agent2, Location), Time),
   
    [ happens(order(Agent1, Agent2, Physobj), Time),
      some(Location,
           '$kolem_Fn_239'(Agent1, Agent2, Physobj, Time))
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3361
% event Request(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3362
event(request(Request_Param,_,Request_Ret)).
==> mpred_prop(request(agent,agent,physobj),event).
==> meta_argtypes(request(agent,agent,physobj)).

% fluent KnowRequest(agent,agent,physobj)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3364
fluent(knowRequest(KnowRequest_Param,
		   _,
		   KnowRequest_Ret)).
==> mpred_prop(knowRequest(agent,agent,physobj),fluent).
==> meta_argtypes(knowRequest(agent,agent,physobj)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3365
% [agent1,agent2,physobj,time]
% Initiates(Request(agent1,agent2,physobj),
%           KnowRequest(agent2,agent1,physobj),
%           time).

 /*  [] ->
       ta(Time,
          initiates(request(Agent1, Agent2, Physobj),
                    knowRequest(Agent2, Agent1, Physobj),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3368
axiom(initiates(request(Agent1, Agent2, Physobj), knowRequest(Agent2, Agent1, Physobj), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3370
% [agent1,agent2,physobj,time]
% Happens(Request(agent1,agent2,physobj),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3372
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).

 /*  exists([Location],
    happens(request(Agent1, Agent2, Physobj), Time) ->
       holds_at(at(Agent1, Location), Time),
       holds_at(at(Agent2, Location), Time)).
 */

 /*  not(happens(request(Agent1, Agent2, Physobj), Time)) :-
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ),
       some(Location,
            '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent1, Location), Time))
       ;   not(holds_at(at(Agent2, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent1, Location)), Time)
       ;   holds_at(neg(at(Agent2, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)), some(Location, '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time,
          not(happens(request(Agent1, Agent2, Physobj),
                      Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3374
axiom(not(happens(request(Agent1, Agent2, Physobj), Time)),
   
    [  (holds_at(neg(at(Agent1, Location)), Time);holds_at(neg(at(Agent2, Location)), Time)),
      some(Location,
           '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time))
    ]).

 /*  holds_at(at(Agent1, Location), Time) :-
       happens(request(Agent1, Agent2, Physobj), Time),
       some(Location,
            '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time)).
 */

 /*  [happens(request(Agent1, Agent2, Physobj), Time), some(Location, '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent1, Location), Time)).
 */
axiom(holds_at(at(Agent1, Location), Time),
   
    [ happens(request(Agent1, Agent2, Physobj), Time),
      some(Location,
           '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time))
    ]).

 /*  holds_at(at(Agent2, Location), Time) :-
       happens(request(Agent1, Agent2, Physobj), Time),
       some(Location,
            '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time)).
 */

 /*  [happens(request(Agent1, Agent2, Physobj), Time), some(Location, '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time))] ->
       ta(Time, holds_at(at(Agent2, Location), Time)).
 */
axiom(holds_at(at(Agent2, Location), Time),
   
    [ happens(request(Agent1, Agent2, Physobj), Time),
      some(Location,
           '$kolem_Fn_240'(Agent1, Agent2, Physobj, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3376
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Diving.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; scuba diving
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3397
% sort object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3398
==> sort(object).

% sort agent: object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3399
==> subsort(agent,object).

% sort diver: agent
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3400
==> subsort(diver,agent).

% sort depth: integer
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3401
==> subsort(depth,integer).

% sort boat: object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3402
==> subsort(boat,object).
%; reference line, anchor line, shotline, SMB line, ...

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3404
% sort line: object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3405
==> subsort(line,object).

% sort equipment: object
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3407
==> subsort(equipment,object).

% sort weight: equipment
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3408
==> subsort(weight,equipment).

% sort fin: equipment
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3409
==> subsort(fin,equipment).

% sort airtank: equipment
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3410
==> subsort(airtank,equipment).
%; buoyancy compensator (BC)
%; buoyancy control device (BCD)

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3413
% sort computer: equipment
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3414
==> subsort(computer,equipment).

% sort bc: equipment
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3415
==> subsort(bc,equipment).

% fluent AtDepth(object,depth)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3417
fluent(atDepth(AtDepth_Param,AtDepth_Ret)).
==> mpred_prop(atDepth(object,depth),fluent).
==> meta_argtypes(atDepth(object,depth)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3418
% [object,depth1,depth2,time]
% HoldsAt(AtDepth(object,depth1),time) &
% HoldsAt(AtDepth(object,depth2),time) ->
% depth1 = depth2.

 /*  allDifferent([Object, Depth1, Time, Depth2]) ->
       ( holds_at(atDepth(Object, Depth1), Time), holds_at(atDepth(Object, Depth2), Time)->Depth1=Depth2
       ).
 */

 /*  not(holds_at(atDepth(Object, Depth1), Time)) :-
       holds_at(atDepth(Object, Depth2), Time),
       not(equals(Depth1, Depth2)),
       allDifferent([Object, Depth1, Time, Depth2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Depth1, Depth2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Depth1=Depth2)).
 */

 /*  [holds_at(atDepth(Object, Depth2), Time), not(call(Depth1=Depth2)), allDifferent([Object, Depth1, Time, Depth2])] ->
       ta(Time,
          holds_at(neg(atDepth(Object, Depth1)), Time)).
 */

 /*  [holds_at(atDepth(Object, Depth2), Time), holds_at(neg(call(Depth1=Depth2)), Time), allDifferent([Object, Depth1, Time, Depth2])] ->
       ta(Time,
          holds_at(neg(atDepth(Object, Depth1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3421
axiom(holds_at(neg(atDepth(Object, Depth1)), Time),
   
    [ holds_at(atDepth(Object, Depth2), Time),
      holds_at(neg(call(Depth1=Depth2)), Time),
      allDifferent([Object, Depth1, Time, Depth2])
    ]).

 /*  not(holds_at(atDepth(Object, Depth2), Time)) :-
       holds_at(atDepth(Object, Depth1), Time),
       not(equals(Depth1, Depth2)),
       allDifferent([Object, Depth1, Time, Depth2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Depth1, Depth2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Depth1=Depth2)).
 */

 /*  [holds_at(atDepth(Object, Depth1), Time), not(call(Depth1=Depth2)), allDifferent([Object, Depth1, Time, Depth2])] ->
       ta(Time,
          holds_at(neg(atDepth(Object, Depth2)), Time)).
 */

 /*  [holds_at(atDepth(Object, Depth1), Time), holds_at(neg(call(Depth1=Depth2)), Time), allDifferent([Object, Depth1, Time, Depth2])] ->
       ta(Time,
          holds_at(neg(atDepth(Object, Depth2)), Time)).
 */
axiom(holds_at(neg(atDepth(Object, Depth2)), Time),
   
    [ holds_at(atDepth(Object, Depth1), Time),
      holds_at(neg(call(Depth1=Depth2)), Time),
      allDifferent([Object, Depth1, Time, Depth2])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3423
% event Ascend(diver,depth)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3424
event(ascend(Ascend_Param,Ascend_Ret)).
==> mpred_prop(ascend(diver,depth),event).
==> meta_argtypes(ascend(diver,depth)).

% event Descend(diver,depth)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3426
event(descend(Descend_Param,Descend_Ret)).
==> mpred_prop(descend(diver,depth),event).
==> meta_argtypes(descend(diver,depth)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3427
% [diver,depth1,depth2,time]
% HoldsAt(AtDepth(diver,depth1),time) &
% Happens(Descend(diver,depth2),time) ->
% depth2>depth1.

 /*  allDifferent([Diver, Depth1, Time, Depth2]) ->
       ( holds_at(atDepth(Diver, Depth1), Time), happens(descend(Diver, Depth2), Time)->Depth2>Depth1
       ).
 */

 /*  comparison(Depth2, Depth1, >) :-
       ( holds_at(atDepth(Diver, Depth1), Time),
         happens(descend(Diver, Depth2), Time)
       ),
       allDifferent([Diver, Depth1, Time, Depth2]).
 */

 /*  [holds_at(atDepth(Diver, Depth1), Time), happens(descend(Diver, Depth2), Time), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time, comparison(Depth2, Depth1, >)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3430
axiom(comparison(Depth2, Depth1, >),
   
    [ holds_at(atDepth(Diver, Depth1), Time),
      happens(descend(Diver, Depth2), Time),
      allDifferent([Diver, Depth1, Time, Depth2])
    ]).

 /*  not(holds_at(atDepth(Diver, Depth1), Time)) :-
       happens(descend(Diver, Depth2), Time),
       not(comparison(Depth2, Depth1, >)),
       allDifferent([Diver, Depth1, Time, Depth2]).
 */

 /*  [happens(descend(Diver, Depth2), Time), not(comparison(Depth2, Depth1, >)), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time, holds_at(neg(atDepth(Diver, Depth1)), Time)).
 */
axiom(holds_at(neg(atDepth(Diver, Depth1)), Time),
   
    [ happens(descend(Diver, Depth2), Time),
      not(comparison(Depth2, Depth1, >)),
      allDifferent([Diver, Depth1, Time, Depth2])
    ]).

 /*  not(happens(descend(Diver, Depth2), Time)) :-
       holds_at(atDepth(Diver, Depth1), Time),
       not(comparison(Depth2, Depth1, >)),
       allDifferent([Diver, Depth1, Time, Depth2]).
 */

 /*  [holds_at(atDepth(Diver, Depth1), Time), not(comparison(Depth2, Depth1, >)), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time, not(happens(descend(Diver, Depth2), Time))).
 */
axiom(not(happens(descend(Diver, Depth2), Time)),
   
    [ holds_at(atDepth(Diver, Depth1), Time),
      not(comparison(Depth2, Depth1, >)),
      allDifferent([Diver, Depth1, Time, Depth2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3432
% [diver,depth1,depth2,time]
% HoldsAt(AtDepth(diver,depth1),time) &
% Happens(Ascend(diver,depth2),time) ->
% depth2<depth1.

 /*  allDifferent([Diver, Depth1, Time, Depth2]) ->
       ( holds_at(atDepth(Diver, Depth1), Time), happens(ascend(Diver, Depth2), Time)->Depth2<Depth1
       ).
 */

 /*  comparison(Depth2, Depth1, <) :-
       ( holds_at(atDepth(Diver, Depth1), Time),
         happens(ascend(Diver, Depth2), Time)
       ),
       allDifferent([Diver, Depth1, Time, Depth2]).
 */

 /*  [holds_at(atDepth(Diver, Depth1), Time), happens(ascend(Diver, Depth2), Time), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time, comparison(Depth2, Depth1, <)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3435
axiom(comparison(Depth2, Depth1, <),
   
    [ holds_at(atDepth(Diver, Depth1), Time),
      happens(ascend(Diver, Depth2), Time),
      allDifferent([Diver, Depth1, Time, Depth2])
    ]).

 /*  not(holds_at(atDepth(Diver, Depth1), Time)) :-
       happens(ascend(Diver, Depth2), Time),
       not(comparison(Depth2, Depth1, <)),
       allDifferent([Diver, Depth1, Time, Depth2]).
 */

 /*  [happens(ascend(Diver, Depth2), Time), not(comparison(Depth2, Depth1, <)), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time, holds_at(neg(atDepth(Diver, Depth1)), Time)).
 */
axiom(holds_at(neg(atDepth(Diver, Depth1)), Time),
   
    [ happens(ascend(Diver, Depth2), Time),
      not(comparison(Depth2, Depth1, <)),
      allDifferent([Diver, Depth1, Time, Depth2])
    ]).

 /*  not(happens(ascend(Diver, Depth2), Time)) :-
       holds_at(atDepth(Diver, Depth1), Time),
       not(comparison(Depth2, Depth1, <)),
       allDifferent([Diver, Depth1, Time, Depth2]).
 */

 /*  [holds_at(atDepth(Diver, Depth1), Time), not(comparison(Depth2, Depth1, <)), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time, not(happens(ascend(Diver, Depth2), Time))).
 */
axiom(not(happens(ascend(Diver, Depth2), Time)),
   
    [ holds_at(atDepth(Diver, Depth1), Time),
      not(comparison(Depth2, Depth1, <)),
      allDifferent([Diver, Depth1, Time, Depth2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3437
% [diver,depth,time]
% Initiates(Descend(diver,depth),AtDepth(diver,depth),time).

 /*  [] ->
       ta(Time,
          initiates(descend(Diver, Depth),
                    atDepth(Diver, Depth),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3438
axiom(initiates(descend(Diver, Depth), atDepth(Diver, Depth), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3440
% [diver,depth1,depth2,time]
% HoldsAt(AtDepth(diver,depth1),time) ->
% Terminates(Descend(diver,depth2),AtDepth(diver,depth1),time).

 /*  [holds_at(atDepth(Diver, Depth1), Time)] ->
       ta(Time,
          terminates(descend(Diver, Depth2),
                     atDepth(Diver, Depth1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3442
axiom(terminates(descend(Diver, Depth2), atDepth(Diver, Depth1), Time),
    [holds_at(atDepth(Diver, Depth1), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3444
% [diver,depth,time]
% Initiates(Ascend(diver,depth),AtDepth(diver,depth),time).

 /*  [] ->
       ta(Time,
          initiates(ascend(Diver, Depth),
                    atDepth(Diver, Depth),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3445
axiom(initiates(ascend(Diver, Depth), atDepth(Diver, Depth), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3447
% [diver,depth1,depth2,time]
% HoldsAt(AtDepth(diver,depth1),time) ->
% Terminates(Ascend(diver,depth2),AtDepth(diver,depth1),time).

 /*  [holds_at(atDepth(Diver, Depth1), Time)] ->
       ta(Time,
          terminates(ascend(Diver, Depth2),
                     atDepth(Diver, Depth1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3449
axiom(terminates(ascend(Diver, Depth2), atDepth(Diver, Depth1), Time),
    [holds_at(atDepth(Diver, Depth1), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3451
% fluent Wearing(diver,equipment)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3452
fluent(wearing(Wearing_Param,Wearing_Ret)).
==> mpred_prop(wearing(diver,equipment),fluent).
==> meta_argtypes(wearing(diver,equipment)).

% event PutOn(diver,equipment)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3454
event(putOn(PutOn_Param,PutOn_Ret)).
==> mpred_prop(putOn(diver,equipment),event).
==> meta_argtypes(putOn(diver,equipment)).

% event TakeOff(diver,equipment)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3456
event(takeOff(TakeOff_Param,TakeOff_Ret)).
==> mpred_prop(takeOff(diver,equipment),event).
==> meta_argtypes(takeOff(diver,equipment)).

% event Lose(diver,equipment)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3458
event(lose(Lose_Param,Lose_Ret)).
==> mpred_prop(lose(diver,equipment),event).
==> meta_argtypes(lose(diver,equipment)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3459
% [diver,equipment,depth,time]
% Releases(PutOn(diver,equipment),AtDepth(equipment,depth),time).

 /*  [] ->
       ta(Time,
          releases(putOn(Diver, Equipment),
                   atDepth(Equipment, Depth),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3460
axiom(releases(putOn(Diver, Equipment), atDepth(Equipment, Depth), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3462
% [diver,equipment,time]
% Releases(PutOn(diver,equipment),UnderWater(equipment),time).

 /*  [] ->
       ta(Time,
          releases(putOn(Diver, Equipment),
                   underWater(Equipment),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3463
axiom(releases(putOn(Diver, Equipment), underWater(Equipment), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3465
% [diver,equipment,time]
% Happens(PutOn(diver,equipment),time) ->
% !{diver1} HoldsAt(Wearing(diver1,equipment),time).

 /*  allDifferent([Diver, Equipment, Time, Diver1]) ->
       ( happens(putOn(Diver, Equipment), Time)->not(exists([Diver1], holds_at(wearing(Diver1, Equipment), Time)))
       ).
 */

 /*  not(holds_at(wearing(Diver1, Equipment), Time)) :-
       happens(putOn(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time, Diver1]).
 */

 /*  [happens(putOn(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time, Diver1])] ->
       ta(Time,
          holds_at(neg(wearing(Diver1, Equipment)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3467
axiom(holds_at(neg(wearing(Diver1, Equipment)), Time),
   
    [ happens(putOn(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time, Diver1])
    ]).

 /*  not(happens(putOn(Diver, Equipment), Time)) :-
       holds_at(wearing(Diver1, Equipment), Time),
       allDifferent([Diver, Equipment, Time, Diver1]).
 */

 /*  [holds_at(wearing(Diver1, Equipment), Time), allDifferent([Diver, Equipment, Time, Diver1])] ->
       ta(Time, not(happens(putOn(Diver, Equipment), Time))).
 */
axiom(not(happens(putOn(Diver, Equipment), Time)),
   
    [ holds_at(wearing(Diver1, Equipment), Time),
      allDifferent([Diver, Equipment, Time, Diver1])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3469
% [diver,depth,equipment,time]
% HoldsAt(Wearing(diver,equipment),time) ->
% (HoldsAt(AtDepth(diver,depth),time) <->
%  HoldsAt(AtDepth(equipment,depth),time)).

 /*  allDifferent([Diver, Equipment, Time, Depth]) ->
       ( holds_at(wearing(Diver, Equipment), Time)->(holds_at(atDepth(Diver, Depth), Time)<->holds_at(atDepth(Equipment, Depth), Time))
       ).
 */

 /*  not(holds_at(wearing(Diver, Equipment), Time)) :-
       (   not(holds_at(atDepth(Equipment, Depth), Time)),
           holds_at(atDepth(Diver, Depth), Time)
       ;   not(holds_at(atDepth(Diver, Depth), Time)),
           holds_at(atDepth(Equipment, Depth), Time)
       ),
       allDifferent([Diver, Equipment, Time, Depth]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(atDepth(Equipment, Depth), Time)),
           holds_at(atDepth(Diver, Depth), Time)
       ;   not(holds_at(atDepth(Diver, Depth), Time)),
           holds_at(atDepth(Equipment, Depth), Time)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(atDepth(Equipment, Depth)), Time),
           holds_at(atDepth(Diver, Depth), Time)
       ;   holds_at(neg(atDepth(Diver, Depth)), Time),
           holds_at(atDepth(Equipment, Depth), Time)
       ).
 */

 /*  [(holds_at(neg(atDepth(Equipment, Depth)), Time), holds_at(atDepth(Diver, Depth), Time);holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(atDepth(Equipment, Depth), Time)), allDifferent([Diver, Equipment, Time, Depth])] ->
       ta(Time,
          holds_at(neg(wearing(Diver, Equipment)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3472
axiom(holds_at(neg(wearing(Diver, Equipment)), Time),
   
    [  (holds_at(neg(atDepth(Equipment, Depth)), Time), holds_at(atDepth(Diver, Depth), Time);holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(atDepth(Equipment, Depth), Time)),
      allDifferent([Diver, Equipment, Time, Depth])
    ]).

 /*  holds_at(atDepth(Equipment, Depth), Time) :-
       holds_at(atDepth(Diver, Depth), Time),
       holds_at(wearing(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time, Depth]).
 */

 /*  [holds_at(atDepth(Diver, Depth), Time), holds_at(wearing(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time, Depth])] ->
       ta(Time, holds_at(atDepth(Equipment, Depth), Time)).
 */
axiom(holds_at(atDepth(Equipment, Depth), Time),
   
    [ holds_at(atDepth(Diver, Depth), Time),
      holds_at(wearing(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time, Depth])
    ]).

 /*  not(holds_at(atDepth(Diver, Depth), Time)) :-
       not(holds_at(atDepth(Equipment, Depth), Time)),
       holds_at(wearing(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time, Depth]).
 */

 /*  [holds_at(neg(atDepth(Equipment, Depth)), Time), holds_at(wearing(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time, Depth])] ->
       ta(Time, holds_at(neg(atDepth(Diver, Depth)), Time)).
 */
axiom(holds_at(neg(atDepth(Diver, Depth)), Time),
   
    [ holds_at(neg(atDepth(Equipment, Depth)), Time),
      holds_at(wearing(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time, Depth])
    ]).

 /*  holds_at(atDepth(Diver, Depth), Time) :-
       holds_at(atDepth(Equipment, Depth), Time),
       holds_at(wearing(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time, Depth]).
 */

 /*  [holds_at(atDepth(Equipment, Depth), Time), holds_at(wearing(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time, Depth])] ->
       ta(Time, holds_at(atDepth(Diver, Depth), Time)).
 */
axiom(holds_at(atDepth(Diver, Depth), Time),
   
    [ holds_at(atDepth(Equipment, Depth), Time),
      holds_at(wearing(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time, Depth])
    ]).

 /*  not(holds_at(atDepth(Equipment, Depth), Time)) :-
       not(holds_at(atDepth(Diver, Depth), Time)),
       holds_at(wearing(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time, Depth]).
 */

 /*  [holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(wearing(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time, Depth])] ->
       ta(Time,
          holds_at(neg(atDepth(Equipment, Depth)), Time)).
 */
axiom(holds_at(neg(atDepth(Equipment, Depth)), Time),
   
    [ holds_at(neg(atDepth(Diver, Depth)), Time),
      holds_at(wearing(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time, Depth])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3474
% [diver,depth,object,time]
% HoldsAt(Holding(diver,object),time) ->
% (HoldsAt(AtDepth(diver,depth),time) <->
%  HoldsAt(AtDepth(object,depth),time)).

 /*  allDifferent([Diver, Object, Time, Depth]) ->
       ( holds_at(holding(Diver, Object), Time)->(holds_at(atDepth(Diver, Depth), Time)<->holds_at(atDepth(Object, Depth), Time))
       ).
 */

 /*  not(holds_at(holding(Diver, Object), Time)) :-
       (   not(holds_at(atDepth(Object, Depth), Time)),
           holds_at(atDepth(Diver, Depth), Time)
       ;   not(holds_at(atDepth(Diver, Depth), Time)),
           holds_at(atDepth(Object, Depth), Time)
       ),
       allDifferent([Diver, Object, Time, Depth]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(atDepth(Object, Depth), Time)),
           holds_at(atDepth(Diver, Depth), Time)
       ;   not(holds_at(atDepth(Diver, Depth), Time)),
           holds_at(atDepth(Object, Depth), Time)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(atDepth(Object, Depth)), Time),
           holds_at(atDepth(Diver, Depth), Time)
       ;   holds_at(neg(atDepth(Diver, Depth)), Time),
           holds_at(atDepth(Object, Depth), Time)
       ).
 */

 /*  [(holds_at(neg(atDepth(Object, Depth)), Time), holds_at(atDepth(Diver, Depth), Time);holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(atDepth(Object, Depth), Time)), allDifferent([Diver, Object, Time, Depth])] ->
       ta(Time, holds_at(neg(holding(Diver, Object)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3477
axiom(holds_at(neg(holding(Diver, Object)), Time),
   
    [  (holds_at(neg(atDepth(Object, Depth)), Time), holds_at(atDepth(Diver, Depth), Time);holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(atDepth(Object, Depth), Time)),
      allDifferent([Diver, Object, Time, Depth])
    ]).

 /*  holds_at(atDepth(Object, Depth), Time) :-
       holds_at(atDepth(Diver, Depth), Time),
       holds_at(holding(Diver, Object), Time),
       allDifferent([Diver, Object, Time, Depth]).
 */

 /*  [holds_at(atDepth(Diver, Depth), Time), holds_at(holding(Diver, Object), Time), allDifferent([Diver, Object, Time, Depth])] ->
       ta(Time, holds_at(atDepth(Object, Depth), Time)).
 */
axiom(holds_at(atDepth(Object, Depth), Time),
   
    [ holds_at(atDepth(Diver, Depth), Time),
      holds_at(holding(Diver, Object), Time),
      allDifferent([Diver, Object, Time, Depth])
    ]).

 /*  not(holds_at(atDepth(Diver, Depth), Time)) :-
       not(holds_at(atDepth(Object, Depth), Time)),
       holds_at(holding(Diver, Object), Time),
       allDifferent([Diver, Object, Time, Depth]).
 */

 /*  [holds_at(neg(atDepth(Object, Depth)), Time), holds_at(holding(Diver, Object), Time), allDifferent([Diver, Object, Time, Depth])] ->
       ta(Time, holds_at(neg(atDepth(Diver, Depth)), Time)).
 */
axiom(holds_at(neg(atDepth(Diver, Depth)), Time),
   
    [ holds_at(neg(atDepth(Object, Depth)), Time),
      holds_at(holding(Diver, Object), Time),
      allDifferent([Diver, Object, Time, Depth])
    ]).

 /*  holds_at(atDepth(Diver, Depth), Time) :-
       holds_at(atDepth(Object, Depth), Time),
       holds_at(holding(Diver, Object), Time),
       allDifferent([Diver, Object, Time, Depth]).
 */

 /*  [holds_at(atDepth(Object, Depth), Time), holds_at(holding(Diver, Object), Time), allDifferent([Diver, Object, Time, Depth])] ->
       ta(Time, holds_at(atDepth(Diver, Depth), Time)).
 */
axiom(holds_at(atDepth(Diver, Depth), Time),
   
    [ holds_at(atDepth(Object, Depth), Time),
      holds_at(holding(Diver, Object), Time),
      allDifferent([Diver, Object, Time, Depth])
    ]).

 /*  not(holds_at(atDepth(Object, Depth), Time)) :-
       not(holds_at(atDepth(Diver, Depth), Time)),
       holds_at(holding(Diver, Object), Time),
       allDifferent([Diver, Object, Time, Depth]).
 */

 /*  [holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(holding(Diver, Object), Time), allDifferent([Diver, Object, Time, Depth])] ->
       ta(Time, holds_at(neg(atDepth(Object, Depth)), Time)).
 */
axiom(holds_at(neg(atDepth(Object, Depth)), Time),
   
    [ holds_at(neg(atDepth(Diver, Depth)), Time),
      holds_at(holding(Diver, Object), Time),
      allDifferent([Diver, Object, Time, Depth])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3479
% [diver,equipment,time]
% HoldsAt(Wearing(diver,equipment),time) ->
% (HoldsAt(UnderWater(diver),time) <->
%  HoldsAt(UnderWater(equipment),time)).

 /*  allDifferent([Diver, Equipment, Time]) ->
       ( holds_at(wearing(Diver, Equipment), Time)->(holds_at(underWater(Diver), Time)<->holds_at(underWater(Equipment), Time))
       ).
 */

 /*  not(holds_at(wearing(Diver, Equipment), Time)) :-
       (   not(holds_at(underWater(Equipment), Time)),
           holds_at(underWater(Diver), Time)
       ;   not(holds_at(underWater(Diver), Time)),
           holds_at(underWater(Equipment), Time)
       ),
       allDifferent([Diver, Equipment, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(underWater(Equipment), Time)),
           holds_at(underWater(Diver), Time)
       ;   not(holds_at(underWater(Diver), Time)),
           holds_at(underWater(Equipment), Time)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(underWater(Equipment)), Time),
           holds_at(underWater(Diver), Time)
       ;   holds_at(neg(underWater(Diver)), Time),
           holds_at(underWater(Equipment), Time)
       ).
 */

 /*  [(holds_at(neg(underWater(Equipment)), Time), holds_at(underWater(Diver), Time);holds_at(neg(underWater(Diver)), Time), holds_at(underWater(Equipment), Time)), allDifferent([Diver, Equipment, Time])] ->
       ta(Time,
          holds_at(neg(wearing(Diver, Equipment)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3482
axiom(holds_at(neg(wearing(Diver, Equipment)), Time),
   
    [  (holds_at(neg(underWater(Equipment)), Time), holds_at(underWater(Diver), Time);holds_at(neg(underWater(Diver)), Time), holds_at(underWater(Equipment), Time)),
      allDifferent([Diver, Equipment, Time])
    ]).

 /*  holds_at(underWater(Equipment), Time) :-
       holds_at(underWater(Diver), Time),
       holds_at(wearing(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time]).
 */

 /*  [holds_at(underWater(Diver), Time), holds_at(wearing(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time])] ->
       ta(Time, holds_at(underWater(Equipment), Time)).
 */
axiom(holds_at(underWater(Equipment), Time),
   
    [ holds_at(underWater(Diver), Time),
      holds_at(wearing(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time])
    ]).

 /*  not(holds_at(underWater(Diver), Time)) :-
       not(holds_at(underWater(Equipment), Time)),
       holds_at(wearing(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time]).
 */

 /*  [holds_at(neg(underWater(Equipment)), Time), holds_at(wearing(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time])] ->
       ta(Time, holds_at(neg(underWater(Diver)), Time)).
 */
axiom(holds_at(neg(underWater(Diver)), Time),
   
    [ holds_at(neg(underWater(Equipment)), Time),
      holds_at(wearing(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time])
    ]).

 /*  holds_at(underWater(Diver), Time) :-
       holds_at(underWater(Equipment), Time),
       holds_at(wearing(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time]).
 */

 /*  [holds_at(underWater(Equipment), Time), holds_at(wearing(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time])] ->
       ta(Time, holds_at(underWater(Diver), Time)).
 */
axiom(holds_at(underWater(Diver), Time),
   
    [ holds_at(underWater(Equipment), Time),
      holds_at(wearing(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time])
    ]).

 /*  not(holds_at(underWater(Equipment), Time)) :-
       not(holds_at(underWater(Diver), Time)),
       holds_at(wearing(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time]).
 */

 /*  [holds_at(neg(underWater(Diver)), Time), holds_at(wearing(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time])] ->
       ta(Time, holds_at(neg(underWater(Equipment)), Time)).
 */
axiom(holds_at(neg(underWater(Equipment)), Time),
   
    [ holds_at(neg(underWater(Diver)), Time),
      holds_at(wearing(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3484
% [diver,object,time]
% HoldsAt(Holding(diver,object),time) ->
% (HoldsAt(UnderWater(diver),time) <->
%  HoldsAt(UnderWater(object),time)).

 /*  allDifferent([Diver, Object, Time]) ->
       ( holds_at(holding(Diver, Object), Time)->(holds_at(underWater(Diver), Time)<->holds_at(underWater(Object), Time))
       ).
 */

 /*  not(holds_at(holding(Diver, Object), Time)) :-
       (   not(holds_at(underWater(Object), Time)),
           holds_at(underWater(Diver), Time)
       ;   not(holds_at(underWater(Diver), Time)),
           holds_at(underWater(Object), Time)
       ),
       allDifferent([Diver, Object, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(underWater(Object), Time)),
           holds_at(underWater(Diver), Time)
       ;   not(holds_at(underWater(Diver), Time)),
           holds_at(underWater(Object), Time)
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(underWater(Object)), Time),
           holds_at(underWater(Diver), Time)
       ;   holds_at(neg(underWater(Diver)), Time),
           holds_at(underWater(Object), Time)
       ).
 */

 /*  [(holds_at(neg(underWater(Object)), Time), holds_at(underWater(Diver), Time);holds_at(neg(underWater(Diver)), Time), holds_at(underWater(Object), Time)), allDifferent([Diver, Object, Time])] ->
       ta(Time, holds_at(neg(holding(Diver, Object)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3487
axiom(holds_at(neg(holding(Diver, Object)), Time),
   
    [  (holds_at(neg(underWater(Object)), Time), holds_at(underWater(Diver), Time);holds_at(neg(underWater(Diver)), Time), holds_at(underWater(Object), Time)),
      allDifferent([Diver, Object, Time])
    ]).

 /*  holds_at(underWater(Object), Time) :-
       holds_at(underWater(Diver), Time),
       holds_at(holding(Diver, Object), Time),
       allDifferent([Diver, Object, Time]).
 */

 /*  [holds_at(underWater(Diver), Time), holds_at(holding(Diver, Object), Time), allDifferent([Diver, Object, Time])] ->
       ta(Time, holds_at(underWater(Object), Time)).
 */
axiom(holds_at(underWater(Object), Time),
   
    [ holds_at(underWater(Diver), Time),
      holds_at(holding(Diver, Object), Time),
      allDifferent([Diver, Object, Time])
    ]).

 /*  not(holds_at(underWater(Diver), Time)) :-
       not(holds_at(underWater(Object), Time)),
       holds_at(holding(Diver, Object), Time),
       allDifferent([Diver, Object, Time]).
 */

 /*  [holds_at(neg(underWater(Object)), Time), holds_at(holding(Diver, Object), Time), allDifferent([Diver, Object, Time])] ->
       ta(Time, holds_at(neg(underWater(Diver)), Time)).
 */
axiom(holds_at(neg(underWater(Diver)), Time),
   
    [ holds_at(neg(underWater(Object)), Time),
      holds_at(holding(Diver, Object), Time),
      allDifferent([Diver, Object, Time])
    ]).

 /*  holds_at(underWater(Diver), Time) :-
       holds_at(underWater(Object), Time),
       holds_at(holding(Diver, Object), Time),
       allDifferent([Diver, Object, Time]).
 */

 /*  [holds_at(underWater(Object), Time), holds_at(holding(Diver, Object), Time), allDifferent([Diver, Object, Time])] ->
       ta(Time, holds_at(underWater(Diver), Time)).
 */
axiom(holds_at(underWater(Diver), Time),
   
    [ holds_at(underWater(Object), Time),
      holds_at(holding(Diver, Object), Time),
      allDifferent([Diver, Object, Time])
    ]).

 /*  not(holds_at(underWater(Object), Time)) :-
       not(holds_at(underWater(Diver), Time)),
       holds_at(holding(Diver, Object), Time),
       allDifferent([Diver, Object, Time]).
 */

 /*  [holds_at(neg(underWater(Diver)), Time), holds_at(holding(Diver, Object), Time), allDifferent([Diver, Object, Time])] ->
       ta(Time, holds_at(neg(underWater(Object)), Time)).
 */
axiom(holds_at(neg(underWater(Object)), Time),
   
    [ holds_at(neg(underWater(Diver)), Time),
      holds_at(holding(Diver, Object), Time),
      allDifferent([Diver, Object, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3489
% [diver,depth,equipment,time]
% HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Wearing(diver,equipment),time) ->
% Initiates(TakeOff(diver,equipment),AtDepth(equipment,depth),time).

 /*  [holds_at(atDepth(Diver, Depth), Time), holds_at(wearing(Diver, Equipment), Time)] ->
       ta(Time,
          initiates(takeOff(Diver, Equipment),
                    atDepth(Equipment, Depth),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3492
axiom(initiates(takeOff(Diver, Equipment), atDepth(Equipment, Depth), Time),
   
    [ holds_at(atDepth(Diver, Depth), Time),
      holds_at(wearing(Diver, Equipment), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3494
% [diver,depth,equipment,time]
% !HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Wearing(diver,equipment),time) ->
% Terminates(TakeOff(diver,equipment),AtDepth(equipment,depth),time).

 /*  [holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(wearing(Diver, Equipment), Time)] ->
       ta(Time,
          terminates(takeOff(Diver, Equipment),
                     atDepth(Equipment, Depth),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3497
axiom(terminates(takeOff(Diver, Equipment), atDepth(Equipment, Depth), Time),
   
    [ holds_at(neg(atDepth(Diver, Depth)), Time),
      holds_at(wearing(Diver, Equipment), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3499
% [diver,equipment,time]
% HoldsAt(UnderWater(diver),time) ->
% Initiates(TakeOff(diver,equipment),UnderWater(equipment),time).

 /*  [holds_at(underWater(Diver), Time)] ->
       ta(Time,
          initiates(takeOff(Diver, Equipment),
                    underWater(Equipment),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3501
axiom(initiates(takeOff(Diver, Equipment), underWater(Equipment), Time),
    [holds_at(underWater(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3503
% [diver,equipment,time]
% !HoldsAt(UnderWater(diver),time) ->
% Terminates(TakeOff(diver,equipment),UnderWater(equipment),time).

 /*  [holds_at(neg(underWater(Diver)), Time)] ->
       ta(Time,
          terminates(takeOff(Diver, Equipment),
                     underWater(Equipment),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3505
axiom(terminates(takeOff(Diver, Equipment), underWater(Equipment), Time),
    [holds_at(neg(underWater(Diver)), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3507
% [diver,equipment,depth,time]
% HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Wearing(diver,equipment),time) ->
% Initiates(Lose(diver,equipment),AtDepth(equipment,depth),time).

 /*  [holds_at(atDepth(Diver, Depth), Time), holds_at(wearing(Diver, Equipment), Time)] ->
       ta(Time,
          initiates(lose(Diver, Equipment),
                    atDepth(Equipment, Depth),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3510
axiom(initiates(lose(Diver, Equipment), atDepth(Equipment, Depth), Time),
   
    [ holds_at(atDepth(Diver, Depth), Time),
      holds_at(wearing(Diver, Equipment), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3512
% [diver,equipment,depth,time]
% !HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Wearing(diver,equipment),time) ->
% Terminates(Lose(diver,equipment),AtDepth(equipment,depth),time).

 /*  [holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(wearing(Diver, Equipment), Time)] ->
       ta(Time,
          terminates(lose(Diver, Equipment),
                     atDepth(Equipment, Depth),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3515
axiom(terminates(lose(Diver, Equipment), atDepth(Equipment, Depth), Time),
   
    [ holds_at(neg(atDepth(Diver, Depth)), Time),
      holds_at(wearing(Diver, Equipment), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3517
% [diver,equipment,time]
% HoldsAt(UnderWater(diver),time) ->
% Initiates(Lose(diver,equipment),UnderWater(equipment),time).

 /*  [holds_at(underWater(Diver), Time)] ->
       ta(Time,
          initiates(lose(Diver, Equipment),
                    underWater(Equipment),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3519
axiom(initiates(lose(Diver, Equipment), underWater(Equipment), Time),
    [holds_at(underWater(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3521
% [diver,equipment,time]
% !HoldsAt(UnderWater(diver),time) ->
% Terminates(Lose(diver,equipment),UnderWater(equipment),time).

 /*  [holds_at(neg(underWater(Diver)), Time)] ->
       ta(Time,
          terminates(lose(Diver, Equipment),
                     underWater(Equipment),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3523
axiom(terminates(lose(Diver, Equipment), underWater(Equipment), Time),
    [holds_at(neg(underWater(Diver)), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3525
% fluent Holding(diver,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3526
fluent(holding(Holding_Param,Holding_Ret)).
==> mpred_prop(holding(diver,object),fluent).
==> meta_argtypes(holding(diver,object)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3527
% [diver1,diver2,time]
% HoldsAt(Holding(diver1,diver2),time) ->
% !HoldsAt(Holding(diver2,diver1),time).

 /*  allDifferent([Diver1, Diver2, Time]) ->
       ( holds_at(holding(Diver1, Diver2), Time)->holds_at(neg(holding(Diver2, Diver1)), Time)
       ).
 */

 /*  holds_at(neg(holding(Diver2, Diver1)), Time) :-
       holds_at(holding(Diver1, Diver2), Time),
       allDifferent([Diver1, Diver2, Time]).
 */

 /*  [holds_at(holding(Diver1, Diver2), Time), allDifferent([Diver1, Diver2, Time])] ->
       ta(Time,
          holds_at(neg(holding(Diver2, Diver1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3529
axiom(holds_at(neg(holding(Diver2, Diver1)), Time),
   
    [ holds_at(holding(Diver1, Diver2), Time),
      allDifferent([Diver1, Diver2, Time])
    ]).

 /*  not(holds_at(holding(Diver1, Diver2), Time)) :-
       not(holds_at(neg(holding(Diver2, Diver1)), Time)),
       allDifferent([Diver1, Diver2, Time]).
 */

 /*  [holds_at(neg(neg(holding(Diver2, Diver1))), Time), allDifferent([Diver1, Diver2, Time])] ->
       ta(Time,
          holds_at(neg(holding(Diver1, Diver2)), Time)).
 */
axiom(holds_at(neg(holding(Diver1, Diver2)), Time),
   
    [ holds_at(neg(neg(holding(Diver2, Diver1))), Time),
      allDifferent([Diver1, Diver2, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3531
% event Grab(diver,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3532
event(grab(Grab_Param,Grab_Ret)).
==> mpred_prop(grab(diver,object),event).
==> meta_argtypes(grab(diver,object)).

% event LetGoOf(diver,object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3534
event(letGoOf(LetGoOf_Param,LetGoOf_Ret)).
==> mpred_prop(letGoOf(diver,object),event).
==> meta_argtypes(letGoOf(diver,object)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3535
% [diver,object,time]
% Initiates(Grab(diver,object),Holding(diver,object),time).

 /*  [] ->
       ta(Time,
          initiates(grab(Diver, Object),
                    holding(Diver, Object),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3536
axiom(initiates(grab(Diver, Object), holding(Diver, Object), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3538
% [diver,object,time]
% Terminates(LetGoOf(diver,object),Holding(diver,object),time).

 /*  [] ->
       ta(Time,
          terminates(letGoOf(Diver, Object),
                     holding(Diver, Object),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3539
axiom(terminates(letGoOf(Diver, Object), holding(Diver, Object), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3541
% [diver,object,depth,time]
% Releases(Grab(diver,object),AtDepth(object,depth),time).

 /*  [] ->
       ta(Time,
          releases(grab(Diver, Object),
                   atDepth(Object, Depth),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3542
axiom(releases(grab(Diver, Object), atDepth(Object, Depth), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3544
% [diver,object,time]
% Releases(Grab(diver,object),UnderWater(object),time).

 /*  [] ->
       ta(Time,
          releases(grab(Diver, Object),
                   underWater(Object),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3545
axiom(releases(grab(Diver, Object), underWater(Object), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3547
% [diver,object,depth,time]
% HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Holding(diver,object),time) ->
% Initiates(LetGoOf(diver,object),AtDepth(object,depth),time).

 /*  [holds_at(atDepth(Diver, Depth), Time), holds_at(holding(Diver, Object), Time)] ->
       ta(Time,
          initiates(letGoOf(Diver, Object),
                    atDepth(Object, Depth),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3550
axiom(initiates(letGoOf(Diver, Object), atDepth(Object, Depth), Time),
   
    [ holds_at(atDepth(Diver, Depth), Time),
      holds_at(holding(Diver, Object), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3552
% [diver,object,depth,time]
% !HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Holding(diver,object),time) ->
% Terminates(LetGoOf(diver,object),AtDepth(object,depth),time).

 /*  [holds_at(neg(atDepth(Diver, Depth)), Time), holds_at(holding(Diver, Object), Time)] ->
       ta(Time,
          terminates(letGoOf(Diver, Object),
                     atDepth(Object, Depth),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3555
axiom(terminates(letGoOf(Diver, Object), atDepth(Object, Depth), Time),
   
    [ holds_at(neg(atDepth(Diver, Depth)), Time),
      holds_at(holding(Diver, Object), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3557
% [diver,object,time]
% HoldsAt(UnderWater(diver),time) ->
% Initiates(LetGoOf(diver,object),UnderWater(object),time).

 /*  [holds_at(underWater(Diver), Time)] ->
       ta(Time,
          initiates(letGoOf(Diver, Object),
                    underWater(Object),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3559
axiom(initiates(letGoOf(Diver, Object), underWater(Object), Time),
    [holds_at(underWater(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3561
% [diver,object,time]
% !HoldsAt(UnderWater(diver),time) ->
% Terminates(LetGoOf(diver,object),UnderWater(object),time).

 /*  [holds_at(neg(underWater(Diver)), Time)] ->
       ta(Time,
          terminates(letGoOf(Diver, Object),
                     underWater(Object),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3563
axiom(terminates(letGoOf(Diver, Object), underWater(Object), Time),
    [holds_at(neg(underWater(Diver)), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3565
% [diver,equipment,time]
% Initiates(PutOn(diver,equipment),Wearing(diver,equipment),time).

 /*  [] ->
       ta(Time,
          initiates(putOn(Diver, Equipment),
                    wearing(Diver, Equipment),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3566
axiom(initiates(putOn(Diver, Equipment), wearing(Diver, Equipment), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3568
% [diver,equipment,time]
% Happens(PutOn(diver,equipment),time) ->
% !HoldsAt(UnderWater(diver),time).

 /*  allDifferent([Diver, Equipment, Time]) ->
       ( happens(putOn(Diver, Equipment), Time)->holds_at(neg(underWater(Diver)), Time)
       ).
 */

 /*  holds_at(neg(underWater(Diver)), Time) :-
       happens(putOn(Diver, Equipment), Time),
       allDifferent([Diver, Equipment, Time]).
 */

 /*  [happens(putOn(Diver, Equipment), Time), allDifferent([Diver, Equipment, Time])] ->
       ta(Time, holds_at(neg(underWater(Diver)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3570
axiom(holds_at(neg(underWater(Diver)), Time),
   
    [ happens(putOn(Diver, Equipment), Time),
      allDifferent([Diver, Equipment, Time])
    ]).

 /*  not(happens(putOn(Diver, Equipment), Time)) :-
       not(holds_at(neg(underWater(Diver)), Time)),
       allDifferent([Diver, Equipment, Time]).
 */

 /*  [holds_at(neg(neg(underWater(Diver))), Time), allDifferent([Diver, Equipment, Time])] ->
       ta(Time, not(happens(putOn(Diver, Equipment), Time))).
 */
axiom(not(happens(putOn(Diver, Equipment), Time)),
   
    [ holds_at(neg(neg(underWater(Diver))), Time),
      allDifferent([Diver, Equipment, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3572
% [diver,equipment,time]
% Terminates(TakeOff(diver,equipment),Wearing(diver,equipment),time).

 /*  [] ->
       ta(Time,
          terminates(takeOff(Diver, Equipment),
                     wearing(Diver, Equipment),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3573
axiom(terminates(takeOff(Diver, Equipment), wearing(Diver, Equipment), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3575
% [diver,equipment,time]
% Terminates(Lose(diver,equipment),Wearing(diver,equipment),time).

 /*  [] ->
       ta(Time,
          terminates(lose(Diver, Equipment),
                     wearing(Diver, Equipment),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3576
axiom(terminates(lose(Diver, Equipment), wearing(Diver, Equipment), Time),
    []).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3578
% fluent Vertical(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3579
fluent(vertical(Vertical_Ret)).
==> mpred_prop(vertical(diver),fluent).
==> meta_argtypes(vertical(diver)).

% fluent HorizontalDown(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3581
fluent(horizontalDown(HorizontalDown_Ret)).
==> mpred_prop(horizontalDown(diver),fluent).
==> meta_argtypes(horizontalDown(diver)).

% fluent Inverted(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3583
fluent(inverted(Inverted_Ret)).
==> mpred_prop(inverted(diver),fluent).
==> meta_argtypes(inverted(diver)).

% fluent HorizontalUp(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3585
fluent(horizontalUp(HorizontalUp_Ret)).
==> mpred_prop(horizontalUp(diver),fluent).
==> meta_argtypes(horizontalUp(diver)).

% xor Vertical, HorizontalDown, Inverted, HorizontalUp
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3587
==> xor([vertical,horizontalDown,inverted,horizontalUp]).

% event RotatePitch(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3589
event(rotatePitch(RotatePitch_Ret)).
==> mpred_prop(rotatePitch(diver),event).
==> meta_argtypes(rotatePitch(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3590
% [diver,time]
% HoldsAt(Vertical(diver),time) ->
% Initiates(RotatePitch(diver),HorizontalDown(diver),time).

 /*  [holds_at(vertical(Diver), Time)] ->
       ta(Time,
          initiates(rotatePitch(Diver),
                    horizontalDown(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3592
axiom(initiates(rotatePitch(Diver), horizontalDown(Diver), Time),
    [holds_at(vertical(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3594
% [diver,time]
% HoldsAt(HorizontalDown(diver),time) ->
% Initiates(RotatePitch(diver),Inverted(diver),time).

 /*  [holds_at(horizontalDown(Diver), Time)] ->
       ta(Time,
          initiates(rotatePitch(Diver), inverted(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3596
axiom(initiates(rotatePitch(Diver), inverted(Diver), Time),
    [holds_at(horizontalDown(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3598
% [diver,time]
% HoldsAt(HorizontalDown(diver),time) ->
% Terminates(RotatePitch(diver),HorizontalDown(diver),time).

 /*  [holds_at(horizontalDown(Diver), Time)] ->
       ta(Time,
          terminates(rotatePitch(Diver),
                     horizontalDown(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3600
axiom(terminates(rotatePitch(Diver), horizontalDown(Diver), Time),
    [holds_at(horizontalDown(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3602
% [diver,time]
% HoldsAt(Inverted(diver),time) ->
% Initiates(RotatePitch(diver),HorizontalUp(diver),time).

 /*  [holds_at(inverted(Diver), Time)] ->
       ta(Time,
          initiates(rotatePitch(Diver),
                    horizontalUp(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3604
axiom(initiates(rotatePitch(Diver), horizontalUp(Diver), Time),
    [holds_at(inverted(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3606
% [diver,time]
% HoldsAt(Inverted(diver),time) ->
% Terminates(RotatePitch(diver),Inverted(diver),time).

 /*  [holds_at(inverted(Diver), Time)] ->
       ta(Time,
          terminates(rotatePitch(Diver), inverted(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3608
axiom(terminates(rotatePitch(Diver), inverted(Diver), Time),
    [holds_at(inverted(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3610
% [diver,time]
% HoldsAt(HorizontalUp(diver),time) ->
% Initiates(RotatePitch(diver),Vertical(diver),time).

 /*  [holds_at(horizontalUp(Diver), Time)] ->
       ta(Time,
          initiates(rotatePitch(Diver), vertical(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3612
axiom(initiates(rotatePitch(Diver), vertical(Diver), Time),
    [holds_at(horizontalUp(Diver), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3614
% [diver,time]
% HoldsAt(HorizontalUp(diver),time) ->
% Terminates(RotatePitch(diver),HorizontalUp(diver),time).

 /*  [holds_at(horizontalUp(Diver), Time)] ->
       ta(Time,
          terminates(rotatePitch(Diver),
                     horizontalUp(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3616
axiom(terminates(rotatePitch(Diver), horizontalUp(Diver), Time),
    [holds_at(horizontalUp(Diver), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3618
% event RotateYaw(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3619
event(rotateYaw(RotateYaw_Ret)).
==> mpred_prop(rotateYaw(diver),event).
==> meta_argtypes(rotateYaw(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3620
%; try taking out Holding condition here
% [diver,time]
% Happens(Ascend1(diver),time) &
% !Happens(RapidAscendToSurface(diver),time) &
% !({diver1} HoldsAt(Holding(diver,diver1),time)) ->
% Happens(RotateYaw(diver),time).

 /*  allDifferent([Diver, Time, Diver1]) ->
       ( happens(ascend1(Diver), Time), not(happens(rapidAscendToSurface(Diver), Time)), not(exists([Diver1], holds_at(holding(Diver, Diver1), Time)))->happens(rotateYaw(Diver), Time)
       ).
 */

 /*  happens(rotateYaw(Diver), Time) :-
       ( happens(ascend1(Diver), Time),
         not(happens(rapidAscendToSurface(Diver), Time)),
         not(holds_at(holding(Diver, Diver1), Time))
       ),
       allDifferent([Diver, Time, Diver1]).
 */

 /*  [happens(ascend1(Diver), Time), not(happens(rapidAscendToSurface(Diver), Time)), holds_at(neg(holding(Diver, Diver1)), Time), allDifferent([Diver, Time, Diver1])] ->
       ta(Time, happens(rotateYaw(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3625
axiom(happens(rotateYaw(Diver), Time),
   
    [ happens(ascend1(Diver), Time),
      not(happens(rapidAscendToSurface(Diver), Time)),
      holds_at(neg(holding(Diver, Diver1)), Time),
      allDifferent([Diver, Time, Diver1])
    ]).

 /*  not(happens(ascend1(Diver), Time)) :-
       ( not(happens(rapidAscendToSurface(Diver), Time)),
         not(holds_at(holding(Diver, Diver1), Time))
       ),
       not(happens(rotateYaw(Diver), Time)),
       allDifferent([Diver, Time, Diver1]).
 */

 /*  [not(happens(rapidAscendToSurface(Diver), Time)), holds_at(neg(holding(Diver, Diver1)), Time), not(happens(rotateYaw(Diver), Time)), allDifferent([Diver, Time, Diver1])] ->
       ta(Time, not(happens(ascend1(Diver), Time))).
 */
axiom(not(happens(ascend1(Diver), Time)),
   
    [ not(happens(rapidAscendToSurface(Diver), Time)),
      holds_at(neg(holding(Diver, Diver1)), Time),
      not(happens(rotateYaw(Diver), Time)),
      allDifferent([Diver, Time, Diver1])
    ]).

 /*  happens(rapidAscendToSurface(Diver), Time) :-
       not(holds_at(holding(Diver, Diver1), Time)),
       happens(ascend1(Diver), Time),
       not(happens(rotateYaw(Diver), Time)),
       allDifferent([Diver, Time, Diver1]).
 */

 /*  [holds_at(neg(holding(Diver, Diver1)), Time), happens(ascend1(Diver), Time), not(happens(rotateYaw(Diver), Time)), allDifferent([Diver, Time, Diver1])] ->
       ta(Time, happens(rapidAscendToSurface(Diver), Time)).
 */
axiom(happens(rapidAscendToSurface(Diver), Time),
   
    [ holds_at(neg(holding(Diver, Diver1)), Time),
      happens(ascend1(Diver), Time),
      not(happens(rotateYaw(Diver), Time)),
      allDifferent([Diver, Time, Diver1])
    ]).

 /*  holds_at(holding(Diver, Diver1), Time) :-
       not(happens(rapidAscendToSurface(Diver), Time)),
       happens(ascend1(Diver), Time),
       not(happens(rotateYaw(Diver), Time)),
       allDifferent([Diver, Time, Diver1]).
 */

 /*  [not(happens(rapidAscendToSurface(Diver), Time)), happens(ascend1(Diver), Time), not(happens(rotateYaw(Diver), Time)), allDifferent([Diver, Time, Diver1])] ->
       ta(Time, holds_at(holding(Diver, Diver1), Time)).
 */
axiom(holds_at(holding(Diver, Diver1), Time),
   
    [ not(happens(rapidAscendToSurface(Diver), Time)),
      happens(ascend1(Diver), Time),
      not(happens(rotateYaw(Diver), Time)),
      allDifferent([Diver, Time, Diver1])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3627
% fluent UnderWater(object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3628
fluent(underWater(UnderWater_Ret)).
==> mpred_prop(underWater(object),fluent).
==> meta_argtypes(underWater(object)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3629
% [object,depth,time]
% depth>% 0 &
% HoldsAt(AtDepth(object,depth),time) ->
% HoldsAt(UnderWater(object),time).

 /*  allDifferent([Depth, Object, Time]) ->
       ( Depth>0, holds_at(atDepth(Object, Depth), Time)->holds_at(underWater(Object), Time)
       ).
 */

 /*  holds_at(underWater(Object), Time) :-
       ( comparison(Depth, 0, >),
         holds_at(atDepth(Object, Depth), Time)
       ),
       allDifferent([Depth, Object, Time]).
 */

 /*  [comparison(Depth, 0, >), holds_at(atDepth(Object, Depth), Time), allDifferent([Depth, Object, Time])] ->
       ta(Time, holds_at(underWater(Object), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3632
axiom(holds_at(underWater(Object), Time),
   
    [ comparison(Depth, 0, >),
      holds_at(atDepth(Object, Depth), Time),
      allDifferent([Depth, Object, Time])
    ]).

 /*  not(holds_at(atDepth(Object, Depth), Time)) :-
       comparison(Depth, 0, >),
       not(holds_at(underWater(Object), Time)),
       allDifferent([Depth, Object, Time]).
 */

 /*  [comparison(Depth, 0, >), holds_at(neg(underWater(Object)), Time), allDifferent([Depth, Object, Time])] ->
       ta(Time, holds_at(neg(atDepth(Object, Depth)), Time)).
 */
axiom(holds_at(neg(atDepth(Object, Depth)), Time),
   
    [ comparison(Depth, 0, >),
      holds_at(neg(underWater(Object)), Time),
      allDifferent([Depth, Object, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3634
% event EnterWater(object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3635
event(enterWater(EnterWater_Ret)).
==> mpred_prop(enterWater(object),event).
==> meta_argtypes(enterWater(object)).

% event Surface(object)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3637
event(surface(Surface_Ret)).
==> mpred_prop(surface(object),event).
==> meta_argtypes(surface(object)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3638
% [object,time]
% Initiates(EnterWater(object),UnderWater(object),time).

 /*  [] ->
       ta(Time,
          initiates(enterWater(Object), underWater(Object), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3639
axiom(initiates(enterWater(Object), underWater(Object), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3641
% [diver,time]
% Happens(EnterWater(diver),time) ->
% !{diver1} HoldsAt(Holding(diver1,diver),time).

 /*  allDifferent([Diver, Time, Diver1]) ->
       ( happens(enterWater(Diver), Time)->not(exists([Diver1], holds_at(holding(Diver1, Diver), Time)))
       ).
 */

 /*  not(holds_at(holding(Diver1, Diver), Time)) :-
       happens(enterWater(Diver), Time),
       allDifferent([Diver, Time, Diver1]).
 */

 /*  [happens(enterWater(Diver), Time), allDifferent([Diver, Time, Diver1])] ->
       ta(Time, holds_at(neg(holding(Diver1, Diver)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3643
axiom(holds_at(neg(holding(Diver1, Diver)), Time),
   
    [ happens(enterWater(Diver), Time),
      allDifferent([Diver, Time, Diver1])
    ]).

 /*  not(happens(enterWater(Diver), Time)) :-
       holds_at(holding(Diver1, Diver), Time),
       allDifferent([Diver, Time, Diver1]).
 */

 /*  [holds_at(holding(Diver1, Diver), Time), allDifferent([Diver, Time, Diver1])] ->
       ta(Time, not(happens(enterWater(Diver), Time))).
 */
axiom(not(happens(enterWater(Diver), Time)),
   
    [ holds_at(holding(Diver1, Diver), Time),
      allDifferent([Diver, Time, Diver1])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3645
% [object,depth,time]
% depth=% 0 ->
% Initiates(EnterWater(object),AtDepth(object,depth),time).

 /*  axiom_head(Time) ->
       equals(Depth, 0).
 */

 /*  fix_axiom_head(Time) ->
       call(Depth=0).
 */

 /*  [call(Depth=0)] ->
       ta(Time,
          initiates(enterWater(Object),
                    atDepth(Object, Depth),
                    Time)).
 */

 /*  [holds_at(call(Depth=0), Time)] ->
       ta(Time,
          initiates(enterWater(Object),
                    atDepth(Object, Depth),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3647
axiom(initiates(enterWater(Object), atDepth(Object, Depth), Time),
    [holds_at(call(Depth=0), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3649
% [object,time]
% Terminates(Surface(object),UnderWater(object),time).

 /*  [] ->
       ta(Time,
          terminates(surface(Object), underWater(Object), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3650
axiom(terminates(surface(Object), underWater(Object), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3652
% [diver,time]
% Terminates(Surface(diver),PositivelyBuoyant(diver),time).

 /*  [] ->
       ta(Time,
          terminates(surface(Diver),
                     positivelyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3653
axiom(terminates(surface(Diver), positivelyBuoyant(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3655
% [diver,time]
% Terminates(Surface(diver),NegativelyBuoyant(diver),time).

 /*  [] ->
       ta(Time,
          terminates(surface(Diver),
                     negativelyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3656
axiom(terminates(surface(Diver), negativelyBuoyant(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3658
% [diver,time]
% Terminates(Surface(diver),NeutrallyBuoyant(diver),time).

 /*  [] ->
       ta(Time,
          terminates(surface(Diver),
                     neutrallyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3659
axiom(terminates(surface(Diver), neutrallyBuoyant(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3661
% [object,depth,time]
% Terminates(Surface(object),AtDepth(object,depth),time).

 /*  [] ->
       ta(Time,
          terminates(surface(Object),
                     atDepth(Object, Depth),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3662
axiom(terminates(surface(Object), atDepth(Object, Depth), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3664
% [diver,time]
 % Happens(EnterWater(diver),time) ->
% HoldsAt(Vertical(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( happens(enterWater(Diver), Time)->holds_at(vertical(Diver), Time)
       ).
 */

 /*  holds_at(vertical(Diver), Time) :-
       happens(enterWater(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [happens(enterWater(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(vertical(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3665
axiom(holds_at(vertical(Diver), Time),
   
    [ happens(enterWater(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(enterWater(Diver), Time)) :-
       not(holds_at(vertical(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(neg(vertical(Diver)), Time), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(enterWater(Diver), Time))).
 */
axiom(not(happens(enterWater(Diver), Time)),
   
    [ holds_at(neg(vertical(Diver)), Time),
      allDifferent([Diver, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3667
% fluent StandingOn(diver,boat)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3668
fluent(standingOn(StandingOn_Param,StandingOn_Ret)).
==> mpred_prop(standingOn(diver,boat),fluent).
==> meta_argtypes(standingOn(diver,boat)).

% event StandOn(diver,boat)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3670
event(standOn(StandOn_Param,StandOn_Ret)).
==> mpred_prop(standOn(diver,boat),event).
==> meta_argtypes(standOn(diver,boat)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3671
% [diver,boat,time]
% Terminates(EnterWater(diver),StandingOn(diver,boat),time).

 /*  [] ->
       ta(Time,
          terminates(enterWater(Diver),
                     standingOn(Diver, Boat),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3672
axiom(terminates(enterWater(Diver), standingOn(Diver, Boat), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3674
% [diver,boat,time]
% Initiates(StandOn(diver,boat),StandingOn(diver,boat),time).

 /*  [] ->
       ta(Time,
          initiates(standOn(Diver, Boat),
                    standingOn(Diver, Boat),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3675
axiom(initiates(standOn(Diver, Boat), standingOn(Diver, Boat), Time),
    []).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3677
% fluent PositivelyBuoyant(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3678
fluent(positivelyBuoyant(PositivelyBuoyant_Ret)).
==> mpred_prop(positivelyBuoyant(diver),fluent).
==> meta_argtypes(positivelyBuoyant(diver)).

% fluent NeutrallyBuoyant(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3680
fluent(neutrallyBuoyant(NeutrallyBuoyant_Ret)).
==> mpred_prop(neutrallyBuoyant(diver),fluent).
==> meta_argtypes(neutrallyBuoyant(diver)).

% fluent NegativelyBuoyant(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3682
fluent(negativelyBuoyant(NegativelyBuoyant_Ret)).
==> mpred_prop(negativelyBuoyant(diver),fluent).
==> meta_argtypes(negativelyBuoyant(diver)).

% mutex PositivelyBuoyant, NeutrallyBuoyant, NegativelyBuoyant
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3684
mutex(positivelyBuoyant).

 /*  axiom_head(Axiom_head_Ret) ->
       mutex(positivelyBuoyant).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(mutex(positivelyBuoyant), Axiom_head_Ret).
 */
mutex(neutrallyBuoyant).

 /*  axiom_head(Axiom_head_Ret1) ->
       mutex(neutrallyBuoyant).
 */

 /*  fix_axiom_head(Axiom_head_Ret1) ->
       holds_at(mutex(neutrallyBuoyant), Axiom_head_Ret1).
 */
mutex(negativelyBuoyant).

 /*  axiom_head(Axiom_head_Ret2) ->
       mutex(negativelyBuoyant).
 */

 /*  fix_axiom_head(Axiom_head_Ret2) ->
       holds_at(mutex(negativelyBuoyant), Axiom_head_Ret2).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3685
% [diver,time]
% HoldsAt(PositivelyBuoyant(diver),time) ->
% HoldsAt(UnderWater(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( holds_at(positivelyBuoyant(Diver), Time)->holds_at(underWater(Diver), Time)
       ).
 */

 /*  holds_at(underWater(Diver), Time) :-
       holds_at(positivelyBuoyant(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(positivelyBuoyant(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(underWater(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3687
axiom(holds_at(underWater(Diver), Time),
   
    [ holds_at(positivelyBuoyant(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(holds_at(positivelyBuoyant(Diver), Time)) :-
       not(holds_at(underWater(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(neg(underWater(Diver)), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(neg(positivelyBuoyant(Diver)), Time)).
 */
axiom(holds_at(neg(positivelyBuoyant(Diver)), Time),
   
    [ holds_at(neg(underWater(Diver)), Time),
      allDifferent([Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3689
% [diver,time]
% HoldsAt(NeutrallyBuoyant(diver),time) ->
% HoldsAt(UnderWater(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( holds_at(neutrallyBuoyant(Diver), Time)->holds_at(underWater(Diver), Time)
       ).
 */

 /*  holds_at(underWater(Diver), Time) :-
       holds_at(neutrallyBuoyant(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(neutrallyBuoyant(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(underWater(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3691
axiom(holds_at(underWater(Diver), Time),
   
    [ holds_at(neutrallyBuoyant(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(holds_at(neutrallyBuoyant(Diver), Time)) :-
       not(holds_at(underWater(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(neg(underWater(Diver)), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(neg(neutrallyBuoyant(Diver)), Time)).
 */
axiom(holds_at(neg(neutrallyBuoyant(Diver)), Time),
   
    [ holds_at(neg(underWater(Diver)), Time),
      allDifferent([Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3693
% [diver,time]
% HoldsAt(NegativelyBuoyant(diver),time) ->
% HoldsAt(UnderWater(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( holds_at(negativelyBuoyant(Diver), Time)->holds_at(underWater(Diver), Time)
       ).
 */

 /*  holds_at(underWater(Diver), Time) :-
       holds_at(negativelyBuoyant(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(negativelyBuoyant(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(underWater(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3695
axiom(holds_at(underWater(Diver), Time),
   
    [ holds_at(negativelyBuoyant(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(holds_at(negativelyBuoyant(Diver), Time)) :-
       not(holds_at(underWater(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(neg(underWater(Diver)), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(neg(negativelyBuoyant(Diver)), Time)).
 */
axiom(holds_at(neg(negativelyBuoyant(Diver)), Time),
   
    [ holds_at(neg(underWater(Diver)), Time),
      allDifferent([Diver, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3697
% event PressDeflateButton(diver,bc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3698
event(pressDeflateButton(PressDeflateButton_Param,
			 PressDeflateButton_Ret)).
==> mpred_prop(pressDeflateButton(diver,bc),event).
==> meta_argtypes(pressDeflateButton(diver,bc)).

% event PressDumpButton(diver,bc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3700
event(pressDumpButton(PressDumpButton_Param,
		      PressDumpButton_Ret)).
==> mpred_prop(pressDumpButton(diver,bc),event).
==> meta_argtypes(pressDumpButton(diver,bc)).

% event PressInflateButton(diver,bc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3702
event(pressInflateButton(PressInflateButton_Param,
			 PressInflateButton_Ret)).
==> mpred_prop(pressInflateButton(diver,bc),event).
==> meta_argtypes(pressInflateButton(diver,bc)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3703
% [diver,bc,time]
% Happens(PressDeflateButton(diver,bc),time) ->
% HoldsAt(Vertical(diver),time) &
% HoldsAt(UnderWater(bc),time).

 /*  allDifferent([Diver, Bc, Time]) ->
       ( happens(pressDeflateButton(Diver, Bc), Time)->holds_at(vertical(Diver), Time), holds_at(underWater(Bc), Time)
       ).
 */

 /*  not(happens(pressDeflateButton(Diver, Bc), Time)) :-
       (   not(holds_at(vertical(Diver), Time))
       ;   not(holds_at(underWater(Bc), Time))
       ),
       allDifferent([Diver, Bc, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(vertical(Diver), Time))
       ;   not(holds_at(underWater(Bc), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(vertical(Diver)), Time)
       ;   holds_at(neg(underWater(Bc)), Time)
       ).
 */

 /*  [(holds_at(neg(vertical(Diver)), Time);holds_at(neg(underWater(Bc)), Time)), allDifferent([Diver, Bc, Time])] ->
       ta(Time,
          not(happens(pressDeflateButton(Diver, Bc), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3706
axiom(not(happens(pressDeflateButton(Diver, Bc), Time)),
   
    [  (holds_at(neg(vertical(Diver)), Time);holds_at(neg(underWater(Bc)), Time)),
      allDifferent([Diver, Bc, Time])
    ]).

 /*  holds_at(vertical(Diver), Time) :-
       happens(pressDeflateButton(Diver, Bc), Time),
       allDifferent([Diver, Bc, Time]).
 */

 /*  [happens(pressDeflateButton(Diver, Bc), Time), allDifferent([Diver, Bc, Time])] ->
       ta(Time, holds_at(vertical(Diver), Time)).
 */
axiom(holds_at(vertical(Diver), Time),
   
    [ happens(pressDeflateButton(Diver, Bc), Time),
      allDifferent([Diver, Bc, Time])
    ]).

 /*  holds_at(underWater(Bc), Time) :-
       happens(pressDeflateButton(Diver, Bc), Time),
       allDifferent([Diver, Bc, Time]).
 */

 /*  [happens(pressDeflateButton(Diver, Bc), Time), allDifferent([Diver, Bc, Time])] ->
       ta(Time, holds_at(underWater(Bc), Time)).
 */
axiom(holds_at(underWater(Bc), Time),
   
    [ happens(pressDeflateButton(Diver, Bc), Time),
      allDifferent([Diver, Bc, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3708
% [diver,bc,time]
% Happens(PressDumpButton(diver,bc),time) ->
% HoldsAt(Vertical(diver),time) &
% HoldsAt(UnderWater(bc),time).

 /*  allDifferent([Diver, Bc, Time]) ->
       ( happens(pressDumpButton(Diver, Bc), Time)->holds_at(vertical(Diver), Time), holds_at(underWater(Bc), Time)
       ).
 */

 /*  not(happens(pressDumpButton(Diver, Bc), Time)) :-
       (   not(holds_at(vertical(Diver), Time))
       ;   not(holds_at(underWater(Bc), Time))
       ),
       allDifferent([Diver, Bc, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(vertical(Diver), Time))
       ;   not(holds_at(underWater(Bc), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(vertical(Diver)), Time)
       ;   holds_at(neg(underWater(Bc)), Time)
       ).
 */

 /*  [(holds_at(neg(vertical(Diver)), Time);holds_at(neg(underWater(Bc)), Time)), allDifferent([Diver, Bc, Time])] ->
       ta(Time,
          not(happens(pressDumpButton(Diver, Bc), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3711
axiom(not(happens(pressDumpButton(Diver, Bc), Time)),
   
    [  (holds_at(neg(vertical(Diver)), Time);holds_at(neg(underWater(Bc)), Time)),
      allDifferent([Diver, Bc, Time])
    ]).

 /*  holds_at(vertical(Diver), Time) :-
       happens(pressDumpButton(Diver, Bc), Time),
       allDifferent([Diver, Bc, Time]).
 */

 /*  [happens(pressDumpButton(Diver, Bc), Time), allDifferent([Diver, Bc, Time])] ->
       ta(Time, holds_at(vertical(Diver), Time)).
 */
axiom(holds_at(vertical(Diver), Time),
   
    [ happens(pressDumpButton(Diver, Bc), Time),
      allDifferent([Diver, Bc, Time])
    ]).

 /*  holds_at(underWater(Bc), Time) :-
       happens(pressDumpButton(Diver, Bc), Time),
       allDifferent([Diver, Bc, Time]).
 */

 /*  [happens(pressDumpButton(Diver, Bc), Time), allDifferent([Diver, Bc, Time])] ->
       ta(Time, holds_at(underWater(Bc), Time)).
 */
axiom(holds_at(underWater(Bc), Time),
   
    [ happens(pressDumpButton(Diver, Bc), Time),
      allDifferent([Diver, Bc, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3713
% [diver,bc,time]
 % Happens(PressDumpButton(diver,bc),time) ->
% HoldsAt(UncontrolledBuoyancy(diver),time).

 /*  allDifferent([Diver, Bc, Time]) ->
       ( happens(pressDumpButton(Diver, Bc), Time)->holds_at(uncontrolledBuoyancy(Diver), Time)
       ).
 */

 /*  holds_at(uncontrolledBuoyancy(Diver), Time) :-
       happens(pressDumpButton(Diver, Bc), Time),
       allDifferent([Diver, Bc, Time]).
 */

 /*  [happens(pressDumpButton(Diver, Bc), Time), allDifferent([Diver, Bc, Time])] ->
       ta(Time, holds_at(uncontrolledBuoyancy(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3714
axiom(holds_at(uncontrolledBuoyancy(Diver), Time),
   
    [ happens(pressDumpButton(Diver, Bc), Time),
      allDifferent([Diver, Bc, Time])
    ]).

 /*  not(happens(pressDumpButton(Diver, Bc), Time)) :-
       not(holds_at(uncontrolledBuoyancy(Diver), Time)),
       allDifferent([Diver, Bc, Time]).
 */

 /*  [holds_at(neg(uncontrolledBuoyancy(Diver)), Time), allDifferent([Diver, Bc, Time])] ->
       ta(Time,
          not(happens(pressDumpButton(Diver, Bc), Time))).
 */
axiom(not(happens(pressDumpButton(Diver, Bc), Time)),
   
    [ holds_at(neg(uncontrolledBuoyancy(Diver)), Time),
      allDifferent([Diver, Bc, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3716
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Initiates(PressDeflateButton(diver,bc),NegativelyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          initiates(pressDeflateButton(Diver, Bc),
                    negativelyBuoyant(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3718
axiom(initiates(pressDeflateButton(Diver, Bc), negativelyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3720
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressDeflateButton(diver,bc),NeutrallyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          terminates(pressDeflateButton(Diver, Bc),
                     neutrallyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3722
axiom(terminates(pressDeflateButton(Diver, Bc), neutrallyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3724
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressDeflateButton(diver,bc),PositivelyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          terminates(pressDeflateButton(Diver, Bc),
                     positivelyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3726
axiom(terminates(pressDeflateButton(Diver, Bc), positivelyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3728
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Initiates(PressDumpButton(diver,bc),NegativelyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          initiates(pressDumpButton(Diver, Bc),
                    negativelyBuoyant(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3730
axiom(initiates(pressDumpButton(Diver, Bc), negativelyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3732
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressDumpButton(diver,bc),NeutrallyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          terminates(pressDumpButton(Diver, Bc),
                     neutrallyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3734
axiom(terminates(pressDumpButton(Diver, Bc), neutrallyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3736
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressDumpButton(diver,bc),PositivelyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          terminates(pressDumpButton(Diver, Bc),
                     positivelyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3738
axiom(terminates(pressDumpButton(Diver, Bc), positivelyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3740
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Initiates(PressInflateButton(diver,bc),NeutrallyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          initiates(pressInflateButton(Diver, Bc),
                    neutrallyBuoyant(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3742
axiom(initiates(pressInflateButton(Diver, Bc), neutrallyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3744
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressInflateButton(diver,bc),PositivelyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          terminates(pressInflateButton(Diver, Bc),
                     positivelyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3746
axiom(terminates(pressInflateButton(Diver, Bc), positivelyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3748
% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressInflateButton(diver,bc),NegativelyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Bc), Time)] ->
       ta(Time,
          terminates(pressInflateButton(Diver, Bc),
                     negativelyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3750
axiom(terminates(pressInflateButton(Diver, Bc), negativelyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Bc), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3752
% [diver,weight,time]
% HoldsAt(Wearing(diver,weight),time) ->
% Initiates(TakeOff(diver,weight),PositivelyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Weight), Time)] ->
       ta(Time,
          initiates(takeOff(Diver, Weight),
                    positivelyBuoyant(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3754
axiom(initiates(takeOff(Diver, Weight), positivelyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Weight), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3756
% [diver,weight,time]
% HoldsAt(Wearing(diver,weight),time) ->
% Terminates(TakeOff(diver,weight),NegativelyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Weight), Time)] ->
       ta(Time,
          terminates(takeOff(Diver, Weight),
                     negativelyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3758
axiom(terminates(takeOff(Diver, Weight), negativelyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Weight), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3760
% [diver,weight,time]
% HoldsAt(Wearing(diver,weight),time) ->
% Terminates(TakeOff(diver,weight),NeutrallyBuoyant(diver),time).

 /*  [holds_at(wearing(Diver, Weight), Time)] ->
       ta(Time,
          terminates(takeOff(Diver, Weight),
                     neutrallyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3762
axiom(terminates(takeOff(Diver, Weight), neutrallyBuoyant(Diver), Time),
    [holds_at(wearing(Diver, Weight), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3764
% fluent UncontrolledBuoyancy(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3765
fluent(uncontrolledBuoyancy(UncontrolledBuoyancy_Ret)).
==> mpred_prop(uncontrolledBuoyancy(diver),fluent).
==> meta_argtypes(uncontrolledBuoyancy(diver)).

% event LoseBuoyancyControl(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3767
event(loseBuoyancyControl(LoseBuoyancyControl_Ret)).
==> mpred_prop(loseBuoyancyControl(diver),event).
==> meta_argtypes(loseBuoyancyControl(diver)).

% predicate IsInexperiencedDiver(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3769
predicate(isInexperiencedDiver(IsInexperiencedDiver_Ret)).
==> mpred_prop(isInexperiencedDiver(diver),predicate).
==> meta_argtypes(isInexperiencedDiver(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3770
% [diver,time]
% Happens(LoseBuoyancyControl(diver),time) ->
% IsInexperiencedDiver(diver).

 /*  allDifferent([Diver, Time]) ->
       ( happens(loseBuoyancyControl(Diver), Time)->isInexperiencedDiver(Diver)
       ).
 */

 /*  isInexperiencedDiver(Diver) :-
       happens(loseBuoyancyControl(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [happens(loseBuoyancyControl(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, isInexperiencedDiver(Diver)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3772
axiom(isInexperiencedDiver(Diver),
   
    [ happens(loseBuoyancyControl(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(loseBuoyancyControl(Diver), Time)) :-
       not(isInexperiencedDiver(Diver)),
       allDifferent([Diver, Time]).
 */

 /*  [not(isInexperiencedDiver(Diver)), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(loseBuoyancyControl(Diver), Time))).
 */
axiom(not(happens(loseBuoyancyControl(Diver), Time)),
   
    [ not(isInexperiencedDiver(Diver)),
      allDifferent([Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3774
% [diver,time]
% Initiates(LoseBuoyancyControl(diver),UncontrolledBuoyancy(diver),time).

 /*  [] ->
       ta(Time,
          initiates(loseBuoyancyControl(Diver),
                    uncontrolledBuoyancy(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3775
axiom(initiates(loseBuoyancyControl(Diver), uncontrolledBuoyancy(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3777
% [diver,time]
% Initiates(LoseBuoyancyControl(diver),PositivelyBuoyant(diver),time).

 /*  [] ->
       ta(Time,
          initiates(loseBuoyancyControl(Diver),
                    positivelyBuoyant(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3778
axiom(initiates(loseBuoyancyControl(Diver), positivelyBuoyant(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3780
% [diver,time]
% Terminates(LoseBuoyancyControl(diver),NegativelyBuoyant(diver),time).

 /*  [] ->
       ta(Time,
          terminates(loseBuoyancyControl(Diver),
                     negativelyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3781
axiom(terminates(loseBuoyancyControl(Diver), negativelyBuoyant(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3783
% [diver,time]
% Terminates(LoseBuoyancyControl(diver),NeutrallyBuoyant(diver),time).

 /*  [] ->
       ta(Time,
          terminates(loseBuoyancyControl(Diver),
                     neutrallyBuoyant(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3784
axiom(terminates(loseBuoyancyControl(Diver), neutrallyBuoyant(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3786
%; determining fluent

% fluent AscendDescendAmount(diver,depth)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3788
fluent(ascendDescendAmount(AscendDescendAmount_Param,
			   AscendDescendAmount_Ret)).
==> mpred_prop(ascendDescendAmount(diver,depth),fluent).
==> meta_argtypes(ascendDescendAmount(diver,depth)).

% noninertial AscendDescendAmount
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3789
==> noninertial(ascendDescendAmount).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3790
% [diver,depth1,depth2,time]
% HoldsAt(AscendDescendAmount(diver,depth1),time) &
% HoldsAt(AscendDescendAmount(diver,depth2),time) ->
% depth1=depth2.

 /*  allDifferent([Diver, Depth1, Time, Depth2]) ->
       ( holds_at(ascendDescendAmount(Diver, Depth1), Time), holds_at(ascendDescendAmount(Diver, Depth2), Time)->Depth1=Depth2
       ).
 */

 /*  not(holds_at(ascendDescendAmount(Diver, Depth1), Time)) :-
       holds_at(ascendDescendAmount(Diver, Depth2), Time),
       not(equals(Depth1, Depth2)),
       allDifferent([Diver, Depth1, Time, Depth2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Depth1, Depth2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Depth1=Depth2)).
 */

 /*  [holds_at(ascendDescendAmount(Diver, Depth2), Time), not(call(Depth1=Depth2)), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time,
          holds_at(neg(ascendDescendAmount(Diver, Depth1)), Time)).
 */

 /*  [holds_at(ascendDescendAmount(Diver, Depth2), Time), holds_at(neg(call(Depth1=Depth2)), Time), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time,
          holds_at(neg(ascendDescendAmount(Diver, Depth1)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3793
axiom(holds_at(neg(ascendDescendAmount(Diver, Depth1)), Time),
   
    [ holds_at(ascendDescendAmount(Diver, Depth2), Time),
      holds_at(neg(call(Depth1=Depth2)), Time),
      allDifferent([Diver, Depth1, Time, Depth2])
    ]).

 /*  not(holds_at(ascendDescendAmount(Diver, Depth2), Time)) :-
       holds_at(ascendDescendAmount(Diver, Depth1), Time),
       not(equals(Depth1, Depth2)),
       allDifferent([Diver, Depth1, Time, Depth2]).
 */

 /*  axiom_head(Time) ->
       not(equals(Depth1, Depth2)).
 */

 /*  fix_axiom_head(Time) ->
       not(call(Depth1=Depth2)).
 */

 /*  [holds_at(ascendDescendAmount(Diver, Depth1), Time), not(call(Depth1=Depth2)), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time,
          holds_at(neg(ascendDescendAmount(Diver, Depth2)), Time)).
 */

 /*  [holds_at(ascendDescendAmount(Diver, Depth1), Time), holds_at(neg(call(Depth1=Depth2)), Time), allDifferent([Diver, Depth1, Time, Depth2])] ->
       ta(Time,
          holds_at(neg(ascendDescendAmount(Diver, Depth2)), Time)).
 */
axiom(holds_at(neg(ascendDescendAmount(Diver, Depth2)), Time),
   
    [ holds_at(ascendDescendAmount(Diver, Depth1), Time),
      holds_at(neg(call(Depth1=Depth2)), Time),
      allDifferent([Diver, Depth1, Time, Depth2])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3795
% [diver,depth,time]
% Happens(Descend(diver,depth),time) ->
% HoldsAt(NegativelyBuoyant(diver),time) &
% ({depth1}
%  HoldsAt(AscendDescendAmount(diver,depth1),time) &
%  HoldsAt(AtDepth(diver,depth-depth1),time)).

 /*  allDifferent([Diver, Depth, Time, Depth1]) ->
       ( happens(descend(Diver, Depth), Time)->holds_at(negativelyBuoyant(Diver), Time), exists([Depth1],  (holds_at(ascendDescendAmount(Diver, Depth1), Time), holds_at(atDepth(Diver, Depth-Depth1), Time)))
       ).
 */

 /*  not(happens(descend(Diver, Depth), Time)) :-
       (   not(holds_at(negativelyBuoyant(Diver), Time))
       ;   not(holds_at(ascendDescendAmount(Diver, Depth1), Time))
       ;   not(holds_at(atDepth(Diver, Depth-Depth1),
                        Time))
       ),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(negativelyBuoyant(Diver), Time))
       ;   not(holds_at(ascendDescendAmount(Diver, Depth1), Time))
       ;   not(holds_at(atDepth(Diver, Depth-Depth1),
                        Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(negativelyBuoyant(Diver)), Time)
       ;   holds_at(neg(ascendDescendAmount(Diver, Depth1)),
                    Time)
       ;   holds_at(neg(atDepth(Diver, Depth-Depth1)),
                    Time)
       ).
 */

 /*  [(holds_at(neg(negativelyBuoyant(Diver)), Time);holds_at(neg(ascendDescendAmount(Diver, Depth1)), Time);holds_at(neg(atDepth(Diver, Depth-Depth1)), Time)), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time, not(happens(descend(Diver, Depth), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3800
axiom(not(happens(descend(Diver, Depth), Time)),
   
    [  (holds_at(neg(negativelyBuoyant(Diver)), Time);holds_at(neg(ascendDescendAmount(Diver, Depth1)), Time);holds_at(neg(atDepth(Diver, Depth-Depth1)), Time)),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

 /*  holds_at(negativelyBuoyant(Diver), Time) :-
       happens(descend(Diver, Depth), Time),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  [happens(descend(Diver, Depth), Time), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time, holds_at(negativelyBuoyant(Diver), Time)).
 */
axiom(holds_at(negativelyBuoyant(Diver), Time),
   
    [ happens(descend(Diver, Depth), Time),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

 /*  holds_at(ascendDescendAmount(Diver, Depth1), Time) :-
       happens(descend(Diver, Depth), Time),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  [happens(descend(Diver, Depth), Time), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time,
          holds_at(ascendDescendAmount(Diver, Depth1), Time)).
 */
axiom(holds_at(ascendDescendAmount(Diver, Depth1), Time),
   
    [ happens(descend(Diver, Depth), Time),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

 /*  holds_at(atDepth(Diver, Depth-Depth1), Time) :-
       happens(descend(Diver, Depth), Time),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  [happens(descend(Diver, Depth), Time), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time,
          holds_at(atDepth(Diver, Depth-Depth1), Time)).
 */
axiom(holds_at(atDepth(Diver, Depth-Depth1), Time),
   
    [ happens(descend(Diver, Depth), Time),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3802
% event KickUp(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3803
event(kickUp(KickUp_Ret)).
==> mpred_prop(kickUp(diver),event).
==> meta_argtypes(kickUp(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3804
% [diver,depth,time]
% Happens(Ascend(diver,depth),time) ->
% (HoldsAt(PositivelyBuoyant(diver),time) |
%  (HoldsAt(NeutrallyBuoyant(diver),time) & Happens(KickUp(diver),time))) &
% ({depth1}
%  HoldsAt(AscendDescendAmount(diver,depth1),time) &
%  HoldsAt(AtDepth(diver,depth+depth1),time)).

 /*  allDifferent([Diver, Depth, Time, Depth1]) ->
       ( happens(ascend(Diver, Depth), Time)->(holds_at(positivelyBuoyant(Diver), Time);holds_at(neutrallyBuoyant(Diver), Time), happens(kickUp(Diver), Time)), exists([Depth1],  (holds_at(ascendDescendAmount(Diver, Depth1), Time), holds_at(atDepth(Diver, Depth+Depth1), Time)))
       ).
 */

 /*  not(happens(ascend(Diver, Depth), Time)) :-
       (   not(holds_at(positivelyBuoyant(Diver), Time)),
           (   not(holds_at(neutrallyBuoyant(Diver), Time))
           ;   not(happens(kickUp(Diver), Time))
           )
       ;   not(holds_at(ascendDescendAmount(Diver, Depth1), Time))
       ;   not(holds_at(atDepth(Diver, Depth+Depth1),
                        Time))
       ),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(positivelyBuoyant(Diver), Time)),
           (   not(holds_at(neutrallyBuoyant(Diver), Time))
           ;   not(happens(kickUp(Diver), Time))
           )
       ;   not(holds_at(ascendDescendAmount(Diver, Depth1), Time))
       ;   not(holds_at(atDepth(Diver, Depth+Depth1),
                        Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(positivelyBuoyant(Diver)), Time),
           (   holds_at(neg(neutrallyBuoyant(Diver)), Time)
           ;   not(happens(kickUp(Diver), Time))
           )
       ;   holds_at(neg(ascendDescendAmount(Diver, Depth1)),
                    Time)
       ;   holds_at(neg(atDepth(Diver, Depth+Depth1)),
                    Time)
       ).
 */

 /*  [(holds_at(neg(positivelyBuoyant(Diver)), Time), (holds_at(neg(neutrallyBuoyant(Diver)), Time);not(happens(kickUp(Diver), Time)));holds_at(neg(ascendDescendAmount(Diver, Depth1)), Time);holds_at(neg(atDepth(Diver, Depth+Depth1)), Time)), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time, not(happens(ascend(Diver, Depth), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3810
axiom(not(happens(ascend(Diver, Depth), Time)),
   
    [  (holds_at(neg(positivelyBuoyant(Diver)), Time), (holds_at(neg(neutrallyBuoyant(Diver)), Time);not(happens(kickUp(Diver), Time)));holds_at(neg(ascendDescendAmount(Diver, Depth1)), Time);holds_at(neg(atDepth(Diver, Depth+Depth1)), Time)),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

 /*  holds_at(positivelyBuoyant(Diver), Time) :-
       (   not(holds_at(neutrallyBuoyant(Diver), Time))
       ;   not(happens(kickUp(Diver), Time))
       ),
       happens(ascend(Diver, Depth), Time),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(neutrallyBuoyant(Diver), Time))
       ;   not(happens(kickUp(Diver), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(neutrallyBuoyant(Diver)), Time)
       ;   not(happens(kickUp(Diver), Time))
       ).
 */

 /*  [(holds_at(neg(neutrallyBuoyant(Diver)), Time);not(happens(kickUp(Diver), Time))), happens(ascend(Diver, Depth), Time), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time, holds_at(positivelyBuoyant(Diver), Time)).
 */
axiom(holds_at(positivelyBuoyant(Diver), Time),
   
    [  (holds_at(neg(neutrallyBuoyant(Diver)), Time);not(happens(kickUp(Diver), Time))),
      happens(ascend(Diver, Depth), Time),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

 /*  holds_at(neutrallyBuoyant(Diver), Time) :-
       not(holds_at(positivelyBuoyant(Diver), Time)),
       happens(ascend(Diver, Depth), Time),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  [holds_at(neg(positivelyBuoyant(Diver)), Time), happens(ascend(Diver, Depth), Time), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time, holds_at(neutrallyBuoyant(Diver), Time)).
 */
axiom(holds_at(neutrallyBuoyant(Diver), Time),
   
    [ holds_at(neg(positivelyBuoyant(Diver)), Time),
      happens(ascend(Diver, Depth), Time),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

 /*  happens(kickUp(Diver), Time) :-
       not(holds_at(positivelyBuoyant(Diver), Time)),
       happens(ascend(Diver, Depth), Time),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  [holds_at(neg(positivelyBuoyant(Diver)), Time), happens(ascend(Diver, Depth), Time), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time, happens(kickUp(Diver), Time)).
 */
axiom(happens(kickUp(Diver), Time),
   
    [ holds_at(neg(positivelyBuoyant(Diver)), Time),
      happens(ascend(Diver, Depth), Time),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

 /*  holds_at(ascendDescendAmount(Diver, Depth1), Time) :-
       happens(ascend(Diver, Depth), Time),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  [happens(ascend(Diver, Depth), Time), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time,
          holds_at(ascendDescendAmount(Diver, Depth1), Time)).
 */
axiom(holds_at(ascendDescendAmount(Diver, Depth1), Time),
   
    [ happens(ascend(Diver, Depth), Time),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).

 /*  holds_at(atDepth(Diver, Depth+Depth1), Time) :-
       happens(ascend(Diver, Depth), Time),
       allDifferent([Diver, Depth, Time, Depth1]).
 */

 /*  [happens(ascend(Diver, Depth), Time), allDifferent([Diver, Depth, Time, Depth1])] ->
       ta(Time,
          holds_at(atDepth(Diver, Depth+Depth1), Time)).
 */
axiom(holds_at(atDepth(Diver, Depth+Depth1), Time),
   
    [ happens(ascend(Diver, Depth), Time),
      allDifferent([Diver, Depth, Time, Depth1])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3812
% [diver,time]
% Happens(KickUp(diver),time) ->
% HoldsAt(Vertical(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( happens(kickUp(Diver), Time)->holds_at(vertical(Diver), Time)
       ).
 */

 /*  holds_at(vertical(Diver), Time) :-
       happens(kickUp(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [happens(kickUp(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(vertical(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3814
axiom(holds_at(vertical(Diver), Time),
   
    [ happens(kickUp(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(kickUp(Diver), Time)) :-
       not(holds_at(vertical(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(neg(vertical(Diver)), Time), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(kickUp(Diver), Time))).
 */
axiom(not(happens(kickUp(Diver), Time)),
   
    [ holds_at(neg(vertical(Diver)), Time),
      allDifferent([Diver, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3816
% event SwimAround(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3817
event(swimAround(SwimAround_Ret)).
==> mpred_prop(swimAround(diver),event).
==> meta_argtypes(swimAround(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3818
% [diver,time]
% Happens(SwimAround(diver),time) ->
% HoldsAt(HorizontalDown(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( happens(swimAround(Diver), Time)->holds_at(horizontalDown(Diver), Time)
       ).
 */

 /*  holds_at(horizontalDown(Diver), Time) :-
       happens(swimAround(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [happens(swimAround(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(horizontalDown(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3820
axiom(holds_at(horizontalDown(Diver), Time),
   
    [ happens(swimAround(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(swimAround(Diver), Time)) :-
       not(holds_at(horizontalDown(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(neg(horizontalDown(Diver)), Time), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(swimAround(Diver), Time))).
 */
axiom(not(happens(swimAround(Diver), Time)),
   
    [ holds_at(neg(horizontalDown(Diver)), Time),
      allDifferent([Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3822
%; signaling

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3824
% event SignalDescend(diver,diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3825
event(signalDescend(SignalDescend_Param,SignalDescend_Ret)).
==> mpred_prop(signalDescend(diver,diver),event).
==> meta_argtypes(signalDescend(diver,diver)).

% event SignalOutOfTime(diver,diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3827
event(signalOutOfTime(SignalOutOfTime_Param,
		      SignalOutOfTime_Ret)).
==> mpred_prop(signalOutOfTime(diver,diver),event).
==> meta_argtypes(signalOutOfTime(diver,diver)).

% event SignalAscend(diver,diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3829
event(signalAscend(SignalAscend_Param,SignalAscend_Ret)).
==> mpred_prop(signalAscend(diver,diver),event).
==> meta_argtypes(signalAscend(diver,diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3830
%;[diver1,diver2,time]
%;Happens(SignalAscend(diver1,diver2),time) ->
%;Happens(SignalOutOfTime(diver1,diver2),time-1).
%;[diver1,diver2,time]
%;Happens(SignalDescend(diver1,diver2),time) ->
%;HoldsAt(See(diver1,diver2),time) &
%;HoldsAt(See(diver2,diver1),time).
%;[diver1,diver2,time]
%;Happens(SignalOutOfTime(diver1,diver2),time) ->
%;HoldsAt(See(diver1,diver2),time) &
%;HoldsAt(See(diver2,diver1),time).
%;[diver1,diver2,time]
%;Happens(SignalAscend(diver1,diver2),time) ->
%;HoldsAt(See(diver1,diver2),time) &
%;HoldsAt(See(diver2,diver1),time).
%;event LookAt(agent,object)
%;fluent See(agent,object)
%;[agent,object,time]
%;Initiates(LookAt(agent,object),See(agent,object),time).
%;[agent,object1,object2,time]
%;object1!=object2 ->
%;Terminates(LookAt(agent,object1),
%;           See(agent,object2),
%;           time).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3862
% event Descend1(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3863
event(descend1(Descend1_Ret)).
==> mpred_prop(descend1(diver),event).
==> meta_argtypes(descend1(diver)).

% event Ascend1(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3865
event(ascend1(Ascend1_Ret)).
==> mpred_prop(ascend1(diver),event).
==> meta_argtypes(ascend1(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3866
%;[diver,object,time]
%;Terminates(Descend1(diver),See(diver,object),time).
%;[diver,object,time]
%;Terminates(Ascend1(diver),See(diver,object),time).
%;[diver,object,time]
%;Terminates(RotateYaw(diver),See(diver,object),time).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3875
% event RapidAscendToSurface(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3876
event(rapidAscendToSurface(RapidAscendToSurface_Ret)).
==> mpred_prop(rapidAscendToSurface(diver),event).
==> meta_argtypes(rapidAscendToSurface(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3877
% [diver,time]
% Happens(Descend1(diver),time) <->
% ({depth} Happens(Descend(diver,depth),time)).

 /*  happens(descend1(Diver), Time) <->
       exists([Depth], happens(descend(Diver, Depth), Time)).
 */

 /*  [happens, descend1] <->
       [exists, happens, descend].
 */

 /*  allDifferent([Diver, Time, Depth]) ->
       ( happens(descend1(Diver), Time)->exists([Depth], happens(descend(Diver, Depth), Time))
       ).
 */

 /*  happens(descend(Diver, Depth), Time) :-
       happens(descend1(Diver), Time),
       allDifferent([Diver, Time, Depth]).
 */

 /*  [happens(descend1(Diver), Time), allDifferent([Diver, Time, Depth])] ->
       ta(Time, happens(descend(Diver, Depth), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3879
axiom(happens(descend(Diver, Depth), Time),
   
    [ happens(descend1(Diver), Time),
      allDifferent([Diver, Time, Depth])
    ]).

 /*  not(happens(descend1(Diver), Time)) :-
       not(happens(descend(Diver, Depth), Time)),
       allDifferent([Diver, Time, Depth]).
 */

 /*  [not(happens(descend(Diver, Depth), Time)), allDifferent([Diver, Time, Depth])] ->
       ta(Time, not(happens(descend1(Diver), Time))).
 */
axiom(not(happens(descend1(Diver), Time)),
   
    [ not(happens(descend(Diver, Depth), Time)),
      allDifferent([Diver, Time, Depth])
    ]).

 /*  allDifferent([Depth, Diver, Time]) ->
       ( exists([Depth], happens(descend(Diver, Depth), Time))->happens(descend1(Diver), Time)
       ).
 */

 /*  happens(descend1(Diver), Time) :-
       happens(descend(Diver, Depth), Time),
       allDifferent([Depth, Diver, Time]).
 */

 /*  [happens(descend(Diver, Depth), Time), allDifferent([Depth, Diver, Time])] ->
       ta(Time, happens(descend1(Diver), Time)).
 */
axiom(happens(descend1(Diver), Time),
   
    [ happens(descend(Diver, Depth), Time),
      allDifferent([Depth, Diver, Time])
    ]).

 /*  not(happens(descend(Diver, Depth), Time)) :-
       not(happens(descend1(Diver), Time)),
       allDifferent([Depth, Diver, Time]).
 */

 /*  [not(happens(descend1(Diver), Time)), allDifferent([Depth, Diver, Time])] ->
       ta(Time, not(happens(descend(Diver, Depth), Time))).
 */
axiom(not(happens(descend(Diver, Depth), Time)),
   
    [ not(happens(descend1(Diver), Time)),
      allDifferent([Depth, Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3881
% [diver,time]
% Happens(Ascend1(diver),time) <->
% ({depth} Happens(Ascend(diver,depth),time)).

 /*  happens(ascend1(Diver), Time) <->
       exists([Depth], happens(ascend(Diver, Depth), Time)).
 */

 /*  [happens, ascend1] <->
       [exists, happens, ascend].
 */

 /*  allDifferent([Diver, Time, Depth]) ->
       ( happens(ascend1(Diver), Time)->exists([Depth], happens(ascend(Diver, Depth), Time))
       ).
 */

 /*  happens(ascend(Diver, Depth), Time) :-
       happens(ascend1(Diver), Time),
       allDifferent([Diver, Time, Depth]).
 */

 /*  [happens(ascend1(Diver), Time), allDifferent([Diver, Time, Depth])] ->
       ta(Time, happens(ascend(Diver, Depth), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3883
axiom(happens(ascend(Diver, Depth), Time),
   
    [ happens(ascend1(Diver), Time),
      allDifferent([Diver, Time, Depth])
    ]).

 /*  not(happens(ascend1(Diver), Time)) :-
       not(happens(ascend(Diver, Depth), Time)),
       allDifferent([Diver, Time, Depth]).
 */

 /*  [not(happens(ascend(Diver, Depth), Time)), allDifferent([Diver, Time, Depth])] ->
       ta(Time, not(happens(ascend1(Diver), Time))).
 */
axiom(not(happens(ascend1(Diver), Time)),
   
    [ not(happens(ascend(Diver, Depth), Time)),
      allDifferent([Diver, Time, Depth])
    ]).

 /*  allDifferent([Depth, Diver, Time]) ->
       ( exists([Depth], happens(ascend(Diver, Depth), Time))->happens(ascend1(Diver), Time)
       ).
 */

 /*  happens(ascend1(Diver), Time) :-
       happens(ascend(Diver, Depth), Time),
       allDifferent([Depth, Diver, Time]).
 */

 /*  [happens(ascend(Diver, Depth), Time), allDifferent([Depth, Diver, Time])] ->
       ta(Time, happens(ascend1(Diver), Time)).
 */
axiom(happens(ascend1(Diver), Time),
   
    [ happens(ascend(Diver, Depth), Time),
      allDifferent([Depth, Diver, Time])
    ]).

 /*  not(happens(ascend(Diver, Depth), Time)) :-
       not(happens(ascend1(Diver), Time)),
       allDifferent([Depth, Diver, Time]).
 */

 /*  [not(happens(ascend1(Diver), Time)), allDifferent([Depth, Diver, Time])] ->
       ta(Time, not(happens(ascend(Diver, Depth), Time))).
 */
axiom(not(happens(ascend(Diver, Depth), Time)),
   
    [ not(happens(ascend1(Diver), Time)),
      allDifferent([Depth, Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3885
% [diver,time]
% Happens(RapidAscendToSurface(diver),time) ->
% Happens(Ascend(diver,0),time).

 /*  allDifferent([Diver, Time]) ->
       ( happens(rapidAscendToSurface(Diver), Time)->happens(ascend(Diver, 0), Time)
       ).
 */

 /*  happens(ascend(Diver, 0), Time) :-
       happens(rapidAscendToSurface(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [happens(rapidAscendToSurface(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, happens(ascend(Diver, 0), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3887
axiom(happens(ascend(Diver, 0), Time),
   
    [ happens(rapidAscendToSurface(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(rapidAscendToSurface(Diver), Time)) :-
       not(happens(ascend(Diver, 0), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [not(happens(ascend(Diver, 0), Time)), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(rapidAscendToSurface(Diver), Time))).
 */
axiom(not(happens(rapidAscendToSurface(Diver), Time)),
   
    [ not(happens(ascend(Diver, 0), Time)),
      allDifferent([Diver, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3889
% event AscendLine(diver,line)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3890
event(ascendLine(AscendLine_Param,AscendLine_Ret)).
==> mpred_prop(ascendLine(diver,line),event).
==> meta_argtypes(ascendLine(diver,line)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3891
% [diver,line,time]
% Happens(AscendLine(diver,line),time) ->
% Happens(Ascend1(diver),time).

 /*  allDifferent([Diver, Line, Time]) ->
       ( happens(ascendLine(Diver, Line), Time)->happens(ascend1(Diver), Time)
       ).
 */

 /*  happens(ascend1(Diver), Time) :-
       happens(ascendLine(Diver, Line), Time),
       allDifferent([Diver, Line, Time]).
 */

 /*  [happens(ascendLine(Diver, Line), Time), allDifferent([Diver, Line, Time])] ->
       ta(Time, happens(ascend1(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3893
axiom(happens(ascend1(Diver), Time),
   
    [ happens(ascendLine(Diver, Line), Time),
      allDifferent([Diver, Line, Time])
    ]).

 /*  not(happens(ascendLine(Diver, Line), Time)) :-
       not(happens(ascend1(Diver), Time)),
       allDifferent([Diver, Line, Time]).
 */

 /*  [not(happens(ascend1(Diver), Time)), allDifferent([Diver, Line, Time])] ->
       ta(Time, not(happens(ascendLine(Diver, Line), Time))).
 */
axiom(not(happens(ascendLine(Diver, Line), Time)),
   
    [ not(happens(ascend1(Diver), Time)),
      allDifferent([Diver, Line, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3895
% fluent Disoriented(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3896
fluent(disoriented(Disoriented_Ret)).
==> mpred_prop(disoriented(diver),fluent).
==> meta_argtypes(disoriented(diver)).

% event BecomeDisoriented(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3898
event(becomeDisoriented(BecomeDisoriented_Ret)).
==> mpred_prop(becomeDisoriented(diver),event).
==> meta_argtypes(becomeDisoriented(diver)).

% event BecomeReoriented(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3900
event(becomeReoriented(BecomeReoriented_Ret)).
==> mpred_prop(becomeReoriented(diver),event).
==> meta_argtypes(becomeReoriented(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3901
% [diver,time]
% Initiates(BecomeDisoriented(diver),Disoriented(diver),time).

 /*  [] ->
       ta(Time,
          initiates(becomeDisoriented(Diver),
                    disoriented(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3902
axiom(initiates(becomeDisoriented(Diver), disoriented(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3904
% [diver,time]
% Terminates(BecomeReoriented(diver),Disoriented(diver),time).

 /*  [] ->
       ta(Time,
          terminates(becomeReoriented(Diver),
                     disoriented(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3905
axiom(terminates(becomeReoriented(Diver), disoriented(Diver), Time),
    []).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3907
% fluent DisturbedSilt()
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3908
fluent(disturbedSilt).
==> mpred_prop(disturbedSilt,fluent).

% event DisturbSilt(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3910
event(disturbSilt(DisturbSilt_Ret)).
==> mpred_prop(disturbSilt(diver),event).
==> meta_argtypes(disturbSilt(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3911
% [diver,time]
% Initiates(DisturbSilt(diver),DisturbedSilt(),time).

 /*  [] ->
       ta(Time,
          initiates(disturbSilt(Diver), disturbedSilt, Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3912
axiom(initiates(disturbSilt(Diver), disturbedSilt, Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3914
% [diver,time]
% Happens(BecomeDisoriented(diver),time) ->
% (!HoldsAt(DisturbedSilt(),time-1) &
%  HoldsAt(DisturbedSilt(),time)).

 /*  allDifferent([Diver, Time]) ->
       ( happens(becomeDisoriented(Diver), Time)->holds_at(neg(disturbedSilt), Time-1), holds_at(disturbedSilt, Time)
       ).
 */

 /*  not(happens(becomeDisoriented(Diver), Time)) :-
       (   not(holds_at(neg(disturbedSilt), Time-1))
       ;   not(holds_at(disturbedSilt, Time))
       ),
       allDifferent([Diver, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(neg(disturbedSilt), Time-1))
       ;   not(holds_at(disturbedSilt, Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(neg(disturbedSilt)), Time-1)
       ;   holds_at(neg(disturbedSilt), Time)
       ).
 */

 /*  [ignore(Time-1==Time2), b(Time2, Time),  (holds_at(neg(neg(disturbedSilt)), Time2);holds_at(neg(disturbedSilt), Time)), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(becomeDisoriented(Diver), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3917
axiom(not(happens(becomeDisoriented(Diver), Time)),
   
    [ b(Time2, Time),
       (holds_at(neg(neg(disturbedSilt)), Time2);holds_at(neg(disturbedSilt), Time)),
      allDifferent([Diver, Time])
    ]).

 /*  holds_at(neg(disturbedSilt), Time-1) :-
       happens(becomeDisoriented(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [happens(becomeDisoriented(Diver), Time), allDifferent([Diver, Time]), b(Time3, Time), ignore(Time-1==Time3)] ->
       ta(Time, holds_at(neg(disturbedSilt), Time3)).
 */
axiom(holds_at(neg(disturbedSilt), Time3),
   
    [ happens(becomeDisoriented(Diver), Time),
      allDifferent([Diver, Time]),
      b(Time3, Time)
    ]).

 /*  holds_at(disturbedSilt, Time) :-
       happens(becomeDisoriented(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [happens(becomeDisoriented(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(disturbedSilt, Time)).
 */
axiom(holds_at(disturbedSilt, Time),
   
    [ happens(becomeDisoriented(Diver), Time),
      allDifferent([Diver, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3919
% event Panic(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3920
event(panic(Panic_Ret)).
==> mpred_prop(panic(diver),event).
==> meta_argtypes(panic(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3921
% [diver,time]
 % Happens(Panic(diver),time) ->
% HoldsAt(Disoriented(diver),time) |
% HoldsAt(UncontrolledBuoyancy(diver),time) |
% ({equipment} Happens(Lose(diver,equipment),time-1)) |
% Happens(Vomit(diver),time-1).

 /*  allDifferent([Diver, Time, Equipment]) ->
       ( happens(panic(Diver), Time)->holds_at(disoriented(Diver), Time);holds_at(uncontrolledBuoyancy(Diver), Time);exists([Equipment], happens(lose(Diver, Equipment), Time-1));happens(vomit(Diver), Time-1)
       ).
 */

 /*  holds_at(disoriented(Diver), Time) :-
       ( not(holds_at(uncontrolledBuoyancy(Diver), Time)),
         not(happens(lose(Diver, Equipment), Time-1)),
         not(happens(vomit(Diver), Time-1))
       ),
       happens(panic(Diver), Time),
       allDifferent([Diver, Time, Equipment]).
 */

 /*  [holds_at(neg(uncontrolledBuoyancy(Diver)), Time), not(happens(lose(Diver, Equipment), Maptime)), not(happens(vomit(Diver), Maptime)), happens(panic(Diver), Time), allDifferent([Diver, Time, Equipment]), b(Maptime, Time), ignore(Time-1==Maptime)] ->
       ta(Time, holds_at(disoriented(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3925
axiom(holds_at(disoriented(Diver), Time),
   
    [ holds_at(neg(uncontrolledBuoyancy(Diver)), Time),
      not(happens(lose(Diver, Equipment), Maptime)),
      not(happens(vomit(Diver), Maptime)),
      happens(panic(Diver), Time),
      allDifferent([Diver, Time, Equipment]),
      b(Maptime, Time)
    ]).

 /*  holds_at(uncontrolledBuoyancy(Diver), Time) :-
       ( not(happens(lose(Diver, Equipment), Time-1)),
         not(happens(vomit(Diver), Time-1))
       ),
       not(holds_at(disoriented(Diver), Time)),
       happens(panic(Diver), Time),
       allDifferent([Diver, Time, Equipment]).
 */

 /*  [not(happens(lose(Diver, Equipment), Maptime4)), not(happens(vomit(Diver), Maptime4)), holds_at(neg(disoriented(Diver)), Time), happens(panic(Diver), Time), allDifferent([Diver, Time, Equipment]), b(Maptime4, Time), ignore(Time-1==Maptime4)] ->
       ta(Time, holds_at(uncontrolledBuoyancy(Diver), Time)).
 */
axiom(holds_at(uncontrolledBuoyancy(Diver), Time),
   
    [ not(happens(lose(Diver, Equipment), Maptime4)),
      not(happens(vomit(Diver), Maptime4)),
      holds_at(neg(disoriented(Diver)), Time),
      happens(panic(Diver), Time),
      allDifferent([Diver, Time, Equipment]),
      b(Maptime4, Time)
    ]).

 /*  happens(lose(Diver, Equipment), Time-1) :-
       not(happens(vomit(Diver), Time-1)),
       not(holds_at(uncontrolledBuoyancy(Diver), Time)),
       not(holds_at(disoriented(Diver), Time)),
       happens(panic(Diver), Time),
       allDifferent([Diver, Time, Equipment]).
 */

 /*  [not(happens(vomit(Diver), Maptime5)), holds_at(neg(uncontrolledBuoyancy(Diver)), Time), holds_at(neg(disoriented(Diver)), Time), happens(panic(Diver), Time), allDifferent([Diver, Time, Equipment]), b(Maptime5, Time), ignore(Time-1==Maptime5)] ->
       ta(Time, happens(lose(Diver, Equipment), Maptime5)).
 */
axiom(happens(lose(Diver, Equipment), Maptime5),
   
    [ not(happens(vomit(Diver), Maptime5)),
      holds_at(neg(uncontrolledBuoyancy(Diver)), Time),
      holds_at(neg(disoriented(Diver)), Time),
      happens(panic(Diver), Time),
      allDifferent([Diver, Time, Equipment]),
      b(Maptime5, Time)
    ]).

 /*  happens(vomit(Diver), Time-1) :-
       not(happens(lose(Diver, Equipment), Time-1)),
       not(holds_at(uncontrolledBuoyancy(Diver), Time)),
       not(holds_at(disoriented(Diver), Time)),
       happens(panic(Diver), Time),
       allDifferent([Diver, Time, Equipment]).
 */

 /*  [not(happens(lose(Diver, Equipment), Maptime6)), holds_at(neg(uncontrolledBuoyancy(Diver)), Time), holds_at(neg(disoriented(Diver)), Time), happens(panic(Diver), Time), allDifferent([Diver, Time, Equipment]), b(Maptime6, Time), ignore(Time-1==Maptime6)] ->
       ta(Time, happens(vomit(Diver), Maptime6)).
 */
axiom(happens(vomit(Diver), Maptime6),
   
    [ not(happens(lose(Diver, Equipment), Maptime6)),
      holds_at(neg(uncontrolledBuoyancy(Diver)), Time),
      holds_at(neg(disoriented(Diver)), Time),
      happens(panic(Diver), Time),
      allDifferent([Diver, Time, Equipment]),
      b(Maptime6, Time)
    ]).

 /*  not(happens(panic(Diver), Time)) :-
       ( not(holds_at(disoriented(Diver), Time)),
         not(holds_at(uncontrolledBuoyancy(Diver), Time)),
         not(happens(lose(Diver, Equipment), Time-1)),
         not(happens(vomit(Diver), Time-1))
       ),
       allDifferent([Diver, Time, Equipment]).
 */

 /*  [holds_at(neg(disoriented(Diver)), Time), holds_at(neg(uncontrolledBuoyancy(Diver)), Time), not(happens(lose(Diver, Equipment), Maptime7)), not(happens(vomit(Diver), Maptime7)), allDifferent([Diver, Time, Equipment]), b(Maptime7, Time), ignore(Time-1==Maptime7)] ->
       ta(Time, not(happens(panic(Diver), Time))).
 */
axiom(not(happens(panic(Diver), Time)),
   
    [ holds_at(neg(disoriented(Diver)), Time),
      holds_at(neg(uncontrolledBuoyancy(Diver)), Time),
      not(happens(lose(Diver, Equipment), Maptime7)),
      not(happens(vomit(Diver), Maptime7)),
      allDifferent([Diver, Time, Equipment]),
      b(Maptime7, Time)
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3927
% event Vomit(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3928
event(vomit(Vomit_Ret)).
==> mpred_prop(vomit(diver),event).
==> meta_argtypes(vomit(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3929
%; conditions

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3931
% fluent Unconscious(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3932
fluent(unconscious(Unconscious_Ret)).
==> mpred_prop(unconscious(diver),fluent).
==> meta_argtypes(unconscious(diver)).

% event GoUnconscious(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3934
event(goUnconscious(GoUnconscious_Ret)).
==> mpred_prop(goUnconscious(diver),event).
==> meta_argtypes(goUnconscious(diver)).

% event RegainConsciousness(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3936
event(regainConsciousness(RegainConsciousness_Ret)).
==> mpred_prop(regainConsciousness(diver),event).
==> meta_argtypes(regainConsciousness(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3937
% [diver,time]
% Initiates(GoUnconscious(diver),Unconscious(diver),time).

 /*  [] ->
       ta(Time,
          initiates(goUnconscious(Diver),
                    unconscious(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3938
axiom(initiates(goUnconscious(Diver), unconscious(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3940
% [diver,time]
% Terminates(RegainConsciousness(diver),Unconscious(diver),time).

 /*  [] ->
       ta(Time,
          terminates(regainConsciousness(Diver),
                     unconscious(Diver),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3941
axiom(terminates(regainConsciousness(Diver), unconscious(Diver), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3943
% [diver,time]
% Happens(GoUnconscious(diver),time) ->
% Happens(RapidAscendToSurface(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( happens(goUnconscious(Diver), Time)->happens(rapidAscendToSurface(Diver), Time)
       ).
 */

 /*  happens(rapidAscendToSurface(Diver), Time) :-
       happens(goUnconscious(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [happens(goUnconscious(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, happens(rapidAscendToSurface(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3945
axiom(happens(rapidAscendToSurface(Diver), Time),
   
    [ happens(goUnconscious(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(goUnconscious(Diver), Time)) :-
       not(happens(rapidAscendToSurface(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [not(happens(rapidAscendToSurface(Diver), Time)), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(goUnconscious(Diver), Time))).
 */
axiom(not(happens(goUnconscious(Diver), Time)),
   
    [ not(happens(rapidAscendToSurface(Diver), Time)),
      allDifferent([Diver, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3947
% fluent HasEarPain(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3948
fluent(hasEarPain(HasEarPain_Ret)).
==> mpred_prop(hasEarPain(diver),fluent).
==> meta_argtypes(hasEarPain(diver)).

% event StartEarPain(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3950
event(startEarPain(StartEarPain_Ret)).
==> mpred_prop(startEarPain(diver),event).
==> meta_argtypes(startEarPain(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3951
% [diver,time]
 % Initiates(StartEarPain(diver),HasEarPain(diver),time).

 /*  [] ->
       ta(Time,
          initiates(startEarPain(Diver), hasEarPain(Diver), Time)).
 */
axiom(initiates(startEarPain(Diver), hasEarPain(Diver), Time),
    []).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3953
% fluent HasRupturedEardrum(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3954
fluent(hasRupturedEardrum(HasRupturedEardrum_Ret)).
==> mpred_prop(hasRupturedEardrum(diver),fluent).
==> meta_argtypes(hasRupturedEardrum(diver)).

% event RuptureEardrum(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3956
event(ruptureEardrum(RuptureEardrum_Ret)).
==> mpred_prop(ruptureEardrum(diver),event).
==> meta_argtypes(ruptureEardrum(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3957
% [diver,time]
% Initiates(RuptureEardrum(diver),HasRupturedEardrum(diver),time).

 /*  [] ->
       ta(Time,
          initiates(ruptureEardrum(Diver),
                    hasRupturedEardrum(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3958
axiom(initiates(ruptureEardrum(Diver), hasRupturedEardrum(Diver), Time),
    []).

% fluent ConditionOK(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3960
fluent(conditionOK(ConditionOK_Ret)).
==> mpred_prop(conditionOK(diver),fluent).
==> meta_argtypes(conditionOK(diver)).

% fluent HasDecompressionIllness(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3962
fluent(hasDecompressionIllness(HasDecompressionIllness_Ret)).
==> mpred_prop(hasDecompressionIllness(diver),fluent).
==> meta_argtypes(hasDecompressionIllness(diver)).

% event StartDecompressionIllness(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3964
event(startDecompressionIllness(StartDecompressionIllness_Ret)).
==> mpred_prop(startDecompressionIllness(diver),event).
==> meta_argtypes(startDecompressionIllness(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3965
% [diver,time]
% Initiates(StartDecompressionIllness(diver),
%           HasDecompressionIllness(diver),
%           time).

 /*  [] ->
       ta(Time,
          initiates(startDecompressionIllness(Diver),
                    hasDecompressionIllness(Diver),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3968
axiom(initiates(startDecompressionIllness(Diver), hasDecompressionIllness(Diver), Time),
    []).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3970
% fluent SignalingDecompress(computer,diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3971
fluent(signalingDecompress(SignalingDecompress_Param,
			   SignalingDecompress_Ret)).
==> mpred_prop(signalingDecompress(computer,diver),fluent).
==> meta_argtypes(signalingDecompress(computer,diver)).

% fluent SignalingLowOnAir(computer,airtank,diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3973
fluent(signalingLowOnAir(SignalingLowOnAir_Param,
			 _,
			 SignalingLowOnAir_Ret)).
==> mpred_prop(signalingLowOnAir(computer,airtank,diver),fluent).
==> meta_argtypes(signalingLowOnAir(computer,airtank,diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3974
% [computer,airtank,diver,time]
% HoldsAt(SignalingLowOnAir(computer,airtank,diver),time) ->
% HoldsAt(LowOnAir(airtank),time).

 /*  allDifferent([Computer, Airtank, Diver, Time]) ->
       ( holds_at(signalingLowOnAir(Computer, Airtank, Diver), Time)->holds_at(lowOnAir(Airtank), Time)
       ).
 */

 /*  holds_at(lowOnAir(Airtank), Time) :-
       holds_at(signalingLowOnAir(Computer, Airtank, Diver),
                Time),
       allDifferent([Computer, Airtank, Diver, Time]).
 */

 /*  [holds_at(signalingLowOnAir(Computer, Airtank, Diver), Time), allDifferent([Computer, Airtank, Diver, Time])] ->
       ta(Time, holds_at(lowOnAir(Airtank), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3976
axiom(holds_at(lowOnAir(Airtank), Time),
   
    [ holds_at(signalingLowOnAir(Computer, Airtank, Diver),
               Time),
      allDifferent([Computer, Airtank, Diver, Time])
    ]).

 /*  not(holds_at(signalingLowOnAir(Computer, Airtank, Diver), Time)) :-
       not(holds_at(lowOnAir(Airtank), Time)),
       allDifferent([Computer, Airtank, Diver, Time]).
 */

 /*  [holds_at(neg(lowOnAir(Airtank)), Time), allDifferent([Computer, Airtank, Diver, Time])] ->
       ta(Time,
          holds_at(neg(signalingLowOnAir(Computer,
                                         Airtank,
                                         Diver)),
                   Time)).
 */
axiom(holds_at(neg(signalingLowOnAir(Computer, Airtank, Diver)), Time),
   
    [ holds_at(neg(lowOnAir(Airtank)), Time),
      allDifferent([Computer, Airtank, Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3978
% [computer,diver,time]
% HoldsAt(SignalingDecompress(computer,diver),time) ->
% !{time1} time1<time & Happens(Decompress(diver),time1).

 /*  allDifferent([Computer, Diver, Time, Time1]) ->
       ( holds_at(signalingDecompress(Computer, Diver), Time)->not(exists([Time1],  (Time1<Time, happens(decompress(Diver), Time1))))
       ).
 */

 /*  not(happens(decompress(Diver), Time1)) :-
       comparison(Time1, Time, <),
       holds_at(signalingDecompress(Computer, Diver), Time),
       allDifferent([Computer, Diver, Time, Time1]).
 */

 /*  [comparison(Time1, Time, <), holds_at(signalingDecompress(Computer, Diver), Time), allDifferent([Computer, Diver, Time, Time1])] ->
       ta(Time1, not(happens(decompress(Diver), Time1))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3980
axiom(not(happens(decompress(Diver), Time1)),
   
    [ comparison(Time1, Time, <),
      holds_at(signalingDecompress(Computer, Diver), Time),
      allDifferent([Computer, Diver, Time, Time1])
    ]).

 /*  not(holds_at(signalingDecompress(Computer, Diver), Time)) :-
       ( comparison(Time1, Time, <),
         happens(decompress(Diver), Time1)
       ),
       allDifferent([Computer, Diver, Time, Time1]).
 */

 /*  [comparison(Time1, Time, <), happens(decompress(Diver), Time1), allDifferent([Computer, Diver, Time, Time1])] ->
       ta(Time,
          holds_at(neg(signalingDecompress(Computer, Diver)),
                   Time)).
 */
axiom(holds_at(neg(signalingDecompress(Computer, Diver)), Time),
   
    [ comparison(Time1, Time, <),
      happens(decompress(Diver), Time1),
      allDifferent([Computer, Diver, Time, Time1])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3982
% event Decompress(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3983
event(decompress(Decompress_Ret)).
==> mpred_prop(decompress(diver),event).
==> meta_argtypes(decompress(diver)).

% event EqualizeEars(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3985
event(equalizeEars(EqualizeEars_Ret)).
==> mpred_prop(equalizeEars(diver),event).
==> meta_argtypes(equalizeEars(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3986
% [diver,time]
% (Happens(Descend1(diver),time) | Happens(Ascend1(diver),time)) &
% !Happens(EqualizeEars(diver),time) ->
% Happens(StartEarPain(diver),time) &
% Happens(RuptureEardrum(diver),time).

 /*  allDifferent([Diver, Time]) ->
       (  (happens(descend1(Diver), Time);happens(ascend1(Diver), Time)), not(happens(equalizeEars(Diver), Time))->happens(startEarPain(Diver), Time), happens(ruptureEardrum(Diver), Time)
       ).
 */

 /*  happens(startEarPain(Diver), Time) :-
       ( not(happens(equalizeEars(Diver), Time)),
         (   happens(descend1(Diver), Time)
         ;   happens(ascend1(Diver), Time)
         )
       ),
       allDifferent([Diver, Time]).
 */

 /*  [not(happens(equalizeEars(Diver), Time)),  (happens(descend1(Diver), Time);happens(ascend1(Diver), Time)), allDifferent([Diver, Time])] ->
       ta(Time, happens(startEarPain(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3990
axiom(happens(startEarPain(Diver), Time),
   
    [ not(happens(equalizeEars(Diver), Time)),
       (happens(descend1(Diver), Time);happens(ascend1(Diver), Time)),
      allDifferent([Diver, Time])
    ]).

 /*  happens(ruptureEardrum(Diver), Time) :-
       ( not(happens(equalizeEars(Diver), Time)),
         (   happens(descend1(Diver), Time)
         ;   happens(ascend1(Diver), Time)
         )
       ),
       allDifferent([Diver, Time]).
 */

 /*  [not(happens(equalizeEars(Diver), Time)),  (happens(descend1(Diver), Time);happens(ascend1(Diver), Time)), allDifferent([Diver, Time])] ->
       ta(Time, happens(ruptureEardrum(Diver), Time)).
 */
axiom(happens(ruptureEardrum(Diver), Time),
   
    [ not(happens(equalizeEars(Diver), Time)),
       (happens(descend1(Diver), Time);happens(ascend1(Diver), Time)),
      allDifferent([Diver, Time])
    ]).

 /*  happens(equalizeEars(Diver), Time) :-
       (   happens(descend1(Diver), Time)
       ;   happens(ascend1(Diver), Time)
       ),
       (   not(happens(startEarPain(Diver), Time))
       ;   not(happens(ruptureEardrum(Diver), Time))
       ),
       allDifferent([Diver, Time]).
 */

 /*  [(happens(descend1(Diver), Time);happens(ascend1(Diver), Time)),  (not(happens(startEarPain(Diver), Time));not(happens(ruptureEardrum(Diver), Time))), allDifferent([Diver, Time])] ->
       ta(Time, happens(equalizeEars(Diver), Time)).
 */
axiom(happens(equalizeEars(Diver), Time),
   
    [  (happens(descend1(Diver), Time);happens(ascend1(Diver), Time)),
       (not(happens(startEarPain(Diver), Time));not(happens(ruptureEardrum(Diver), Time))),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(descend1(Diver), Time)) :-
       not(happens(equalizeEars(Diver), Time)),
       (   not(happens(startEarPain(Diver), Time))
       ;   not(happens(ruptureEardrum(Diver), Time))
       ),
       allDifferent([Diver, Time]).
 */

 /*  [not(happens(equalizeEars(Diver), Time)),  (not(happens(startEarPain(Diver), Time));not(happens(ruptureEardrum(Diver), Time))), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(descend1(Diver), Time))).
 */
axiom(not(happens(descend1(Diver), Time)),
   
    [ not(happens(equalizeEars(Diver), Time)),
       (not(happens(startEarPain(Diver), Time));not(happens(ruptureEardrum(Diver), Time))),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(ascend1(Diver), Time)) :-
       not(happens(equalizeEars(Diver), Time)),
       (   not(happens(startEarPain(Diver), Time))
       ;   not(happens(ruptureEardrum(Diver), Time))
       ),
       allDifferent([Diver, Time]).
 */

 /*  [not(happens(equalizeEars(Diver), Time)),  (not(happens(startEarPain(Diver), Time));not(happens(ruptureEardrum(Diver), Time))), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(ascend1(Diver), Time))).
 */
axiom(not(happens(ascend1(Diver), Time)),
   
    [ not(happens(equalizeEars(Diver), Time)),
       (not(happens(startEarPain(Diver), Time));not(happens(ruptureEardrum(Diver), Time))),
      allDifferent([Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3992
% [diver,time]
% Happens(Ascend1(diver),time) &
% !Happens(Decompress(diver),time) ->
% Happens(StartDecompressionIllness(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( happens(ascend1(Diver), Time), not(happens(decompress(Diver), Time))->happens(startDecompressionIllness(Diver), Time)
       ).
 */

 /*  happens(startDecompressionIllness(Diver), Time) :-
       ( happens(ascend1(Diver), Time),
         not(happens(decompress(Diver), Time))
       ),
       allDifferent([Diver, Time]).
 */

 /*  [happens(ascend1(Diver), Time), not(happens(decompress(Diver), Time)), allDifferent([Diver, Time])] ->
       ta(Time, happens(startDecompressionIllness(Diver), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3995
axiom(happens(startDecompressionIllness(Diver), Time),
   
    [ happens(ascend1(Diver), Time),
      not(happens(decompress(Diver), Time)),
      allDifferent([Diver, Time])
    ]).

 /*  not(happens(ascend1(Diver), Time)) :-
       not(happens(decompress(Diver), Time)),
       not(happens(startDecompressionIllness(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [not(happens(decompress(Diver), Time)), not(happens(startDecompressionIllness(Diver), Time)), allDifferent([Diver, Time])] ->
       ta(Time, not(happens(ascend1(Diver), Time))).
 */
axiom(not(happens(ascend1(Diver), Time)),
   
    [ not(happens(decompress(Diver), Time)),
      not(happens(startDecompressionIllness(Diver), Time)),
      allDifferent([Diver, Time])
    ]).

 /*  happens(decompress(Diver), Time) :-
       happens(ascend1(Diver), Time),
       not(happens(startDecompressionIllness(Diver), Time)),
       allDifferent([Diver, Time]).
 */

 /*  [happens(ascend1(Diver), Time), not(happens(startDecompressionIllness(Diver), Time)), allDifferent([Diver, Time])] ->
       ta(Time, happens(decompress(Diver), Time)).
 */
axiom(happens(decompress(Diver), Time),
   
    [ happens(ascend1(Diver), Time),
      not(happens(startDecompressionIllness(Diver), Time)),
      allDifferent([Diver, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:3997
% [diver1,diver2,time]
% HoldsAt(Holding(diver1,diver2),time) &
% Happens(Ascend1(diver1),time) &
% !Happens(Decompress(diver2),time) ->
% Happens(StartDecompressionIllness(diver2),time).

 /*  allDifferent([Diver1, Diver2, Time]) ->
       ( holds_at(holding(Diver1, Diver2), Time), happens(ascend1(Diver1), Time), not(happens(decompress(Diver2), Time))->happens(startDecompressionIllness(Diver2), Time)
       ).
 */

 /*  happens(startDecompressionIllness(Diver2), Time) :-
       ( holds_at(holding(Diver1, Diver2), Time),
         happens(ascend1(Diver1), Time),
         not(happens(decompress(Diver2), Time))
       ),
       allDifferent([Diver1, Diver2, Time]).
 */

 /*  [holds_at(holding(Diver1, Diver2), Time), happens(ascend1(Diver1), Time), not(happens(decompress(Diver2), Time)), allDifferent([Diver1, Diver2, Time])] ->
       ta(Time, happens(startDecompressionIllness(Diver2), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4001
axiom(happens(startDecompressionIllness(Diver2), Time),
   
    [ holds_at(holding(Diver1, Diver2), Time),
      happens(ascend1(Diver1), Time),
      not(happens(decompress(Diver2), Time)),
      allDifferent([Diver1, Diver2, Time])
    ]).

 /*  not(holds_at(holding(Diver1, Diver2), Time)) :-
       ( happens(ascend1(Diver1), Time),
         not(happens(decompress(Diver2), Time))
       ),
       not(happens(startDecompressionIllness(Diver2), Time)),
       allDifferent([Diver1, Diver2, Time]).
 */

 /*  [happens(ascend1(Diver1), Time), not(happens(decompress(Diver2), Time)), not(happens(startDecompressionIllness(Diver2), Time)), allDifferent([Diver1, Diver2, Time])] ->
       ta(Time,
          holds_at(neg(holding(Diver1, Diver2)), Time)).
 */
axiom(holds_at(neg(holding(Diver1, Diver2)), Time),
   
    [ happens(ascend1(Diver1), Time),
      not(happens(decompress(Diver2), Time)),
      not(happens(startDecompressionIllness(Diver2), Time)),
      allDifferent([Diver1, Diver2, Time])
    ]).

 /*  not(happens(ascend1(Diver1), Time)) :-
       not(happens(decompress(Diver2), Time)),
       holds_at(holding(Diver1, Diver2), Time),
       not(happens(startDecompressionIllness(Diver2), Time)),
       allDifferent([Diver1, Diver2, Time]).
 */

 /*  [not(happens(decompress(Diver2), Time)), holds_at(holding(Diver1, Diver2), Time), not(happens(startDecompressionIllness(Diver2), Time)), allDifferent([Diver1, Diver2, Time])] ->
       ta(Time, not(happens(ascend1(Diver1), Time))).
 */
axiom(not(happens(ascend1(Diver1), Time)),
   
    [ not(happens(decompress(Diver2), Time)),
      holds_at(holding(Diver1, Diver2), Time),
      not(happens(startDecompressionIllness(Diver2), Time)),
      allDifferent([Diver1, Diver2, Time])
    ]).

 /*  happens(decompress(Diver2), Time) :-
       happens(ascend1(Diver1), Time),
       holds_at(holding(Diver1, Diver2), Time),
       not(happens(startDecompressionIllness(Diver2), Time)),
       allDifferent([Diver1, Diver2, Time]).
 */

 /*  [happens(ascend1(Diver1), Time), holds_at(holding(Diver1, Diver2), Time), not(happens(startDecompressionIllness(Diver2), Time)), allDifferent([Diver1, Diver2, Time])] ->
       ta(Time, happens(decompress(Diver2), Time)).
 */
axiom(happens(decompress(Diver2), Time),
   
    [ happens(ascend1(Diver1), Time),
      holds_at(holding(Diver1, Diver2), Time),
      not(happens(startDecompressionIllness(Diver2), Time)),
      allDifferent([Diver1, Diver2, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4003
% [diver,time]
% Happens(Decompress(diver),time) ->
% ({depth} depth>0 & HoldsAt(AtDepth(diver,depth),time)) &
% !HoldsAt(UncontrolledBuoyancy(diver),time).

 /*  allDifferent([Diver, Time, Depth]) ->
       ( happens(decompress(Diver), Time)->exists([Depth],  (Depth>0, holds_at(atDepth(Diver, Depth), Time))), holds_at(neg(uncontrolledBuoyancy(Diver)), Time)
       ).
 */

 /*  not(happens(decompress(Diver), Time)) :-
       (   not(holds_at(neg(uncontrolledBuoyancy(Diver)), Time))
       ;   not(comparison(Depth, 0, >))
       ;   not(holds_at(atDepth(Diver, Depth), Time))
       ),
       allDifferent([Diver, Time, Depth]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(neg(uncontrolledBuoyancy(Diver)), Time))
       ;   not(comparison(Depth, 0, >))
       ;   not(holds_at(atDepth(Diver, Depth), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(neg(uncontrolledBuoyancy(Diver))), Time)
       ;   not(comparison(Depth, 0, >))
       ;   holds_at(neg(atDepth(Diver, Depth)), Time)
       ).
 */

 /*  [(holds_at(neg(neg(uncontrolledBuoyancy(Diver))), Time);not(comparison(Depth, 0, >));holds_at(neg(atDepth(Diver, Depth)), Time)), allDifferent([Diver, Time, Depth])] ->
       ta(Time, not(happens(decompress(Diver), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4006
axiom(not(happens(decompress(Diver), Time)),
   
    [  (holds_at(neg(neg(uncontrolledBuoyancy(Diver))), Time);not(comparison(Depth, 0, >));holds_at(neg(atDepth(Diver, Depth)), Time)),
      allDifferent([Diver, Time, Depth])
    ]).

 /*  holds_at(neg(uncontrolledBuoyancy(Diver)), Time) :-
       happens(decompress(Diver), Time),
       allDifferent([Diver, Time, Depth]).
 */

 /*  [happens(decompress(Diver), Time), allDifferent([Diver, Time, Depth])] ->
       ta(Time, holds_at(neg(uncontrolledBuoyancy(Diver)), Time)).
 */
axiom(holds_at(neg(uncontrolledBuoyancy(Diver)), Time),
   
    [ happens(decompress(Diver), Time),
      allDifferent([Diver, Time, Depth])
    ]).

 /*  comparison(Depth, 0, >) :-
       happens(decompress(Diver), Time),
       allDifferent([Diver, Time, Depth]).
 */

 /*  [happens(decompress(Diver), Time), allDifferent([Diver, Time, Depth])] ->
       ta(Time, comparison(Depth, 0, >)).
 */
axiom(comparison(Depth, 0, >),
   
    [ happens(decompress(Diver), Time),
      allDifferent([Diver, Time, Depth])
    ]).

 /*  holds_at(atDepth(Diver, Depth), Time) :-
       happens(decompress(Diver), Time),
       allDifferent([Diver, Time, Depth]).
 */

 /*  [happens(decompress(Diver), Time), allDifferent([Diver, Time, Depth])] ->
       ta(Time, holds_at(atDepth(Diver, Depth), Time)).
 */
axiom(holds_at(atDepth(Diver, Depth), Time),
   
    [ happens(decompress(Diver), Time),
      allDifferent([Diver, Time, Depth])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4008
% fluent HasHeadache(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4009
fluent(hasHeadache(HasHeadache_Ret)).
==> mpred_prop(hasHeadache(diver),fluent).
==> meta_argtypes(hasHeadache(diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4010
% [diver,time]
% HoldsAt(ConditionOK(diver),time) ->
% !HoldsAt(Unconscious(diver),time) &
% !HoldsAt(HasEarPain(diver),time) &
% !HoldsAt(HasRupturedEardrum(diver),time) &
% !HoldsAt(HasDecompressionIllness(diver),time) &
% !HoldsAt(HasHeadache(diver),time).

 /*  allDifferent([Diver, Time]) ->
       ( holds_at(conditionOK(Diver), Time)->holds_at(neg(unconscious(Diver)), Time), holds_at(neg(hasEarPain(Diver)), Time), holds_at(neg(hasRupturedEardrum(Diver)), Time), holds_at(neg(hasDecompressionIllness(Diver)), Time), holds_at(neg(hasHeadache(Diver)), Time)
       ).
 */

 /*  not(holds_at(conditionOK(Diver), Time)) :-
       (   not(holds_at(neg(unconscious(Diver)), Time))
       ;   not(holds_at(neg(hasEarPain(Diver)), Time))
       ;   not(holds_at(neg(hasRupturedEardrum(Diver)), Time))
       ;   not(holds_at(neg(hasDecompressionIllness(Diver)), Time))
       ;   not(holds_at(neg(hasHeadache(Diver)), Time))
       ),
       allDifferent([Diver, Time]).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(neg(unconscious(Diver)), Time))
       ;   not(holds_at(neg(hasEarPain(Diver)), Time))
       ;   not(holds_at(neg(hasRupturedEardrum(Diver)), Time))
       ;   not(holds_at(neg(hasDecompressionIllness(Diver)), Time))
       ;   not(holds_at(neg(hasHeadache(Diver)), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(neg(unconscious(Diver))), Time)
       ;   holds_at(neg(neg(hasEarPain(Diver))), Time)
       ;   holds_at(neg(neg(hasRupturedEardrum(Diver))), Time)
       ;   holds_at(neg(neg(hasDecompressionIllness(Diver))), Time)
       ;   holds_at(neg(neg(hasHeadache(Diver))), Time)
       ).
 */

 /*  [(holds_at(neg(neg(unconscious(Diver))), Time);holds_at(neg(neg(hasEarPain(Diver))), Time);holds_at(neg(neg(hasRupturedEardrum(Diver))), Time);holds_at(neg(neg(hasDecompressionIllness(Diver))), Time);holds_at(neg(neg(hasHeadache(Diver))), Time)), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(neg(conditionOK(Diver)), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4016
axiom(holds_at(neg(conditionOK(Diver)), Time),
   
    [  (holds_at(neg(neg(unconscious(Diver))), Time);holds_at(neg(neg(hasEarPain(Diver))), Time);holds_at(neg(neg(hasRupturedEardrum(Diver))), Time);holds_at(neg(neg(hasDecompressionIllness(Diver))), Time);holds_at(neg(neg(hasHeadache(Diver))), Time)),
      allDifferent([Diver, Time])
    ]).

 /*  holds_at(neg(unconscious(Diver)), Time) :-
       holds_at(conditionOK(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(conditionOK(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(neg(unconscious(Diver)), Time)).
 */
axiom(holds_at(neg(unconscious(Diver)), Time),
   
    [ holds_at(conditionOK(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  holds_at(neg(hasEarPain(Diver)), Time) :-
       holds_at(conditionOK(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(conditionOK(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(neg(hasEarPain(Diver)), Time)).
 */
axiom(holds_at(neg(hasEarPain(Diver)), Time),
   
    [ holds_at(conditionOK(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  holds_at(neg(hasRupturedEardrum(Diver)), Time) :-
       holds_at(conditionOK(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(conditionOK(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(neg(hasRupturedEardrum(Diver)), Time)).
 */
axiom(holds_at(neg(hasRupturedEardrum(Diver)), Time),
   
    [ holds_at(conditionOK(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  holds_at(neg(hasDecompressionIllness(Diver)), Time) :-
       holds_at(conditionOK(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(conditionOK(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time,
          holds_at(neg(hasDecompressionIllness(Diver)), Time)).
 */
axiom(holds_at(neg(hasDecompressionIllness(Diver)), Time),
   
    [ holds_at(conditionOK(Diver), Time),
      allDifferent([Diver, Time])
    ]).

 /*  holds_at(neg(hasHeadache(Diver)), Time) :-
       holds_at(conditionOK(Diver), Time),
       allDifferent([Diver, Time]).
 */

 /*  [holds_at(conditionOK(Diver), Time), allDifferent([Diver, Time])] ->
       ta(Time, holds_at(neg(hasHeadache(Diver)), Time)).
 */
axiom(holds_at(neg(hasHeadache(Diver)), Time),
   
    [ holds_at(conditionOK(Diver), Time),
      allDifferent([Diver, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4018
% event BeAirlifted(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4019
event(beAirlifted(BeAirlifted_Ret)).
==> mpred_prop(beAirlifted(diver),event).
==> meta_argtypes(beAirlifted(diver)).

% event TakeInWater(diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4021
event(takeInWater(TakeInWater_Ret)).
==> mpred_prop(takeInWater(diver),event).
==> meta_argtypes(takeInWater(diver)).

% fluent LowOnAir(airtank)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4023
fluent(lowOnAir(LowOnAir_Ret)).
==> mpred_prop(lowOnAir(airtank),fluent).
==> meta_argtypes(lowOnAir(airtank)).

% event BecomeLowOnAir(airtank)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4025
event(becomeLowOnAir(BecomeLowOnAir_Ret)).
==> mpred_prop(becomeLowOnAir(airtank),event).
==> meta_argtypes(becomeLowOnAir(airtank)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4026
% [airtank,time]
% Initiates(BecomeLowOnAir(airtank),LowOnAir(airtank),time).

 /*  [] ->
       ta(Time,
          initiates(becomeLowOnAir(Airtank),
                    lowOnAir(Airtank),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4027
axiom(initiates(becomeLowOnAir(Airtank), lowOnAir(Airtank), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4029
%; initial state
% [diver]
 % HoldsAt(ConditionOK(diver),0).

 /*  [] ->
       ta(Ta_Param, initially(conditionOK(Diver))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4030
axiom(initially(conditionOK(Diver)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4031
% [diver]
 % HoldsAt(Vertical(diver),0).

 /*  [] ->
       ta(Ta_Param, initially(vertical(Diver))).
 */
axiom(initially(vertical(Diver)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4032
% !HoldsAt(DisturbedSilt(),0).
 %  not(initially(disturbedSilt)).

 /*  [] ->
       ta(Ta_Param, not(initially(disturbedSilt))).
 */
axiom(not(initially(disturbedSilt)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4033
% [diver]
 % !HoldsAt(UncontrolledBuoyancy(diver),0).
 %  not(initially(uncontrolledBuoyancy(Diver))).

 /*  [] ->
       ta(Ta_Param, not(initially(uncontrolledBuoyancy(Diver)))).
 */
axiom(not(initially(uncontrolledBuoyancy(Diver))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4034
% [diver]
 % !HoldsAt(Disoriented(diver),0).
 %  not(initially(disoriented(Diver))).

 /*  [] ->
       ta(Ta_Param, not(initially(disoriented(Diver)))).
 */
axiom(not(initially(disoriented(Diver))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4035
% [diver]
 % !HoldsAt(PositivelyBuoyant(diver),0) &
%         !HoldsAt(NeutrallyBuoyant(diver),0) &
%         !HoldsAt(NegativelyBuoyant(diver),0).

 /*   not(initially(positivelyBuoyant(Diver))),
      not(initially(neutrallyBuoyant(Diver))),
      not(initially(negativelyBuoyant(Diver))).
 */

 /*  [] ->
       ta(Ta_Param, not(initially(positivelyBuoyant(Diver)))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4037
axiom(not(initially(positivelyBuoyant(Diver))),
    []).

 /*  [] ->
       ta(Ta_Param2, not(initially(neutrallyBuoyant(Diver)))).
 */
axiom(not(initially(neutrallyBuoyant(Diver))),
    []).

 /*  [] ->
       ta(Ta_Param3, not(initially(negativelyBuoyant(Diver)))).
 */
axiom(not(initially(negativelyBuoyant(Diver))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4038
% [diver,object]
 % !HoldsAt(Wearing(diver,object),0).
 %  not(initially(wearing(Diver,Object))).

 /*  [] ->
       ta(Ta_Param, not(initially(wearing(Diver, Object)))).
 */
axiom(not(initially(wearing(Diver, Object))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4039
% [diver,object]
 % !HoldsAt(Holding(diver,object),0).
 %  not(initially(holding(Diver,Object))).

 /*  [] ->
       ta(Ta_Param, not(initially(holding(Diver, Object)))).
 */
axiom(not(initially(holding(Diver, Object))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4040
% [diver1,diver2]
 % !HoldsAt(Separated(diver1,diver2),0).
 %  not(initially(separated(Diver1,Diver2))).

 /*  [] ->
       ta(Ta_Param, not(initially(separated(Diver1, Diver2)))).
 */
axiom(not(initially(separated(Diver1, Diver2))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4041
%;[agent,object] !HoldsAt(See(agent,object),0).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4043
% fluent Separated(diver,diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4044
fluent(separated(Separated_Param,Separated_Ret)).
==> mpred_prop(separated(diver,diver),fluent).
==> meta_argtypes(separated(diver,diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4045
% [diver1,diver2,time]
% HoldsAt(Separated(diver1,diver2),time) ->
% HoldsAt(Separated(diver2,diver1),time).

 /*  allDifferent([Diver1, Diver2, Time]) ->
       ( holds_at(separated(Diver1, Diver2), Time)->holds_at(separated(Diver2, Diver1), Time)
       ).
 */

 /*  holds_at(separated(Diver2, Diver1), Time) :-
       holds_at(separated(Diver1, Diver2), Time),
       allDifferent([Diver1, Diver2, Time]).
 */

 /*  [holds_at(separated(Diver1, Diver2), Time), allDifferent([Diver1, Diver2, Time])] ->
       ta(Time, holds_at(separated(Diver2, Diver1), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4047
axiom(holds_at(separated(Diver2, Diver1), Time),
   
    [ holds_at(separated(Diver1, Diver2), Time),
      allDifferent([Diver1, Diver2, Time])
    ]).

 /*  not(holds_at(separated(Diver1, Diver2), Time)) :-
       not(holds_at(separated(Diver2, Diver1), Time)),
       allDifferent([Diver1, Diver2, Time]).
 */

 /*  [holds_at(neg(separated(Diver2, Diver1)), Time), allDifferent([Diver1, Diver2, Time])] ->
       ta(Time,
          holds_at(neg(separated(Diver1, Diver2)), Time)).
 */
axiom(holds_at(neg(separated(Diver1, Diver2)), Time),
   
    [ holds_at(neg(separated(Diver2, Diver1)), Time),
      allDifferent([Diver1, Diver2, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4049
% event BecomeSeparated(diver,diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4050
event(becomeSeparated(BecomeSeparated_Param,
		      BecomeSeparated_Ret)).
==> mpred_prop(becomeSeparated(diver,diver),event).
==> meta_argtypes(becomeSeparated(diver,diver)).

% event BeReunitedWith(diver,diver)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4052
event(beReunitedWith(BeReunitedWith_Param,
		     BeReunitedWith_Ret)).
==> mpred_prop(beReunitedWith(diver,diver),event).
==> meta_argtypes(beReunitedWith(diver,diver)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4053
% [diver1,diver2,time]
% Initiates(BecomeSeparated(diver1,diver2),Separated(diver1,diver2),time).

 /*  [] ->
       ta(Time,
          initiates(becomeSeparated(Diver1, Diver2),
                    separated(Diver1, Diver2),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4054
axiom(initiates(becomeSeparated(Diver1, Diver2), separated(Diver1, Diver2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4056
% [diver1,diver2,time]
% Initiates(BecomeSeparated(diver1,diver2),Separated(diver2,diver1),time).

 /*  [] ->
       ta(Time,
          initiates(becomeSeparated(Diver1, Diver2),
                    separated(Diver2, Diver1),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4057
axiom(initiates(becomeSeparated(Diver1, Diver2), separated(Diver2, Diver1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4059
% [diver1,diver2,time]
% Terminates(BeReunitedWith(diver1,diver2),Separated(diver1,diver2),time).

 /*  [] ->
       ta(Time,
          terminates(beReunitedWith(Diver1, Diver2),
                     separated(Diver1, Diver2),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4060
axiom(terminates(beReunitedWith(Diver1, Diver2), separated(Diver1, Diver2), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4062
% [diver1,diver2,time]
% Terminates(BeReunitedWith(diver1,diver2),Separated(diver2,diver1),time).

 /*  [] ->
       ta(Time,
          terminates(beReunitedWith(Diver1, Diver2),
                     separated(Diver2, Diver1),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4063
axiom(terminates(beReunitedWith(Diver1, Diver2), separated(Diver2, Diver1), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4065
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Dress.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Dress
%; (cf Sleep)
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4087
% event PutOn(agent,clothing)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4088
event(putOn(PutOn_Param,PutOn_Ret)).
==> mpred_prop(putOn(agent,clothing),event).
==> meta_argtypes(putOn(agent,clothing)).

% event TakeOff(agent,clothing)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4090
event(takeOff(TakeOff_Param,TakeOff_Ret)).
==> mpred_prop(takeOff(agent,clothing),event).
==> meta_argtypes(takeOff(agent,clothing)).

% fluent Wearing(agent,clothing)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4092
fluent(wearing(Wearing_Param,Wearing_Ret)).
==> mpred_prop(wearing(agent,clothing),fluent).
==> meta_argtypes(wearing(agent,clothing)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4093
% [agent,clothing,time]
% Initiates(PutOn(agent,clothing),
%           Wearing(agent,clothing),
%           time).

 /*  [] ->
       ta(Time,
          initiates(putOn(Agent, Clothing),
                    wearing(Agent, Clothing),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4096
axiom(initiates(putOn(Agent, Clothing), wearing(Agent, Clothing), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4098
% [agent,clothing,time]
% Happens(PutOn(agent,clothing),time) ->
% !HoldsAt(Wearing(agent,clothing),time) &
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4101
% {location}%  HoldsAt(At(agent,location),time) &
%            HoldsAt(At(clothing,location),time).

 /*  exists([Location],
    happens(putOn(Agent, Clothing), Time) ->
       holds_at(neg(wearing(Agent, Clothing)), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Clothing, Location), Time)).
 */

 /*  not(happens(putOn(Agent, Clothing), Time)) :-
       (   not(holds_at(neg(wearing(Agent, Clothing)), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Clothing, Location), Time))
       ),
       some(Location, '$kolem_Fn_253'(Agent, Clothing, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(neg(wearing(Agent, Clothing)), Time))
       ;   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Clothing, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(neg(wearing(Agent, Clothing))), Time)
       ;   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Clothing, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(neg(wearing(Agent, Clothing))), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Clothing, Location)), Time)), some(Location, '$kolem_Fn_253'(Agent, Clothing, Time))] ->
       ta(Time, not(happens(putOn(Agent, Clothing), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4102
axiom(not(happens(putOn(Agent, Clothing), Time)),
   
    [  (holds_at(neg(neg(wearing(Agent, Clothing))), Time);holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Clothing, Location)), Time)),
      some(Location,
           '$kolem_Fn_253'(Agent, Clothing, Time))
    ]).

 /*  holds_at(neg(wearing(Agent, Clothing)), Time) :-
       happens(putOn(Agent, Clothing), Time),
       some(Location, '$kolem_Fn_253'(Agent, Clothing, Time)).
 */

 /*  [happens(putOn(Agent, Clothing), Time), some(Location, '$kolem_Fn_253'(Agent, Clothing, Time))] ->
       ta(Time,
          holds_at(neg(wearing(Agent, Clothing)), Time)).
 */
axiom(holds_at(neg(wearing(Agent, Clothing)), Time),
   
    [ happens(putOn(Agent, Clothing), Time),
      some(Location,
           '$kolem_Fn_253'(Agent, Clothing, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(putOn(Agent, Clothing), Time),
       some(Location, '$kolem_Fn_253'(Agent, Clothing, Time)).
 */

 /*  [happens(putOn(Agent, Clothing), Time), some(Location, '$kolem_Fn_253'(Agent, Clothing, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(putOn(Agent, Clothing), Time),
      some(Location,
           '$kolem_Fn_253'(Agent, Clothing, Time))
    ]).

 /*  holds_at(at(Clothing, Location), Time) :-
       happens(putOn(Agent, Clothing), Time),
       some(Location, '$kolem_Fn_253'(Agent, Clothing, Time)).
 */

 /*  [happens(putOn(Agent, Clothing), Time), some(Location, '$kolem_Fn_253'(Agent, Clothing, Time))] ->
       ta(Time, holds_at(at(Clothing, Location), Time)).
 */
axiom(holds_at(at(Clothing, Location), Time),
   
    [ happens(putOn(Agent, Clothing), Time),
      some(Location,
           '$kolem_Fn_253'(Agent, Clothing, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4104
% [agent,clothing,time]
% Terminates(TakeOff(agent,clothing),
%            Wearing(agent,clothing),
%            time).

 /*  [] ->
       ta(Time,
          terminates(takeOff(Agent, Clothing),
                     wearing(Agent, Clothing),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4107
axiom(terminates(takeOff(Agent, Clothing), wearing(Agent, Clothing), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4109
% [agent,clothing,time]
% Happens(TakeOff(agent,clothing),time) ->
% HoldsAt(Wearing(agent,clothing),time).

 /*  allDifferent([Agent, Clothing, Time]) ->
       ( happens(takeOff(Agent, Clothing), Time)->holds_at(wearing(Agent, Clothing), Time)
       ).
 */

 /*  holds_at(wearing(Agent, Clothing), Time) :-
       happens(takeOff(Agent, Clothing), Time),
       allDifferent([Agent, Clothing, Time]).
 */

 /*  [happens(takeOff(Agent, Clothing), Time), allDifferent([Agent, Clothing, Time])] ->
       ta(Time, holds_at(wearing(Agent, Clothing), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4111
axiom(holds_at(wearing(Agent, Clothing), Time),
   
    [ happens(takeOff(Agent, Clothing), Time),
      allDifferent([Agent, Clothing, Time])
    ]).

 /*  not(happens(takeOff(Agent, Clothing), Time)) :-
       not(holds_at(wearing(Agent, Clothing), Time)),
       allDifferent([Agent, Clothing, Time]).
 */

 /*  [holds_at(neg(wearing(Agent, Clothing)), Time), allDifferent([Agent, Clothing, Time])] ->
       ta(Time,
          not(happens(takeOff(Agent, Clothing), Time))).
 */
axiom(not(happens(takeOff(Agent, Clothing), Time)),
   
    [ holds_at(neg(wearing(Agent, Clothing)), Time),
      allDifferent([Agent, Clothing, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4113
% [agent,clothing,location,time]
% Releases(PutOn(agent,clothing),At(clothing,location),time).

 /*  [] ->
       ta(Time,
          releases(putOn(Agent, Clothing),
                   at(Clothing, Location),
                   Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4114
axiom(releases(putOn(Agent, Clothing), at(Clothing, Location), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4116
% [agent,clothing,location,time]
% HoldsAt(Wearing(agent,clothing),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(clothing,location),time).

 /*  allDifferent([Agent, Clothing, Time, Location]) ->
       ( holds_at(wearing(Agent, Clothing), Time), holds_at(at(Agent, Location), Time)->holds_at(at(Clothing, Location), Time)
       ).
 */

 /*  holds_at(at(Clothing, Location), Time) :-
       ( holds_at(wearing(Agent, Clothing), Time),
         holds_at(at(Agent, Location), Time)
       ),
       allDifferent([Agent, Clothing, Time, Location]).
 */

 /*  [holds_at(wearing(Agent, Clothing), Time), holds_at(at(Agent, Location), Time), allDifferent([Agent, Clothing, Time, Location])] ->
       ta(Time, holds_at(at(Clothing, Location), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4119
axiom(holds_at(at(Clothing, Location), Time),
   
    [ holds_at(wearing(Agent, Clothing), Time),
      holds_at(at(Agent, Location), Time),
      allDifferent([Agent, Clothing, Time, Location])
    ]).

 /*  not(holds_at(wearing(Agent, Clothing), Time)) :-
       holds_at(at(Agent, Location), Time),
       not(holds_at(at(Clothing, Location), Time)),
       allDifferent([Agent, Clothing, Time, Location]).
 */

 /*  [holds_at(at(Agent, Location), Time), holds_at(neg(at(Clothing, Location)), Time), allDifferent([Agent, Clothing, Time, Location])] ->
       ta(Time,
          holds_at(neg(wearing(Agent, Clothing)), Time)).
 */
axiom(holds_at(neg(wearing(Agent, Clothing)), Time),
   
    [ holds_at(at(Agent, Location), Time),
      holds_at(neg(at(Clothing, Location)), Time),
      allDifferent([Agent, Clothing, Time, Location])
    ]).

 /*  not(holds_at(at(Agent, Location), Time)) :-
       holds_at(wearing(Agent, Clothing), Time),
       not(holds_at(at(Clothing, Location), Time)),
       allDifferent([Agent, Clothing, Time, Location]).
 */

 /*  [holds_at(wearing(Agent, Clothing), Time), holds_at(neg(at(Clothing, Location)), Time), allDifferent([Agent, Clothing, Time, Location])] ->
       ta(Time, holds_at(neg(at(Agent, Location)), Time)).
 */
axiom(holds_at(neg(at(Agent, Location)), Time),
   
    [ holds_at(wearing(Agent, Clothing), Time),
      holds_at(neg(at(Clothing, Location)), Time),
      allDifferent([Agent, Clothing, Time, Location])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4121
%;[agent,clothing,location1,location2,time]
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(TakeOff(agent,clothing),At(clothing,location2),time).
% [agent,clothing,location,time]
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4127
% HoldsAt(At(agent,location),time) ->
% Initiates(TakeOff(agent,clothing),At(clothing,location),time).

 /*  [holds_at(at(Agent, Location), Time)] ->
       ta(Time,
          initiates(takeOff(Agent, Clothing),
                    at(Clothing, Location),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4128
axiom(initiates(takeOff(Agent, Clothing), at(Clothing, Location), Time),
    [holds_at(at(Agent, Location), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4130
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/HungerNeed.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; hunger need
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4151
% fluent Hungry(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4152
fluent(hungry(Hungry_Ret)).
==> mpred_prop(hungry(agent),fluent).
==> meta_argtypes(hungry(agent)).

% fluent Satiated(agent)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4154
fluent(satiated(Satiated_Ret)).
==> mpred_prop(satiated(agent),fluent).
==> meta_argtypes(satiated(agent)).

% noninertial Satiated
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4155
==> noninertial(satiated).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4156
% [agent,time]
 % HoldsAt(Hungry(agent),time) <-> !HoldsAt(Satiated(agent),time).

 /*  holds_at(hungry(Agent), Time) <->
       holds_at(neg(satiated(Agent)), Time).
 */

 /*  [holds_at, hungry] <->
       [holds_at, neg, satiated].
 */

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(hungry(Agent), Time)->holds_at(neg(satiated(Agent)), Time)
       ).
 */

 /*  holds_at(neg(satiated(Agent)), Time) :-
       holds_at(hungry(Agent), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(hungry(Agent), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(satiated(Agent)), Time)).
 */
axiom(holds_at(neg(satiated(Agent)), Time),
   
    [ holds_at(hungry(Agent), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(hungry(Agent), Time)) :-
       not(holds_at(neg(satiated(Agent)), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(neg(satiated(Agent))), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(hungry(Agent)), Time)).
 */
axiom(holds_at(neg(hungry(Agent)), Time),
   
    [ holds_at(neg(neg(satiated(Agent))), Time),
      allDifferent([Agent, Time])
    ]).

 /*  allDifferent([Agent, Time]) ->
       ( holds_at(neg(satiated(Agent)), Time)->holds_at(hungry(Agent), Time)
       ).
 */

 /*  holds_at(hungry(Agent), Time) :-
       holds_at(neg(satiated(Agent)), Time),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(satiated(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(hungry(Agent), Time)).
 */
axiom(holds_at(hungry(Agent), Time),
   
    [ holds_at(neg(satiated(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

 /*  not(holds_at(neg(satiated(Agent)), Time)) :-
       not(holds_at(hungry(Agent), Time)),
       allDifferent([Agent, Time]).
 */

 /*  [holds_at(neg(hungry(Agent)), Time), allDifferent([Agent, Time])] ->
       ta(Time, holds_at(neg(neg(satiated(Agent))), Time)).
 */
axiom(holds_at(neg(neg(satiated(Agent))), Time),
   
    [ holds_at(neg(hungry(Agent)), Time),
      allDifferent([Agent, Time])
    ]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4158
% event Eat(agent,food)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4159
event(eat(Eat_Param,Eat_Ret)).
==> mpred_prop(eat(agent,food),event).
==> meta_argtypes(eat(agent,food)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4160
% [agent,food,time]
% Happens(Eat(agent,food),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4162
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).

 /*  exists([Location],
    happens(eat(Agent, Food), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Food, Location), Time)).
 */

 /*  not(happens(eat(Agent, Food), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Food, Location), Time))
       ),
       some(Location, '$kolem_Fn_254'(Agent, Food, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Food, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Food, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Food, Location)), Time)), some(Location, '$kolem_Fn_254'(Agent, Food, Time))] ->
       ta(Time, not(happens(eat(Agent, Food), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4164
axiom(not(happens(eat(Agent, Food), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Food, Location)), Time)),
      some(Location, '$kolem_Fn_254'(Agent, Food, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(eat(Agent, Food), Time),
       some(Location, '$kolem_Fn_254'(Agent, Food, Time)).
 */

 /*  [happens(eat(Agent, Food), Time), some(Location, '$kolem_Fn_254'(Agent, Food, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(eat(Agent, Food), Time),
      some(Location, '$kolem_Fn_254'(Agent, Food, Time))
    ]).

 /*  holds_at(at(Food, Location), Time) :-
       happens(eat(Agent, Food), Time),
       some(Location, '$kolem_Fn_254'(Agent, Food, Time)).
 */

 /*  [happens(eat(Agent, Food), Time), some(Location, '$kolem_Fn_254'(Agent, Food, Time))] ->
       ta(Time, holds_at(at(Food, Location), Time)).
 */
axiom(holds_at(at(Food, Location), Time),
   
    [ happens(eat(Agent, Food), Time),
      some(Location, '$kolem_Fn_254'(Agent, Food, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4166
% [agent,food,time]
% Terminates(Eat(agent,food),Hungry(agent),time).

 /*  [] ->
       ta(Time,
          terminates(eat(Agent, Food), hungry(Agent), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4167
axiom(terminates(eat(Agent, Food), hungry(Agent), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4169
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Restaurant.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4187
% sort restaurant: script
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4188
==> subsort(restaurant,script).

% sort waiter: agent
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4189
==> subsort(waiter,agent).

% sort cook: agent
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4190
==> subsort(cook,agent).

% function BillOf(restaurant): bill
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4192
functional_predicate(billOf(BillOf_Param,BillOf_Ret)).
==> mpred_prop(billOf(restaurant,bill),functional_predicate).
==> meta_argtypes(billOf(restaurant,bill)).
==> resultIsa(billOf,bill).

% function CookOf(restaurant): cook
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4193
functional_predicate(cookOf(CookOf_Param,CookOf_Ret)).
==> mpred_prop(cookOf(restaurant,cook),functional_predicate).
==> meta_argtypes(cookOf(restaurant,cook)).
==> resultIsa(cookOf,cook).

% function TableOf(restaurant): table
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4194
functional_predicate(tableOf(TableOf_Param,TableOf_Ret)).
==> mpred_prop(tableOf(restaurant,table),functional_predicate).
==> meta_argtypes(tableOf(restaurant,table)).
==> resultIsa(tableOf,table).

% function WaiterOf(restaurant): waiter
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4195
functional_predicate(waiterOf(WaiterOf_Param,WaiterOf_Ret)).
==> mpred_prop(waiterOf(restaurant,waiter),functional_predicate).
==> meta_argtypes(waiterOf(restaurant,waiter)).
==> resultIsa(waiterOf,waiter).

% function KitchenDoorOf(restaurant): door
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4196
functional_predicate(kitchenDoorOf(KitchenDoorOf_Param,
				   KitchenDoorOf_Ret)).
==> mpred_prop(kitchenDoorOf(restaurant,door),functional_predicate).
==> meta_argtypes(kitchenDoorOf(restaurant,door)).
==> resultIsa(kitchenDoorOf,door).
%; awaiting customer/waiter has set down bill on customer's table

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4198
% fluent BeWaiter0(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4199
fluent(beWaiter0(BeWaiter0_Ret)).
==> mpred_prop(beWaiter0(waiter),fluent).
==> meta_argtypes(beWaiter0(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4200
%; awaiting customer order

% fluent BeWaiter1(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4202
fluent(beWaiter1(BeWaiter1_Ret)).
==> mpred_prop(beWaiter1(waiter),fluent).
==> meta_argtypes(beWaiter1(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4203
%; has customer order

% fluent BeWaiter2(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4205
fluent(beWaiter2(BeWaiter2_Ret)).
==> mpred_prop(beWaiter2(waiter),fluent).
==> meta_argtypes(beWaiter2(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4206
%; in kitchen

% fluent BeWaiter3(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4208
fluent(beWaiter3(BeWaiter3_Ret)).
==> mpred_prop(beWaiter3(waiter),fluent).
==> meta_argtypes(beWaiter3(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4209
%; awaiting preparation of order

% fluent BeWaiter4(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4211
fluent(beWaiter4(BeWaiter4_Ret)).
==> mpred_prop(beWaiter4(waiter),fluent).
==> meta_argtypes(beWaiter4(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4212
%; has order

% fluent BeWaiter5(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4214
fluent(beWaiter5(BeWaiter5_Ret)).
==> mpred_prop(beWaiter5(waiter),fluent).
==> meta_argtypes(beWaiter5(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4215
%; back in dining room

% fluent BeWaiter6(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4217
fluent(beWaiter6(BeWaiter6_Ret)).
==> mpred_prop(beWaiter6(waiter),fluent).
==> meta_argtypes(beWaiter6(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4218
%; order delivered to customer (can ask if all is OK)

% fluent BeWaiter7(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4220
fluent(beWaiter7(BeWaiter7_Ret)).
==> mpred_prop(beWaiter7(waiter),fluent).
==> meta_argtypes(beWaiter7(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4221
%; customer has requested bill

% fluent BeWaiter8(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4223
fluent(beWaiter8(BeWaiter8_Ret)).
==> mpred_prop(beWaiter8(waiter),fluent).
==> meta_argtypes(beWaiter8(waiter)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4224
%; waiter is holding bill

% fluent BeWaiter9(waiter)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4226
fluent(beWaiter9(BeWaiter9_Ret)).
==> mpred_prop(beWaiter9(waiter),fluent).
==> meta_argtypes(beWaiter9(waiter)).

% xor BeWaiter0, BeWaiter1, BeWaiter2, BeWaiter3, BeWaiter4, BeWaiter5, BeWaiter6, BeWaiter7, BeWaiter8, BeWaiter9
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4228
==> xor([ beWaiter0,
	  beWaiter1,
	  beWaiter2,
	  beWaiter3,
	  beWaiter4,
	  beWaiter5,
	  beWaiter6,
	  beWaiter7,
	  beWaiter8,
	  beWaiter9
	]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4229
% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Terminates(Greet(waiter,agent),
%            BeWaiter0(waiter),
%            time).

 /*  [holds_at(beWaiter0(Waiter), Time)] ->
       ta(Time,
          terminates(greet(Waiter, Agent),
                     beWaiter0(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4233
axiom(terminates(greet(Waiter, Agent), beWaiter0(Waiter), Time),
    [holds_at(beWaiter0(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4235
% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Initiates(Greet(waiter,agent),
%           BeWaiter1(waiter),
%           time).

 /*  [holds_at(beWaiter0(Waiter), Time)] ->
       ta(Time,
          initiates(greet(Waiter, Agent),
                    beWaiter1(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4239
axiom(initiates(greet(Waiter, Agent), beWaiter1(Waiter), Time),
    [holds_at(beWaiter0(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4241
% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Terminates(Order(agent,waiter,food),
%            BeWaiter1(waiter),
%            time).

 /*  [holds_at(beWaiter1(Waiter), Time)] ->
       ta(Time,
          terminates(order(Agent, Waiter, Food),
                     beWaiter1(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4245
axiom(terminates(order(Agent, Waiter, Food), beWaiter1(Waiter), Time),
    [holds_at(beWaiter1(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4247
% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Initiates(Order(agent,waiter,food),
%           BeWaiter2(waiter),
%           time).

 /*  [holds_at(beWaiter1(Waiter), Time)] ->
       ta(Time,
          initiates(order(Agent, Waiter, Food),
                    beWaiter2(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4251
axiom(initiates(order(Agent, Waiter, Food), beWaiter2(Waiter), Time),
    [holds_at(beWaiter1(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4253
% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter2(waiter),time) ->
% Happens(WalkThroughDoor12(waiter,KitchenDoorOf(restaurant)),time).

 /*  allDifferent([Restaurant, Waiter, Time]) ->
       ( waiterOf(Restaurant)=Waiter, holds_at(beWaiter2(Waiter), Time)->happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time)
       ).
 */

 /*  happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         holds_at(beWaiter2(Waiter), Time)
       ),
       allDifferent([Restaurant, Waiter, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), holds_at(beWaiter2(Waiter), Time), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time,
          happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)),
                  Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(beWaiter2(Waiter), Time), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time,
          happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)),
                  Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4256
axiom(happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(beWaiter2(Waiter), Time),
      allDifferent([Restaurant, Waiter, Time])
    ]).

 /*  not(holds_at(beWaiter2(Waiter), Time)) :-
       equals(waiterOf(Restaurant), Waiter),
       not(happens(walkThroughDoor12(Waiter,
                                     kitchenDoorOf(Restaurant)),
                   Time)),
       allDifferent([Restaurant, Waiter, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), not(happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time)), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time, holds_at(neg(beWaiter2(Waiter)), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time)), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time, holds_at(neg(beWaiter2(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter2(Waiter)), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(walkThroughDoor12(Waiter,
                                    kitchenDoorOf(Restaurant)),
                  Time)),
      allDifferent([Restaurant, Waiter, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4258
% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor12(waiter,door),
%            BeWaiter2(waiter),
%            time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(kitchenDoorOf(Restaurant), Door).
 */

 /*  fix_axiom_head(Time) ->
       call(kitchenDoorOf(Restaurant)=Door).
 */

 /*  [holds_at(beWaiter2(Waiter), Time), call(waiterOf(Restaurant)=Waiter), call(kitchenDoorOf(Restaurant)=Door)] ->
       ta(Time,
          terminates(walkThroughDoor12(Waiter, Door),
                     beWaiter2(Waiter),
                     Time)).
 */

 /*  [holds_at(beWaiter2(Waiter), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)] ->
       ta(Time,
          terminates(walkThroughDoor12(Waiter, Door),
                     beWaiter2(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4264
axiom(terminates(walkThroughDoor12(Waiter, Door), beWaiter2(Waiter), Time),
   
    [ holds_at(beWaiter2(Waiter), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4266
% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor12(waiter,door),
%           BeWaiter3(waiter),
%           time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(kitchenDoorOf(Restaurant), Door).
 */

 /*  fix_axiom_head(Time) ->
       call(kitchenDoorOf(Restaurant)=Door).
 */

 /*  [holds_at(beWaiter2(Waiter), Time), call(waiterOf(Restaurant)=Waiter), call(kitchenDoorOf(Restaurant)=Door)] ->
       ta(Time,
          initiates(walkThroughDoor12(Waiter, Door),
                    beWaiter3(Waiter),
                    Time)).
 */

 /*  [holds_at(beWaiter2(Waiter), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)] ->
       ta(Time,
          initiates(walkThroughDoor12(Waiter, Door),
                    beWaiter3(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4272
axiom(initiates(walkThroughDoor12(Waiter, Door), beWaiter3(Waiter), Time),
   
    [ holds_at(beWaiter2(Waiter), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4274
% [restaurant,food,time]
% HoldsAt(BeWaiter3(WaiterOf(restaurant)),time) &
% ({agent} HoldsAt(KnowOrder(WaiterOf(restaurant),agent,food),time)) ->
% Happens(Order(WaiterOf(restaurant),CookOf(restaurant),food),time).

 /*  allDifferent([Restaurant, Time, Agent, Food]) ->
       ( holds_at(beWaiter3(waiterOf(Restaurant)), Time), exists([Agent], holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time))->happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time)
       ).
 */

 /*  happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time) :-
       ( holds_at(beWaiter3(waiterOf(Restaurant)), Time),
         holds_at(knowOrder(waiterOf(Restaurant), Agent, Food),
                  Time)
       ),
       allDifferent([Restaurant, Time, Agent, Food]).
 */

 /*  [holds_at(beWaiter3(waiterOf(Restaurant)), Time), holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time), allDifferent([Restaurant, Time, Agent, Food])] ->
       ta(Time,
          happens(order(waiterOf(Restaurant),
                        cookOf(Restaurant),
                        Food),
                  Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4277
axiom(happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time),
   
    [ holds_at(beWaiter3(waiterOf(Restaurant)), Time),
      holds_at(knowOrder(waiterOf(Restaurant), Agent, Food),
               Time),
      allDifferent([Restaurant, Time, Agent, Food])
    ]).

 /*  not(holds_at(beWaiter3(waiterOf(Restaurant)), Time)) :-
       holds_at(knowOrder(waiterOf(Restaurant), Agent, Food),
                Time),
       not(happens(order(waiterOf(Restaurant),
                         cookOf(Restaurant),
                         Food),
                   Time)),
       allDifferent([Restaurant, Time, Agent, Food]).
 */

 /*  [holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time), not(happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time)), allDifferent([Restaurant, Time, Agent, Food])] ->
       ta(Time,
          holds_at(neg(beWaiter3(waiterOf(Restaurant))), Time)).
 */
axiom(holds_at(neg(beWaiter3(waiterOf(Restaurant))), Time),
   
    [ holds_at(knowOrder(waiterOf(Restaurant), Agent, Food),
               Time),
      not(happens(order(waiterOf(Restaurant),
                        cookOf(Restaurant),
                        Food),
                  Time)),
      allDifferent([Restaurant, Time, Agent, Food])
    ]).

 /*  not(holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time)) :-
       holds_at(beWaiter3(waiterOf(Restaurant)), Time),
       not(happens(order(waiterOf(Restaurant),
                         cookOf(Restaurant),
                         Food),
                   Time)),
       allDifferent([Restaurant, Time, Agent, Food]).
 */

 /*  [holds_at(beWaiter3(waiterOf(Restaurant)), Time), not(happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time)), allDifferent([Restaurant, Time, Agent, Food])] ->
       ta(Time,
          holds_at(neg(knowOrder(waiterOf(Restaurant),
                                 Agent,
                                 Food)),
                   Time)).
 */
axiom(holds_at(neg(knowOrder(waiterOf(Restaurant), Agent, Food)), Time),
   
    [ holds_at(beWaiter3(waiterOf(Restaurant)), Time),
      not(happens(order(waiterOf(Restaurant),
                        cookOf(Restaurant),
                        Food),
                  Time)),
      allDifferent([Restaurant, Time, Agent, Food])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4279
% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Terminates(Order(waiter,cook,food),
%            BeWaiter3(waiter),
%            time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(cookOf(Restaurant), Cook).
 */

 /*  fix_axiom_head(Time) ->
       call(cookOf(Restaurant)=Cook).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(cookOf(Restaurant)=Cook), holds_at(beWaiter3(Waiter), Time)] ->
       ta(Time,
          terminates(order(Waiter, Cook, Food),
                     beWaiter3(Waiter),
                     Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(cookOf(Restaurant)=Cook), Time), holds_at(beWaiter3(Waiter), Time)] ->
       ta(Time,
          terminates(order(Waiter, Cook, Food),
                     beWaiter3(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4285
axiom(terminates(order(Waiter, Cook, Food), beWaiter3(Waiter), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(cookOf(Restaurant)=Cook), Time),
      holds_at(beWaiter3(Waiter), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4287
% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Initiates(Order(waiter,cook,food),
%           BeWaiter4(waiter),
%           time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(cookOf(Restaurant), Cook).
 */

 /*  fix_axiom_head(Time) ->
       call(cookOf(Restaurant)=Cook).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(cookOf(Restaurant)=Cook), holds_at(beWaiter3(Waiter), Time)] ->
       ta(Time,
          initiates(order(Waiter, Cook, Food),
                    beWaiter4(Waiter),
                    Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(cookOf(Restaurant)=Cook), Time), holds_at(beWaiter3(Waiter), Time)] ->
       ta(Time,
          initiates(order(Waiter, Cook, Food),
                    beWaiter4(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4293
axiom(initiates(order(Waiter, Cook, Food), beWaiter4(Waiter), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(cookOf(Restaurant)=Cook), Time),
      holds_at(beWaiter3(Waiter), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4295
% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) &
% HoldsAt(FoodPrepared(food),time) ->
% Happens(PickUp(waiter,food),time).

 /*  allDifferent([Waiter, Time, Agent, Food]) ->
       ( holds_at(beWaiter4(Waiter), Time), exists([Agent], holds_at(knowOrder(Waiter, Agent, Food), Time)), holds_at(foodPrepared(Food), Time)->happens(pickUp(Waiter, Food), Time)
       ).
 */

 /*  happens(pickUp(Waiter, Food), Time) :-
       ( holds_at(beWaiter4(Waiter), Time),
         holds_at(knowOrder(Waiter, Agent, Food), Time),
         holds_at(foodPrepared(Food), Time)
       ),
       allDifferent([Waiter, Time, Agent, Food]).
 */

 /*  [holds_at(beWaiter4(Waiter), Time), holds_at(knowOrder(Waiter, Agent, Food), Time), holds_at(foodPrepared(Food), Time), allDifferent([Waiter, Time, Agent, Food])] ->
       ta(Time, happens(pickUp(Waiter, Food), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4299
axiom(happens(pickUp(Waiter, Food), Time),
   
    [ holds_at(beWaiter4(Waiter), Time),
      holds_at(knowOrder(Waiter, Agent, Food), Time),
      holds_at(foodPrepared(Food), Time),
      allDifferent([Waiter, Time, Agent, Food])
    ]).

 /*  not(holds_at(beWaiter4(Waiter), Time)) :-
       ( holds_at(knowOrder(Waiter, Agent, Food), Time),
         holds_at(foodPrepared(Food), Time)
       ),
       not(happens(pickUp(Waiter, Food), Time)),
       allDifferent([Waiter, Time, Agent, Food]).
 */

 /*  [holds_at(knowOrder(Waiter, Agent, Food), Time), holds_at(foodPrepared(Food), Time), not(happens(pickUp(Waiter, Food), Time)), allDifferent([Waiter, Time, Agent, Food])] ->
       ta(Time, holds_at(neg(beWaiter4(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter4(Waiter)), Time),
   
    [ holds_at(knowOrder(Waiter, Agent, Food), Time),
      holds_at(foodPrepared(Food), Time),
      not(happens(pickUp(Waiter, Food), Time)),
      allDifferent([Waiter, Time, Agent, Food])
    ]).

 /*  not(holds_at(knowOrder(Waiter, Agent, Food), Time)) :-
       holds_at(foodPrepared(Food), Time),
       holds_at(beWaiter4(Waiter), Time),
       not(happens(pickUp(Waiter, Food), Time)),
       allDifferent([Waiter, Time, Agent, Food]).
 */

 /*  [holds_at(foodPrepared(Food), Time), holds_at(beWaiter4(Waiter), Time), not(happens(pickUp(Waiter, Food), Time)), allDifferent([Waiter, Time, Agent, Food])] ->
       ta(Time,
          holds_at(neg(knowOrder(Waiter, Agent, Food)),
                   Time)).
 */
axiom(holds_at(neg(knowOrder(Waiter, Agent, Food)), Time),
   
    [ holds_at(foodPrepared(Food), Time),
      holds_at(beWaiter4(Waiter), Time),
      not(happens(pickUp(Waiter, Food), Time)),
      allDifferent([Waiter, Time, Agent, Food])
    ]).

 /*  not(holds_at(foodPrepared(Food), Time)) :-
       holds_at(knowOrder(Waiter, Agent, Food), Time),
       holds_at(beWaiter4(Waiter), Time),
       not(happens(pickUp(Waiter, Food), Time)),
       allDifferent([Waiter, Time, Agent, Food]).
 */

 /*  [holds_at(knowOrder(Waiter, Agent, Food), Time), holds_at(beWaiter4(Waiter), Time), not(happens(pickUp(Waiter, Food), Time)), allDifferent([Waiter, Time, Agent, Food])] ->
       ta(Time, holds_at(neg(foodPrepared(Food)), Time)).
 */
axiom(holds_at(neg(foodPrepared(Food)), Time),
   
    [ holds_at(knowOrder(Waiter, Agent, Food), Time),
      holds_at(beWaiter4(Waiter), Time),
      not(happens(pickUp(Waiter, Food), Time)),
      allDifferent([Waiter, Time, Agent, Food])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4301
% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Terminates(PickUp(waiter,food),
%            BeWaiter4(waiter),
%            time).

 /*  [holds_at(beWaiter4(Waiter), Time), holds_at(knowOrder(Waiter, Agent, Food), Time)] ->
       ta(Time,
          terminates(pickUp(Waiter, Food),
                     beWaiter4(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4306
axiom(terminates(pickUp(Waiter, Food), beWaiter4(Waiter), Time),
   
    [ holds_at(beWaiter4(Waiter), Time),
      holds_at(knowOrder(Waiter, Agent, Food), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4308
% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Initiates(PickUp(waiter,food),
%           BeWaiter5(waiter),
%           time).

 /*  [holds_at(beWaiter4(Waiter), Time), holds_at(knowOrder(Waiter, Agent, Food), Time)] ->
       ta(Time,
          initiates(pickUp(Waiter, Food),
                    beWaiter5(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4313
axiom(initiates(pickUp(Waiter, Food), beWaiter5(Waiter), Time),
   
    [ holds_at(beWaiter4(Waiter), Time),
      holds_at(knowOrder(Waiter, Agent, Food), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4315
% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter5(waiter),time) ->
% Happens(WalkThroughDoor21(waiter,KitchenDoorOf(restaurant)),time).

 /*  allDifferent([Restaurant, Waiter, Time]) ->
       ( waiterOf(Restaurant)=Waiter, holds_at(beWaiter5(Waiter), Time)->happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time)
       ).
 */

 /*  happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         holds_at(beWaiter5(Waiter), Time)
       ),
       allDifferent([Restaurant, Waiter, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), holds_at(beWaiter5(Waiter), Time), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time,
          happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)),
                  Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(beWaiter5(Waiter), Time), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time,
          happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)),
                  Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4318
axiom(happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(beWaiter5(Waiter), Time),
      allDifferent([Restaurant, Waiter, Time])
    ]).

 /*  not(holds_at(beWaiter5(Waiter), Time)) :-
       equals(waiterOf(Restaurant), Waiter),
       not(happens(walkThroughDoor21(Waiter,
                                     kitchenDoorOf(Restaurant)),
                   Time)),
       allDifferent([Restaurant, Waiter, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), not(happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time)), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time, holds_at(neg(beWaiter5(Waiter)), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time)), allDifferent([Restaurant, Waiter, Time])] ->
       ta(Time, holds_at(neg(beWaiter5(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter5(Waiter)), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(walkThroughDoor21(Waiter,
                                    kitchenDoorOf(Restaurant)),
                  Time)),
      allDifferent([Restaurant, Waiter, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4320
% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor21(waiter,door),
%            BeWaiter5(waiter),
%            time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(kitchenDoorOf(Restaurant), Door).
 */

 /*  fix_axiom_head(Time) ->
       call(kitchenDoorOf(Restaurant)=Door).
 */

 /*  [holds_at(beWaiter5(Waiter), Time), call(waiterOf(Restaurant)=Waiter), call(kitchenDoorOf(Restaurant)=Door)] ->
       ta(Time,
          terminates(walkThroughDoor21(Waiter, Door),
                     beWaiter5(Waiter),
                     Time)).
 */

 /*  [holds_at(beWaiter5(Waiter), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)] ->
       ta(Time,
          terminates(walkThroughDoor21(Waiter, Door),
                     beWaiter5(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4326
axiom(terminates(walkThroughDoor21(Waiter, Door), beWaiter5(Waiter), Time),
   
    [ holds_at(beWaiter5(Waiter), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4328
% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor21(waiter,door),
%           BeWaiter6(waiter),
%           time).

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(kitchenDoorOf(Restaurant), Door).
 */

 /*  fix_axiom_head(Time) ->
       call(kitchenDoorOf(Restaurant)=Door).
 */

 /*  [holds_at(beWaiter5(Waiter), Time), call(waiterOf(Restaurant)=Waiter), call(kitchenDoorOf(Restaurant)=Door)] ->
       ta(Time,
          initiates(walkThroughDoor21(Waiter, Door),
                    beWaiter6(Waiter),
                    Time)).
 */

 /*  [holds_at(beWaiter5(Waiter), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)] ->
       ta(Time,
          initiates(walkThroughDoor21(Waiter, Door),
                    beWaiter6(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4334
axiom(initiates(walkThroughDoor21(Waiter, Door), beWaiter6(Waiter), Time),
   
    [ holds_at(beWaiter5(Waiter), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(kitchenDoorOf(Restaurant)=Door), Time)
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4336
% [restaurant,waiter,table,food,time]
% WaiterOf(restaurant)=waiter &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter6(waiter),time) &
% HoldsAt(Holding(waiter,food),time) ->
% Happens(PlaceOn(waiter,food,table),time).

 /*  allDifferent([Restaurant, Waiter, Table, Time, Food]) ->
       ( waiterOf(Restaurant)=Waiter, tableOf(Restaurant)=Table, holds_at(beWaiter6(Waiter), Time), holds_at(holding(Waiter, Food), Time)->happens(placeOn(Waiter, Food, Table), Time)
       ).
 */

 /*  happens(placeOn(Waiter, Food, Table), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         equals(tableOf(Restaurant), Table),
         holds_at(beWaiter6(Waiter), Time),
         holds_at(holding(Waiter, Food), Time)
       ),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Table,
                      Time,
                      Food
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(tableOf(Restaurant)=Table), holds_at(beWaiter6(Waiter), Time), holds_at(holding(Waiter, Food), Time), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time,
          happens(placeOn(Waiter, Food, Table), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(beWaiter6(Waiter), Time), holds_at(holding(Waiter, Food), Time), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time,
          happens(placeOn(Waiter, Food, Table), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4341
axiom(happens(placeOn(Waiter, Food, Table), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(beWaiter6(Waiter), Time),
      holds_at(holding(Waiter, Food), Time),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Table,
                     Time,
                     Food
                   ])
    ]).

 /*  not(holds_at(beWaiter6(Waiter), Time)) :-
       holds_at(holding(Waiter, Food), Time),
       equals(tableOf(Restaurant), Table),
       equals(waiterOf(Restaurant), Waiter),
       not(happens(placeOn(Waiter, Food, Table), Time)),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Table,
                      Time,
                      Food
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [holds_at(holding(Waiter, Food), Time), call(tableOf(Restaurant)=Table), call(waiterOf(Restaurant)=Waiter), not(happens(placeOn(Waiter, Food, Table), Time)), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time, holds_at(neg(beWaiter6(Waiter)), Time)).
 */

 /*  [holds_at(holding(Waiter, Food), Time), holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(placeOn(Waiter, Food, Table), Time)), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time, holds_at(neg(beWaiter6(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter6(Waiter)), Time),
   
    [ holds_at(holding(Waiter, Food), Time),
      holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(placeOn(Waiter, Food, Table), Time)),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Table,
                     Time,
                     Food
                   ])
    ]).

 /*  not(holds_at(holding(Waiter, Food), Time)) :-
       holds_at(beWaiter6(Waiter), Time),
       equals(tableOf(Restaurant), Table),
       equals(waiterOf(Restaurant), Waiter),
       not(happens(placeOn(Waiter, Food, Table), Time)),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Table,
                      Time,
                      Food
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [holds_at(beWaiter6(Waiter), Time), call(tableOf(Restaurant)=Table), call(waiterOf(Restaurant)=Waiter), not(happens(placeOn(Waiter, Food, Table), Time)), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time, holds_at(neg(holding(Waiter, Food)), Time)).
 */

 /*  [holds_at(beWaiter6(Waiter), Time), holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(placeOn(Waiter, Food, Table), Time)), allDifferent([Restaurant, Waiter, Table, Time, Food])] ->
       ta(Time, holds_at(neg(holding(Waiter, Food)), Time)).
 */
axiom(holds_at(neg(holding(Waiter, Food)), Time),
   
    [ holds_at(beWaiter6(Waiter), Time),
      holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(placeOn(Waiter, Food, Table), Time)),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Table,
                     Time,
                     Food
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4343
% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Terminates(PlaceOn(waiter,food,table),
%            BeWaiter6(waiter),
%            time).

 /*  [holds_at(beWaiter6(Waiter), Time)] ->
       ta(Time,
          terminates(placeOn(Waiter, Food, Table),
                     beWaiter6(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4347
axiom(terminates(placeOn(Waiter, Food, Table), beWaiter6(Waiter), Time),
    [holds_at(beWaiter6(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4349
% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Initiates(PlaceOn(waiter,food,table),
%           BeWaiter7(waiter),
%           time).

 /*  [holds_at(beWaiter6(Waiter), Time)] ->
       ta(Time,
          initiates(placeOn(Waiter, Food, Table),
                    beWaiter7(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4353
axiom(initiates(placeOn(Waiter, Food, Table), beWaiter7(Waiter), Time),
    [holds_at(beWaiter6(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4355
% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Terminates(Request(agent,waiter,bill),
%            BeWaiter7(waiter),
%            time).

 /*  [holds_at(beWaiter7(Waiter), Time)] ->
       ta(Time,
          terminates(request(Agent, Waiter, Bill),
                     beWaiter7(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4359
axiom(terminates(request(Agent, Waiter, Bill), beWaiter7(Waiter), Time),
    [holds_at(beWaiter7(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4361
% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Initiates(Request(agent,waiter,bill),
%           BeWaiter8(waiter),
%           time).

 /*  [holds_at(beWaiter7(Waiter), Time)] ->
       ta(Time,
          initiates(request(Agent, Waiter, Bill),
                    beWaiter8(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4365
axiom(initiates(request(Agent, Waiter, Bill), beWaiter8(Waiter), Time),
    [holds_at(beWaiter7(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4367
% [restaurant,waiter,bill,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% HoldsAt(BeWaiter8(waiter),time) ->
% Happens(PickUp(waiter,bill),time).

 /*  allDifferent([Restaurant, Waiter, Bill, Time]) ->
       ( waiterOf(Restaurant)=Waiter, billOf(Restaurant)=Bill, holds_at(beWaiter8(Waiter), Time)->happens(pickUp(Waiter, Bill), Time)
       ).
 */

 /*  happens(pickUp(Waiter, Bill), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         equals(billOf(Restaurant), Bill),
         holds_at(beWaiter8(Waiter), Time)
       ),
       allDifferent([Restaurant, Waiter, Bill, Time]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(billOf(Restaurant), Bill).
 */

 /*  fix_axiom_head(Time) ->
       call(billOf(Restaurant)=Bill).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(billOf(Restaurant)=Bill), holds_at(beWaiter8(Waiter), Time), allDifferent([Restaurant, Waiter, Bill, Time])] ->
       ta(Time, happens(pickUp(Waiter, Bill), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(billOf(Restaurant)=Bill), Time), holds_at(beWaiter8(Waiter), Time), allDifferent([Restaurant, Waiter, Bill, Time])] ->
       ta(Time, happens(pickUp(Waiter, Bill), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4371
axiom(happens(pickUp(Waiter, Bill), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(billOf(Restaurant)=Bill), Time),
      holds_at(beWaiter8(Waiter), Time),
      allDifferent([Restaurant, Waiter, Bill, Time])
    ]).

 /*  not(holds_at(beWaiter8(Waiter), Time)) :-
       equals(billOf(Restaurant), Bill),
       equals(waiterOf(Restaurant), Waiter),
       not(happens(pickUp(Waiter, Bill), Time)),
       allDifferent([Restaurant, Waiter, Bill, Time]).
 */

 /*  axiom_head(Time) ->
       equals(billOf(Restaurant), Bill).
 */

 /*  fix_axiom_head(Time) ->
       call(billOf(Restaurant)=Bill).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(billOf(Restaurant)=Bill), call(waiterOf(Restaurant)=Waiter), not(happens(pickUp(Waiter, Bill), Time)), allDifferent([Restaurant, Waiter, Bill, Time])] ->
       ta(Time, holds_at(neg(beWaiter8(Waiter)), Time)).
 */

 /*  [holds_at(call(billOf(Restaurant)=Bill), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(pickUp(Waiter, Bill), Time)), allDifferent([Restaurant, Waiter, Bill, Time])] ->
       ta(Time, holds_at(neg(beWaiter8(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter8(Waiter)), Time),
   
    [ holds_at(call(billOf(Restaurant)=Bill), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(pickUp(Waiter, Bill), Time)),
      allDifferent([Restaurant, Waiter, Bill, Time])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4373
% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Terminates(PickUp(waiter,bill),
%            BeWaiter8(waiter),
%            time).

 /*  [holds_at(beWaiter8(Waiter), Time)] ->
       ta(Time,
          terminates(pickUp(Waiter, Bill),
                     beWaiter8(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4377
axiom(terminates(pickUp(Waiter, Bill), beWaiter8(Waiter), Time),
    [holds_at(beWaiter8(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4379
% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Initiates(PickUp(waiter,bill),
%           BeWaiter9(waiter),
%           time).

 /*  [holds_at(beWaiter8(Waiter), Time)] ->
       ta(Time,
          initiates(pickUp(Waiter, Bill),
                    beWaiter9(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4383
axiom(initiates(pickUp(Waiter, Bill), beWaiter9(Waiter), Time),
    [holds_at(beWaiter8(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4385
% [restaurant,waiter,bill,table,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter9(waiter),time) ->
% Happens(PlaceOn(waiter,bill,table),time).

 /*  allDifferent([Restaurant, Waiter, Bill, Table, Time]) ->
       ( waiterOf(Restaurant)=Waiter, billOf(Restaurant)=Bill, tableOf(Restaurant)=Table, holds_at(beWaiter9(Waiter), Time)->happens(placeOn(Waiter, Bill, Table), Time)
       ).
 */

 /*  happens(placeOn(Waiter, Bill, Table), Time) :-
       ( equals(waiterOf(Restaurant), Waiter),
         equals(billOf(Restaurant), Bill),
         equals(tableOf(Restaurant), Table),
         holds_at(beWaiter9(Waiter), Time)
       ),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Bill,
                      Table,
                      Time
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  axiom_head(Time) ->
       equals(billOf(Restaurant), Bill).
 */

 /*  fix_axiom_head(Time) ->
       call(billOf(Restaurant)=Bill).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  [call(waiterOf(Restaurant)=Waiter), call(billOf(Restaurant)=Bill), call(tableOf(Restaurant)=Table), holds_at(beWaiter9(Waiter), Time), allDifferent([Restaurant, Waiter, Bill, Table, Time])] ->
       ta(Time,
          happens(placeOn(Waiter, Bill, Table), Time)).
 */

 /*  [holds_at(call(waiterOf(Restaurant)=Waiter), Time), holds_at(call(billOf(Restaurant)=Bill), Time), holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(beWaiter9(Waiter), Time), allDifferent([Restaurant, Waiter, Bill, Table, Time])] ->
       ta(Time,
          happens(placeOn(Waiter, Bill, Table), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4390
axiom(happens(placeOn(Waiter, Bill, Table), Time),
   
    [ holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      holds_at(call(billOf(Restaurant)=Bill), Time),
      holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(beWaiter9(Waiter), Time),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Bill,
                     Table,
                     Time
                   ])
    ]).

 /*  not(holds_at(beWaiter9(Waiter), Time)) :-
       equals(tableOf(Restaurant), Table),
       equals(billOf(Restaurant), Bill),
       equals(waiterOf(Restaurant), Waiter),
       not(happens(placeOn(Waiter, Bill, Table), Time)),
       allDifferent(
                    [ Restaurant,
                      Waiter,
                      Bill,
                      Table,
                      Time
                    ]).
 */

 /*  axiom_head(Time) ->
       equals(tableOf(Restaurant), Table).
 */

 /*  fix_axiom_head(Time) ->
       call(tableOf(Restaurant)=Table).
 */

 /*  axiom_head(Time) ->
       equals(billOf(Restaurant), Bill).
 */

 /*  fix_axiom_head(Time) ->
       call(billOf(Restaurant)=Bill).
 */

 /*  axiom_head(Time) ->
       equals(waiterOf(Restaurant), Waiter).
 */

 /*  fix_axiom_head(Time) ->
       call(waiterOf(Restaurant)=Waiter).
 */

 /*  [call(tableOf(Restaurant)=Table), call(billOf(Restaurant)=Bill), call(waiterOf(Restaurant)=Waiter), not(happens(placeOn(Waiter, Bill, Table), Time)), allDifferent([Restaurant, Waiter, Bill, Table, Time])] ->
       ta(Time, holds_at(neg(beWaiter9(Waiter)), Time)).
 */

 /*  [holds_at(call(tableOf(Restaurant)=Table), Time), holds_at(call(billOf(Restaurant)=Bill), Time), holds_at(call(waiterOf(Restaurant)=Waiter), Time), not(happens(placeOn(Waiter, Bill, Table), Time)), allDifferent([Restaurant, Waiter, Bill, Table, Time])] ->
       ta(Time, holds_at(neg(beWaiter9(Waiter)), Time)).
 */
axiom(holds_at(neg(beWaiter9(Waiter)), Time),
   
    [ holds_at(call(tableOf(Restaurant)=Table), Time),
      holds_at(call(billOf(Restaurant)=Bill), Time),
      holds_at(call(waiterOf(Restaurant)=Waiter), Time),
      not(happens(placeOn(Waiter, Bill, Table), Time)),
      allDifferent(
                   [ Restaurant,
                     Waiter,
                     Bill,
                     Table,
                     Time
                   ])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4392
% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Terminates(PlaceOn(waiter,bill,table),
%            BeWaiter9(waiter),
%            time).

 /*  [holds_at(beWaiter9(Waiter), Time)] ->
       ta(Time,
          terminates(placeOn(Waiter, Bill, Table),
                     beWaiter9(Waiter),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4396
axiom(terminates(placeOn(Waiter, Bill, Table), beWaiter9(Waiter), Time),
    [holds_at(beWaiter9(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4398
% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Initiates(PlaceOn(waiter,bill,table),
%           BeWaiter0(waiter),
%           time).

 /*  [holds_at(beWaiter9(Waiter), Time)] ->
       ta(Time,
          initiates(placeOn(Waiter, Bill, Table),
                    beWaiter0(Waiter),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4402
axiom(initiates(placeOn(Waiter, Bill, Table), beWaiter0(Waiter), Time),
    [holds_at(beWaiter9(Waiter), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4404
%; awaiting next waiter order

% fluent BeCook0(cook)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4406
fluent(beCook0(BeCook0_Ret)).
==> mpred_prop(beCook0(cook),fluent).
==> meta_argtypes(beCook0(cook)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4407
%; waiter order received

% fluent BeCook1(cook)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4409
fluent(beCook1(BeCook1_Ret)).
==> mpred_prop(beCook1(cook),fluent).
==> meta_argtypes(beCook1(cook)).

% xor BeCook0, BeCook1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4411
==> xor([beCook0,beCook1]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4412
% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Terminates(Order(agent,cook,food),
%            BeCook0(cook),
%            time).

 /*  [holds_at(beCook0(Cook), Time)] ->
       ta(Time,
          terminates(order(Agent, Cook, Food),
                     beCook0(Cook),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4416
axiom(terminates(order(Agent, Cook, Food), beCook0(Cook), Time),
    [holds_at(beCook0(Cook), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4418
% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Initiates(Order(agent,cook,food),
%           BeCook1(cook),
%           time).

 /*  [holds_at(beCook0(Cook), Time)] ->
       ta(Time,
          initiates(order(Agent, Cook, Food),
                    beCook1(Cook),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4422
axiom(initiates(order(Agent, Cook, Food), beCook1(Cook), Time),
    [holds_at(beCook0(Cook), Time)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4424
% event FoodPrepare(agent,food)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4425
event(foodPrepare(FoodPrepare_Param,FoodPrepare_Ret)).
==> mpred_prop(foodPrepare(agent,food),event).
==> meta_argtypes(foodPrepare(agent,food)).

% fluent FoodPrepared(food)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4427
fluent(foodPrepared(FoodPrepared_Ret)).
==> mpred_prop(foodPrepared(food),fluent).
==> meta_argtypes(foodPrepared(food)).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4428
% [agent,food,time]
% Initiates(FoodPrepare(agent,food),
%           FoodPrepared(food),
%           time).

 /*  [] ->
       ta(Time,
          initiates(foodPrepare(Agent, Food),
                    foodPrepared(Food),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4431
axiom(initiates(foodPrepare(Agent, Food), foodPrepared(Food), Time),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4433
% [agent,food,time]
% Happens(FoodPrepare(agent,food),time) ->
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4435
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).

 /*  exists([Location],
    happens(foodPrepare(Agent, Food), Time) ->
       holds_at(at(Agent, Location), Time),
       holds_at(at(Food, Location), Time)).
 */

 /*  not(happens(foodPrepare(Agent, Food), Time)) :-
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Food, Location), Time))
       ),
       some(Location, '$kolem_Fn_259'(Agent, Food, Time)).
 */

 /*  axiom_head(Time) ->
       (   not(holds_at(at(Agent, Location), Time))
       ;   not(holds_at(at(Food, Location), Time))
       ).
 */

 /*  fix_axiom_head(Time) ->
       (   holds_at(neg(at(Agent, Location)), Time)
       ;   holds_at(neg(at(Food, Location)), Time)
       ).
 */

 /*  [(holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Food, Location)), Time)), some(Location, '$kolem_Fn_259'(Agent, Food, Time))] ->
       ta(Time,
          not(happens(foodPrepare(Agent, Food), Time))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4437
axiom(not(happens(foodPrepare(Agent, Food), Time)),
   
    [  (holds_at(neg(at(Agent, Location)), Time);holds_at(neg(at(Food, Location)), Time)),
      some(Location, '$kolem_Fn_259'(Agent, Food, Time))
    ]).

 /*  holds_at(at(Agent, Location), Time) :-
       happens(foodPrepare(Agent, Food), Time),
       some(Location, '$kolem_Fn_259'(Agent, Food, Time)).
 */

 /*  [happens(foodPrepare(Agent, Food), Time), some(Location, '$kolem_Fn_259'(Agent, Food, Time))] ->
       ta(Time, holds_at(at(Agent, Location), Time)).
 */
axiom(holds_at(at(Agent, Location), Time),
   
    [ happens(foodPrepare(Agent, Food), Time),
      some(Location, '$kolem_Fn_259'(Agent, Food, Time))
    ]).

 /*  holds_at(at(Food, Location), Time) :-
       happens(foodPrepare(Agent, Food), Time),
       some(Location, '$kolem_Fn_259'(Agent, Food, Time)).
 */

 /*  [happens(foodPrepare(Agent, Food), Time), some(Location, '$kolem_Fn_259'(Agent, Food, Time))] ->
       ta(Time, holds_at(at(Food, Location), Time)).
 */
axiom(holds_at(at(Food, Location), Time),
   
    [ happens(foodPrepare(Agent, Food), Time),
      some(Location, '$kolem_Fn_259'(Agent, Food, Time))
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4439
% [cook,agent,food,time]
% HoldsAt(BeCook1(cook),time) &
% HoldsAt(KnowOrder(cook,agent,food),time) ->
% Happens(FoodPrepare(cook,food),time).

 /*  allDifferent([Cook, Time, Agent, Food]) ->
       ( holds_at(beCook1(Cook), Time), holds_at(knowOrder(Cook, Agent, Food), Time)->happens(foodPrepare(Cook, Food), Time)
       ).
 */

 /*  happens(foodPrepare(Cook, Food), Time) :-
       ( holds_at(beCook1(Cook), Time),
         holds_at(knowOrder(Cook, Agent, Food), Time)
       ),
       allDifferent([Cook, Time, Agent, Food]).
 */

 /*  [holds_at(beCook1(Cook), Time), holds_at(knowOrder(Cook, Agent, Food), Time), allDifferent([Cook, Time, Agent, Food])] ->
       ta(Time, happens(foodPrepare(Cook, Food), Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4442
axiom(happens(foodPrepare(Cook, Food), Time),
   
    [ holds_at(beCook1(Cook), Time),
      holds_at(knowOrder(Cook, Agent, Food), Time),
      allDifferent([Cook, Time, Agent, Food])
    ]).

 /*  not(holds_at(beCook1(Cook), Time)) :-
       holds_at(knowOrder(Cook, Agent, Food), Time),
       not(happens(foodPrepare(Cook, Food), Time)),
       allDifferent([Cook, Time, Agent, Food]).
 */

 /*  [holds_at(knowOrder(Cook, Agent, Food), Time), not(happens(foodPrepare(Cook, Food), Time)), allDifferent([Cook, Time, Agent, Food])] ->
       ta(Time, holds_at(neg(beCook1(Cook)), Time)).
 */
axiom(holds_at(neg(beCook1(Cook)), Time),
   
    [ holds_at(knowOrder(Cook, Agent, Food), Time),
      not(happens(foodPrepare(Cook, Food), Time)),
      allDifferent([Cook, Time, Agent, Food])
    ]).

 /*  not(holds_at(knowOrder(Cook, Agent, Food), Time)) :-
       holds_at(beCook1(Cook), Time),
       not(happens(foodPrepare(Cook, Food), Time)),
       allDifferent([Cook, Time, Agent, Food]).
 */

 /*  [holds_at(beCook1(Cook), Time), not(happens(foodPrepare(Cook, Food), Time)), allDifferent([Cook, Time, Agent, Food])] ->
       ta(Time,
          holds_at(neg(knowOrder(Cook, Agent, Food)), Time)).
 */
axiom(holds_at(neg(knowOrder(Cook, Agent, Food)), Time),
   
    [ holds_at(beCook1(Cook), Time),
      not(happens(foodPrepare(Cook, Food), Time)),
      allDifferent([Cook, Time, Agent, Food])
    ]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4444
% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Terminates(FoodPrepare(cook,food),
%            BeCook1(cook),
%            time).

 /*  [holds_at(beCook1(Cook), Time)] ->
       ta(Time,
          terminates(foodPrepare(Cook, Food),
                     beCook1(Cook),
                     Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4448
axiom(terminates(foodPrepare(Cook, Food), beCook1(Cook), Time),
    [holds_at(beCook1(Cook), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4450
% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Initiates(FoodPrepare(cook,food),
%           BeCook0(cook),
%           time).

 /*  [holds_at(beCook1(Cook), Time)] ->
       ta(Time,
          initiates(foodPrepare(Cook, Food),
                    beCook0(Cook),
                    Time)).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4454
axiom(initiates(foodPrepare(Cook, Food), beCook0(Cook), Time),
    [holds_at(beCook1(Cook), Time)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4456
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/EatingInAHouse.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:2004c,
%;   author = "Erik T. Mueller",
%;   year = "2004",
%;   title = "Understanding script-based stories using commonsense reasoning",
%;   journal = "Cognitive Systems Research",
%;   volume = "5",
%;   number = "4",
%;   pages = "307--340",
%; }
%;

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4485
% option modeldiff on
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4486
:- set_ec_option(modeldiff, on).
:- if(false).
:- endif.

% option encoding 3
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4487
:- set_ec_option(encoding, 3).
:- if(false).
:- endif.

% option renaming off
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4488
:- set_ec_option(renaming, off).
:- if(false).
:- endif.

% ignore Love, ThreatenedBy
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4490
ignore(love).
ignore(threatenedBy).

% ignore LookOutOnto, Floor, BuildingOf, SkyOf, GroundOf
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4491
ignore(lookOutOnto).
ignore(floor).
ignore(buildingOf).
ignore(skyOf).
ignore(groundOf).

% ignore Inside
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4492
ignore(inside).

% ignore Near, WalkFrom, WalkFromTo, RunFromTo
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4493
ignore(near).
ignore(walkFrom).
ignore(walkFromTo).
ignore(runFromTo).

% ignore BillOf, CookOf, TableOf, WaiterOf, KitchenDoorOf
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4494
ignore(billOf).
ignore(cookOf).
ignore(tableOf).
ignore(waiterOf).
ignore(kitchenDoorOf).

% ignore BeWaiter0, BeWaiter1, BeWaiter2, BeWaiter3, BeWaiter4
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4495
ignore(beWaiter0).
ignore(beWaiter1).
ignore(beWaiter2).
ignore(beWaiter3).
ignore(beWaiter4).

% ignore BeWaiter5, BeWaiter6, BeWaiter7, BeWaiter8, BeWaiter9
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4496
ignore(beWaiter5).
ignore(beWaiter6).
ignore(beWaiter7).
ignore(beWaiter8).
ignore(beWaiter9).

% ignore BeCook0, BeCook1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4497
ignore(beCook0).
ignore(beCook1).

% ignore InviteIn, InvitedIn, IntendToWalkIn, IntentionToWalkIn
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4498
ignore(inviteIn).
ignore(invitedIn).
ignore(intendToWalkIn).
ignore(intentionToWalkIn).

% ignore ActOnIntentionToWalkIn, Greet, SayGoodbye, CryForJoy
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4499
ignore(actOnIntentionToWalkIn).
ignore(greet).
ignore(sayGoodbye).
ignore(cryForJoy).

% ignore Threaten, ReleaseFromThreat, ThreatenedBy
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4500
ignore(threaten).
ignore(releaseFromThreat).
ignore(threatenedBy).

% ignore Order, KnowOrder, Request, KnowRequest
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4501
ignore(order).
ignore(knowOrder).
ignore(request).
ignore(knowRequest).

% ignore PutInside, TakeOutOf
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4502
ignore(putInside).
ignore(takeOutOf).

% ignore SayPleaseToMeet, Move
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4503
ignore(sayPleaseToMeet).
ignore(move).

% load foundations/Root.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4505
:- load_e('foundations/Root.e', changed).
:- if(false).
:- endif.

% load foundations/EC.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4506
:- load_e('foundations/EC.e', changed).
:- if(false).
:- endif.

% load answers/Mueller2003/Ontology.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4507
:- load_e('answers/Mueller2003/Ontology.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2003/Ontology.e').
:- endif.

% load answers/Mueller2004c/RTSpaceM.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4508
:- load_e('answers/Mueller2004c/RTSpaceM.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2004c/RTSpaceM.e').
:- endif.

% load answers/Mueller2004c/OTSpaceM.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4509
:- load_e('answers/Mueller2004c/OTSpaceM.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2004c/OTSpaceM.e').
:- endif.

% load answers/Mueller2004c/HungerNeed.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4510
:- load_e('answers/Mueller2004c/HungerNeed.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2004c/HungerNeed.e').
:- endif.

% load answers/Mueller2004c/Restaurant.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4511
:- load_e('answers/Mueller2004c/Restaurant.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2004c/Restaurant.e').
:- endif.

% load answers/Mueller2003/Sleep.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4512
:- load_e('answers/Mueller2003/Sleep.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2003/Sleep.e').
:- endif.

% load answers/Mueller2003/SpeechAct.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4513
:- load_e('answers/Mueller2003/SpeechAct.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2003/SpeechAct.e').
:- endif.

% load answers/Mueller2004c/Dress.e
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4514
:- load_e('answers/Mueller2004c/Dress.e', changed).
:- if(false).
 %  load(changed,'answers/Mueller2004c/Dress.e').
:- endif.

% room Upstairs1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4516
==> t(room,upstairs1).

% staircase Staircase1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4518
==> t(staircase,staircase1).

% room Hallway1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4520
==> t(room,hallway1).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4521
% Side1(Staircase1)=Hallway1.
side1(staircase1,hallway1).

 /*  axiom_head(Axiom_head_Ret) ->
       side1(staircase1, hallway1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side1(staircase1, hallway1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4522
% Side2(Staircase1)=Upstairs1.
side2(staircase1,upstairs1).

 /*  axiom_head(Axiom_head_Ret) ->
       side2(staircase1, upstairs1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side2(staircase1, upstairs1), Axiom_head_Ret).
 */

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4524
% door DiningRoomDoor1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4525
==> t(door,diningRoomDoor1).

% room DiningRoom1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4527
==> t(room,diningRoom1).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4528
% Side1(DiningRoomDoor1)=Hallway1.
side1(diningRoomDoor1,hallway1).

 /*  axiom_head(Axiom_head_Ret) ->
       side1(diningRoomDoor1, hallway1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side1(diningRoomDoor1, hallway1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4529
% Side2(DiningRoomDoor1)=DiningRoom1.
side2(diningRoomDoor1,diningRoom1).

 /*  axiom_head(Axiom_head_Ret) ->
       side2(diningRoomDoor1, diningRoom1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side2(diningRoomDoor1, diningRoom1), Axiom_head_Ret).
 */

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4531
% door KitchenDoor1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4532
==> t(door,kitchenDoor1).

% room Kitchen1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4534
==> t(room,kitchen1).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4535
% Side1(KitchenDoor1)=DiningRoom1.
side1(kitchenDoor1,diningRoom1).

 /*  axiom_head(Axiom_head_Ret) ->
       side1(kitchenDoor1, diningRoom1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side1(kitchenDoor1, diningRoom1), Axiom_head_Ret).
 */


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4536
% Side2(KitchenDoor1)=Kitchen1.
side2(kitchenDoor1,kitchen1).

 /*  axiom_head(Axiom_head_Ret) ->
       side2(kitchenDoor1, kitchen1).
 */

 /*  fix_axiom_head(Axiom_head_Ret) ->
       holds_at(side2(kitchenDoor1, kitchen1), Axiom_head_Ret).
 */

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4538
% agent Eater1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4539
==> t(agent,eater1).

% agent Eater2
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4541
==> t(agent,eater2).

% clothing Clothing1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4543
==> t(clothing,clothing1).

% clothing Clothing2
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4545
==> t(clothing,clothing2).

% chair Chair1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4547
==> t(chair,chair1).

% chair Chair2
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4549
==> t(chair,chair2).

% food Food1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4551
==> t(food,food1).

% agent Cook1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4553
==> t(agent,cook1).

% table Table1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4555
==> t(table,table1).

% content Content1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4557
==> t(content,content1).

% content Content2
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4559
==> t(content,content2).

% outside DummyOutside1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4561
==> t(outside,dummyOutside1).
%; prune

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4563
% sort ona, onb
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4564
==> sort(ona).
==> sort(onb).

% fluent! On(ona,onb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4565
fluent(on(On_Param,On_Ret)).
==> mpred_prop(on(ona,onb),fluent).
==> meta_argtypes(on(ona,onb)).

% event! PlaceOn(agent,ona,onb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4566
event(placeOn(PlaceOn_Param,_,PlaceOn_Ret)).
==> mpred_prop(placeOn(agent,ona,onb),event).
==> meta_argtypes(placeOn(agent,ona,onb)).

% event! TakeOffOf(agent,ona,onb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4567
event(takeOffOf(TakeOffOf_Param,_,TakeOffOf_Ret)).
==> mpred_prop(takeOffOf(agent,ona,onb),event).
==> meta_argtypes(takeOffOf(agent,ona,onb)).

% sort ordera, orderb, orderc
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4569
==> sort(ordera).
==> sort(orderb).
==> sort(orderc).

% event! Order(ordera,orderb,orderc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4570
event(order(Order_Param,_,Order_Ret)).
==> mpred_prop(order(ordera,orderb,orderc),event).
==> meta_argtypes(order(ordera,orderb,orderc)).

% fluent! KnowOrder(orderb,ordera,orderc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4571
fluent(knowOrder(KnowOrder_Param,_,KnowOrder_Ret)).
==> mpred_prop(knowOrder(orderb,ordera,orderc),fluent).
==> meta_argtypes(knowOrder(orderb,ordera,orderc)).

% sort requesta, requestb, requestc
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4573
==> sort(requesta).
==> sort(requestb).
==> sort(requestc).

% event! Request(requesta,requestb,requestc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4574
event(request(Request_Param,_,Request_Ret)).
==> mpred_prop(request(requesta,requestb,requestc),event).
==> meta_argtypes(request(requesta,requestb,requestc)).

% fluent! KnowRequest(requestb,requesta,requestc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4575
fluent(knowRequest(KnowRequest_Param,
		   _,
		   KnowRequest_Ret)).
==> mpred_prop(knowRequest(requestb,requesta,requestc),fluent).
==> meta_argtypes(knowRequest(requestb,requesta,requestc)).

% sort holda, holdb, holdc
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4577
==> sort(holda).
==> sort(holdb).
==> sort(holdc).

% event! TakeOffOf(holda,holdb,holdc)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4578
event(takeOffOf(TakeOffOf_Param,_,TakeOffOf_Ret)).
==> mpred_prop(takeOffOf(holda,holdb,holdc),event).
==> meta_argtypes(takeOffOf(holda,holdb,holdc)).

% event! PickUp(holda,holdb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4579
event(pickUp(PickUp_Param,PickUp_Ret)).
==> mpred_prop(pickUp(holda,holdb),event).
==> meta_argtypes(pickUp(holda,holdb)).

% event! LetGoOf(holda,holdb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4580
event(letGoOf(LetGoOf_Param,LetGoOf_Ret)).
==> mpred_prop(letGoOf(holda,holdb),event).
==> meta_argtypes(letGoOf(holda,holdb)).

% event! Hold(holda,holdb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4581
event(hold(Hold_Param,Hold_Ret)).
==> mpred_prop(hold(holda,holdb),event).
==> meta_argtypes(hold(holda,holdb)).

% fluent! Holding(holda,holdb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4582
fluent(holding(Holding_Param,Holding_Ret)).
==> mpred_prop(holding(holda,holdb),fluent).
==> meta_argtypes(holding(holda,holdb)).

% sort sita, sitb
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4584
==> sort(sita).
==> sort(sitb).

% event! LieOn(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4585
event(lieOn(LieOn_Param,LieOn_Ret)).
==> mpred_prop(lieOn(sita,sitb),event).
==> meta_argtypes(lieOn(sita,sitb)).

% event! SitOn(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4586
event(sitOn(SitOn_Param,SitOn_Ret)).
==> mpred_prop(sitOn(sita,sitb),event).
==> meta_argtypes(sitOn(sita,sitb)).

% event! RiseFrom(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4587
event(riseFrom(RiseFrom_Param,RiseFrom_Ret)).
==> mpred_prop(riseFrom(sita,sitb),event).
==> meta_argtypes(riseFrom(sita,sitb)).

% fluent! LyingOn(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4588
fluent(lyingOn(LyingOn_Param,LyingOn_Ret)).
==> mpred_prop(lyingOn(sita,sitb),fluent).
==> meta_argtypes(lyingOn(sita,sitb)).

% fluent! SittingOn(sita,sitb)
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4589
fluent(sittingOn(SittingOn_Param,SittingOn_Ret)).
==> mpred_prop(sittingOn(sita,sitb),fluent).
==> meta_argtypes(sittingOn(sita,sitb)).

% ona! Food1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4591
==> t(ona,food1).

% onb! Table1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4592
==> t(onb,table1).

% holda! Cook1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4593
==> t(holda,cook1).

% holdb! Food1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4594
==> t(holdb,food1).

% holdc! Table1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4595
==> t(holdc,table1).

% sita! Eater1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4596
==> t(sita,eater1).

% sitb! Chair1
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4597
==> t(sitb,chair1).
%; initial situation
% [agent]
 % HoldsAt(Dressed(agent),0).

 /*  [] ->
       ta(Ta_Param, initially(dressed(Agent))).
 */
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4599
axiom(initially(dressed(Agent)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4600
% [agent]
 % HoldsAt(Awake(agent),0).

 /*  [] ->
       ta(Ta_Param, initially(awake(Agent))).
 */
axiom(initially(awake(Agent)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4601
% [agent]
 % HoldsAt(Sleep3(agent),0).

 /*  [] ->
       ta(Ta_Param, initially(sleep3(Agent))).
 */
axiom(initially(sleep3(Agent)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4602
% [agent]
 % HoldsAt(Standing(agent),0).

 /*  [] ->
       ta(Ta_Param, initially(standing(Agent))).
 */
axiom(initially(standing(Agent)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4603
% [agent]
 % HoldsAt(Standing(agent),0).

 /*  [] ->
       ta(Ta_Param, initially(standing(Agent))).
 */
axiom(initially(standing(Agent)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4604
% [agent,object]
 % !HoldsAt(Holding(agent,object),0).
 %  not(initially(holding(Agent,Object))).

 /*  [] ->
       ta(Ta_Param, not(initially(holding(Agent, Object)))).
 */
axiom(not(initially(holding(Agent, Object))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4605
% [food]
 % HoldsAt(At(food,Kitchen1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(Food, kitchen1))).
 */
axiom(initially(at(Food, kitchen1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4606
% [food]
 % !HoldsAt(FoodPrepared(food),0).
 %  not(initially(foodPrepared(Food))).

 /*  [] ->
       ta(Ta_Param, not(initially(foodPrepared(Food)))).
 */
axiom(not(initially(foodPrepared(Food))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4607
% [agent]
 % HoldsAt(Hungry(agent),0).

 /*  [] ->
       ta(Ta_Param, initially(hungry(Agent))).
 */
axiom(initially(hungry(Agent)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4608
% [door]
 % HoldsAt(DoorIsOpen(door),0).

 /*  [] ->
       ta(Ta_Param, initially(doorIsOpen(Door))).
 */
axiom(initially(doorIsOpen(Door)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4609
% [clothing]
 % HoldsAt(At(clothing,Upstairs1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(Clothing, upstairs1))).
 */
axiom(initially(at(Clothing, upstairs1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4610
% [chair]
 % HoldsAt(At(chair,DiningRoom1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(Chair, diningRoom1))).
 */
axiom(initially(at(Chair, diningRoom1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4611
% HoldsAt(At(Cook1,Kitchen1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(cook1, kitchen1))).
 */
axiom(initially(at(cook1, kitchen1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4612
% HoldsAt(At(Table1,DiningRoom1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(table1, diningRoom1))).
 */
axiom(initially(at(table1, diningRoom1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4613
% [agent,clothing]
 % !HoldsAt(Wearing(agent,clothing),0).
 %  not(initially(wearing(Agent,Clothing))).

 /*  [] ->
       ta(Ta_Param, not(initially(wearing(Agent, Clothing)))).
 */
axiom(not(initially(wearing(Agent, Clothing))),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4615
%; narrative


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4616
% HoldsAt(At(Cook1,Kitchen1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(cook1, kitchen1))).
 */
axiom(initially(at(cook1, kitchen1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4617
% HoldsAt(At(Eater1,Upstairs1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(eater1, upstairs1))).
 */
axiom(initially(at(eater1, upstairs1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4618
% HoldsAt(At(Eater2,Upstairs1),0).

 /*  [] ->
       ta(Ta_Param, initially(at(eater2, upstairs1))).
 */
axiom(initially(at(eater2, upstairs1)),
    []).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4619
% Happens(FoodPrepare(Cook1,Food1),0).

 /*  axiom_head(0) ->
       is_time(0).
 */

 /*  fix_axiom_head(0) ->
       holds_at(is_time(0), 0).
 */

 /*  [holds_at(is_time(0), t)] ->
       ta(0, happens(foodPrepare(cook1, food1), t)).
 */
axiom(happens(foodPrepare(cook1, food1), t),
    [holds_at(is_time(0), t)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4620
% Happens(PutOn(Eater1,Clothing1),1).

 /*  axiom_head(1) ->
       is_time(1).
 */

 /*  fix_axiom_head(1) ->
       holds_at(is_time(1), 1).
 */

 /*  [holds_at(is_time(1), start), b(t, start), ignore(t+1==start)] ->
       ta(1, happens(putOn(eater1, clothing1), start)).
 */
axiom(happens(putOn(eater1, clothing1), start),
    [holds_at(is_time(1), start), b(t, start)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4621
% Happens(PutOn(Eater2,Clothing2),2).

 /*  axiom_head(2) ->
       is_time(2).
 */

 /*  fix_axiom_head(2) ->
       holds_at(is_time(2), 2).
 */

 /*  [holds_at(is_time(2), t2), b(t, t2), ignore(t+2==t2)] ->
       ta(2, happens(putOn(eater2, clothing2), t2)).
 */
axiom(happens(putOn(eater2, clothing2), t2),
    [holds_at(is_time(2), t2), b(t, t2)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4622
% Happens(WalkDownStaircase(Eater1,Staircase1),3).

 /*  axiom_head(3) ->
       is_time(3).
 */

 /*  fix_axiom_head(3) ->
       holds_at(is_time(3), 3).
 */

 /*  [holds_at(is_time(3), t3), b(t, t3), ignore(t+3==t3)] ->
       ta(3, happens(walkDownStaircase(eater1, staircase1), t3)).
 */
axiom(happens(walkDownStaircase(eater1, staircase1), t3),
    [holds_at(is_time(3), t3), b(t, t3)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4623
% Happens(WalkDownStaircase(Eater2,Staircase1),4).

 /*  axiom_head(4) ->
       is_time(4).
 */

 /*  fix_axiom_head(4) ->
       holds_at(is_time(4), 4).
 */

 /*  [holds_at(is_time(4), t4), b(t, t4), ignore(t+4==t4)] ->
       ta(4, happens(walkDownStaircase(eater2, staircase1), t4)).
 */
axiom(happens(walkDownStaircase(eater2, staircase1), t4),
    [holds_at(is_time(4), t4), b(t, t4)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4624
% Happens(WalkThroughDoor12(Eater1,DiningRoomDoor1),5).

 /*  axiom_head(5) ->
       is_time(5).
 */

 /*  fix_axiom_head(5) ->
       holds_at(is_time(5), 5).
 */

 /*  [holds_at(is_time(5), t5), b(t, t5), ignore(t+5==t5)] ->
       ta(5, happens(walkThroughDoor12(eater1, diningRoomDoor1), t5)).
 */
axiom(happens(walkThroughDoor12(eater1, diningRoomDoor1), t5),
    [holds_at(is_time(5), t5), b(t, t5)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4625
% Happens(WalkThroughDoor12(Eater2,DiningRoomDoor1),6).

 /*  axiom_head(6) ->
       is_time(6).
 */

 /*  fix_axiom_head(6) ->
       holds_at(is_time(6), 6).
 */

 /*  [holds_at(is_time(6), t6), b(t, t6), ignore(t+6==t6)] ->
       ta(6, happens(walkThroughDoor12(eater2, diningRoomDoor1), t6)).
 */
axiom(happens(walkThroughDoor12(eater2, diningRoomDoor1), t6),
    [holds_at(is_time(6), t6), b(t, t6)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4626
% Happens(SitOn(Eater1,Chair1),7).

 /*  axiom_head(7) ->
       is_time(7).
 */

 /*  fix_axiom_head(7) ->
       holds_at(is_time(7), 7).
 */

 /*  [holds_at(is_time(7), t7), b(t, t7), ignore(t+7==t7)] ->
       ta(7, happens(sitOn(eater1, chair1), t7)).
 */
axiom(happens(sitOn(eater1, chair1), t7),
    [holds_at(is_time(7), t7), b(t, t7)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4627
% Happens(SitOn(Eater2,Chair2),8).

 /*  axiom_head(8) ->
       is_time(8).
 */

 /*  fix_axiom_head(8) ->
       holds_at(is_time(8), 8).
 */

 /*  [holds_at(is_time(8), t8), b(t, t8), ignore(t+8==t8)] ->
       ta(8, happens(sitOn(eater2, chair2), t8)).
 */
axiom(happens(sitOn(eater2, chair2), t8),
    [holds_at(is_time(8), t8), b(t, t8)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4628
% Happens(PickUp(Cook1, Food1),9).

 /*  axiom_head(9) ->
       is_time(9).
 */

 /*  fix_axiom_head(9) ->
       holds_at(is_time(9), 9).
 */

 /*  [holds_at(is_time(9), t9), b(t, t9), ignore(t+9==t9)] ->
       ta(9, happens(pickUp(cook1, food1), t9)).
 */
axiom(happens(pickUp(cook1, food1), t9),
    [holds_at(is_time(9), t9), b(t, t9)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4629
% Happens(WalkThroughDoor21(Cook1, KitchenDoor1),10).

 /*  axiom_head(10) ->
       is_time(10).
 */

 /*  fix_axiom_head(10) ->
       holds_at(is_time(10), 10).
 */

 /*  [holds_at(is_time(10), t10), b(t, t10), ignore(t+10==t10)] ->
       ta(10, happens(walkThroughDoor21(cook1, kitchenDoor1), t10)).
 */
axiom(happens(walkThroughDoor21(cook1, kitchenDoor1), t10),
    [holds_at(is_time(10), t10), b(t, t10)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4630
% Happens(PlaceOn(Cook1, Food1, Table1),11).

 /*  axiom_head(11) ->
       is_time(11).
 */

 /*  fix_axiom_head(11) ->
       holds_at(is_time(11), 11).
 */

 /*  [holds_at(is_time(11), t11), b(t, t11), ignore(t+11==t11)] ->
       ta(11, happens(placeOn(cook1, food1, table1), t11)).
 */
axiom(happens(placeOn(cook1, food1, table1), t11),
    [holds_at(is_time(11), t11), b(t, t11)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4631
% Happens(WalkThroughDoor12(Cook1, KitchenDoor1),12).

 /*  axiom_head(12) ->
       is_time(12).
 */

 /*  fix_axiom_head(12) ->
       holds_at(is_time(12), 12).
 */

 /*  [holds_at(is_time(12), t12), b(t, t12), ignore(t+12==t12)] ->
       ta(12, happens(walkThroughDoor12(cook1, kitchenDoor1), t12)).
 */
axiom(happens(walkThroughDoor12(cook1, kitchenDoor1), t12),
    [holds_at(is_time(12), t12), b(t, t12)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4632
% Happens(Eat(Eater1,Food1),13).

 /*  axiom_head(13) ->
       is_time(13).
 */

 /*  fix_axiom_head(13) ->
       holds_at(is_time(13), 13).
 */

 /*  [holds_at(is_time(13), t13), b(t, t13), ignore(t+13==t13)] ->
       ta(13, happens(eat(eater1, food1), t13)).
 */
axiom(happens(eat(eater1, food1), t13),
    [holds_at(is_time(13), t13), b(t, t13)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4633
% Happens(Eat(Eater2,Food1),14).

 /*  axiom_head(14) ->
       is_time(14).
 */

 /*  fix_axiom_head(14) ->
       holds_at(is_time(14), 14).
 */

 /*  [holds_at(is_time(14), t14), b(t, t14), ignore(t+14==t14)] ->
       ta(14, happens(eat(eater2, food1), t14)).
 */
axiom(happens(eat(eater2, food1), t14),
    [holds_at(is_time(14), t14), b(t, t14)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4634
% Happens(Converse(Eater1,Eater2),15).

 /*  axiom_head(15) ->
       is_time(15).
 */

 /*  fix_axiom_head(15) ->
       holds_at(is_time(15), 15).
 */

 /*  [holds_at(is_time(15), t15), b(t, t15), ignore(t+15==t15)] ->
       ta(15, happens(converse(eater1, eater2), t15)).
 */
axiom(happens(converse(eater1, eater2), t15),
    [holds_at(is_time(15), t15), b(t, t15)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4635
% Happens(TalkAbout(Eater1,Content1),16).

 /*  axiom_head(16) ->
       is_time(16).
 */

 /*  fix_axiom_head(16) ->
       holds_at(is_time(16), 16).
 */

 /*  [holds_at(is_time(16), t16), b(t, t16), ignore(t+16==t16)] ->
       ta(16, happens(talkAbout(eater1, content1), t16)).
 */
axiom(happens(talkAbout(eater1, content1), t16),
    [holds_at(is_time(16), t16), b(t, t16)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4636
% Happens(TalkAbout(Eater2,Content2),17).

 /*  axiom_head(17) ->
       is_time(17).
 */

 /*  fix_axiom_head(17) ->
       holds_at(is_time(17), 17).
 */

 /*  [holds_at(is_time(17), t17), b(t, t17), ignore(t+17==t17)] ->
       ta(17, happens(talkAbout(eater2, content2), t17)).
 */
axiom(happens(talkAbout(eater2, content2), t17),
    [holds_at(is_time(17), t17), b(t, t17)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4637
% Happens(RiseFrom(Eater1,Chair1),18).

 /*  axiom_head(18) ->
       is_time(18).
 */

 /*  fix_axiom_head(18) ->
       holds_at(is_time(18), 18).
 */

 /*  [holds_at(is_time(18), t18), b(t, t18), ignore(t+18==t18)] ->
       ta(18, happens(riseFrom(eater1, chair1), t18)).
 */
axiom(happens(riseFrom(eater1, chair1), t18),
    [holds_at(is_time(18), t18), b(t, t18)]).


% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4638
% Happens(RiseFrom(Eater2,Chair2),19).

 /*  axiom_head(19) ->
       is_time(19).
 */

 /*  fix_axiom_head(19) ->
       holds_at(is_time(19), 19).
 */

 /*  [holds_at(is_time(19), t19), b(t, t19), ignore(t+19==t19)] ->
       ta(19, happens(riseFrom(eater2, chair2), t19)).
 */
axiom(happens(riseFrom(eater2, chair2), t19),
    [holds_at(is_time(19), t19), b(t, t19)]).

% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4640
% range time 0 20
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4641
==> range(time,0,20).

% range offset 0 0
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4642
==> range(offset,0,0).

% range diameter 0 0
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4643
==> range(diameter,0,0).

% completion Happens
% From /opt/logicmoo_workspace/packs_sys/logicmoo_nlu/prolog/ec_planner/ectest/ec_reader_test.e:4645
==> completion(happens).
%; End of file.
